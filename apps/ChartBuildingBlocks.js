module('apps.ChartBuildingBlocks').requires('lively.morphic.AdditionalMorphs', 'apps.d3').toRun(function() {


lively.morphic.Box.subclass('apps.ChartBuildingBlocks.ChartRenderer',

'Template', {
    renderHooks: [
        'prepareContext',
        'makeDrawingPane',
        'drawDimensions',
        'drawSeries',
        'setupScales'
    ]
},

'Adding parts', {
    activeRenderPartClassName: 'active-render-part',

    addMorph: function($super, morph, optMorphBefore) {
        $super(morph, optMorphBefore);
        this.connectHooks();
        return morph;
    },
    removeMorph: function($super, morph) {
        morph.removeStyleClassName(this.activeRenderPartClassName);
        $super(morph);
        this.connectHooks();
    },
    connectHooks: function() {
        // Iterates over all submorphs and checks for hook implementations
        this.resetHooks();
        this.renderHooks.each(function(hookName){
                var m, i = this.submorphs.length - 1;
                for (; (m = this.submorphs[i]); i--) {
                    var hook = m[hookName];
                    if (hook && typeof hook === 'function' && !this.getHook(hookName)) {
                        m.addStyleClassName(this.activeRenderPartClassName);
                        this.registerHook(hookName, hook);
                        continue;
                    }
                }
            }, this)
    },
    resetHooks: function() {
        this.renderHooks.each(function(h) {
            delete this[h+'Hook'];
        }, this);

        this.submorphs.each(function(m){
            m.removeStyleClassName(this.activeRenderPartClassName)
        }, this);
    },
    registerHook: function (hookName, hook) {
        this[hookName+'Hook'] = hook;
    },
    getHook: function(hookName) {
        var hook = this[hookName+'Hook'];
        if (hook && typeof hook === 'function') {
            return hook;
        } else {
            return null;
        }
    }

},

'Template methods', {

    makeDrawingPane: function(context, area) {
	// Override to create a custom surface to be used as a 
	// drawing context for the chart content.
        // Per default returns the context itself.
        var hook = this.makeDrawingPaneHook;
        if (hook && typeof hook === 'function') {
            return hook(context, area);
        } else {
            return context;
        }
    },
    drawDimensions: function(context, dimensions, scales, area) {
        // Override this method to set up and draw your chart's axes
	//
	// context: a d3 node to draw your axes onto,
	// dimensions: an array of simple dimension representations
	// (i.e. [{id: 'x', title: 'X Axis', unit: 'Time'}])
        var hook = this.drawDimensionsHook;
        if (hook && typeof hook === 'function') {
            return hook(context, dimensions, scales, area);
        }
    },
    drawSeries: function(context, series, scales) {
	// Override to draw the information contained by the dataset's series
	// onto a drawing context (in general the content pane
	// generated by the 'makeContentPane' method).
        var hook = this.drawSeriesHook;
        if (hook && typeof hook === 'function') {
            return hook(context, series, scales);
        }
    },
    setupScales: function(data, area) {
	// Override to draw the information contained by the dataset's series
	// onto a drawing context (in general the content pane
	// generated by the 'makeContentPane' method).
        var hook = this.setupScalesHook;
        if (hook && typeof hook === 'function') {
            return hook(data, area);
        } else {
            return {}
        }
    },
    prepareContext: function(context) {
        // Override to customize the DOM context of the chart.
        // Returns an SVG node with a group node per default.
        var hook = this.prepareContextHook;
        if (hook && typeof hook === 'function') {
            return hook(context);
        } else {
            var ctxH = $(context).height(),
                ctxW = $(context).width();

            $(context).empty();

            return d3.select(context).append("svg:svg")
                .attr("width", ctxW)
                .attr("height", ctxH)
                .append("svg:g");
        }
    },
},
'drawing', {
    draw: function(context, data, area) {
        var dimensions = data.getDimensions(),
            series = data.getSeries(),

            // Creates an SVG context for the chart
            contextPane = this.prepareContext(context),

            // Template hook for making a pane for the actual content
            drawingPane = this.makeDrawingPane(contextPane, area),

            // Create scales for the data's dimensions
            scales = this.setupScales(data, area);

        // Template hook for drawing axes
        this.drawDimensions(contextPane, dimensions, scales, area);

        // Template hook for drawing the series
        this.drawSeries(drawingPane, series, scales);
    },
});



lively.morphic.HtmlWrapperMorph.subclass('apps.ChartBuildingBlocks.ChartDisplay',

'init', {
    initialize: function($super, bounds) {
        $super(bounds);
        this.redrawOnResize = true;
    }
},
'drawing', {
    getDrawingArea: function() {
        var padding = this.padding || [0,0,0,0];
        return new Rectangle(
                padding[3],
                padding[0],
                this.getExtent().x - padding [3] - padding[1],
                this.getExtent().y - padding [2] - padding[0]
            );
    },
    draw: function() {
        var context = this.renderContext().shapeNode,
            area = this.getDrawingArea();
        if (this.chartRenderer.draw) {
            this.chartRenderer.draw(context, this.chartData, area);
        } else {
            console.warn('The ChartDisplay has no ChartRenderer so nothing can be drawn right now.');
        }
        // call connected ChartRenderer.draw(context)
    },

});


}) // end of module