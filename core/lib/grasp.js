(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, compact, unlines, min, max;
  ref$ = require('prelude-ls'), id = ref$.id, compact = ref$.compact, unlines = ref$.unlines, min = ref$.min, max = ref$.max;
  module.exports = {
    formatResult: formatResult,
    formatName: formatName,
    formatCount: formatCount
  };
  function formatResult(name, inputLines, inputLinesLength, arg$, options, node){
    var color, bold, resStartLine, startLine, resEndLine, endLine, startCol, endCol, highlight, onlyMatch, outputLines, res$, i$, lineNum, line, start, middle, end, rest, cleanLines, multiline, outputString, displayStartLine, displayEndLine, locationString, separatorString, nameString;
    color = arg$.color, bold = arg$.bold;
    resStartLine = node.loc.start.line - 1;
    startLine = max(resStartLine - options.beforeContext, 0);
    resEndLine = node.loc.end.line - 1;
    endLine = min(resEndLine + options.afterContext, inputLinesLength - 1);
    startCol = node.loc.start.column;
    endCol = node.loc.end.column;
    highlight = function(){
      return color.red(bold.apply(this, arguments));
    };
    onlyMatch = options.onlyMatching;
    res$ = [];
    for (i$ = startLine; i$ <= endLine; ++i$) {
      lineNum = i$;
      line = inputLines[lineNum];
      if (lineNum < resStartLine || lineNum > resEndLine) {
        if (onlyMatch) {
          res$.push('');
        } else {
          res$.push(line);
        }
      } else if (lineNum === resStartLine && resStartLine === resEndLine) {
        start = onlyMatch
          ? ''
          : line.slice(0, startCol);
        middle = line.slice(startCol, endCol);
        end = onlyMatch
          ? ''
          : line.slice(endCol);
        res$.push(start + "" + highlight(middle) + end);
      } else if (resStartLine < lineNum && lineNum < resEndLine) {
        res$.push(highlight(line));
      } else if (lineNum === resStartLine) {
        start = onlyMatch
          ? ''
          : line.slice(0, startCol);
        rest = line.slice(startCol);
        res$.push(start + "" + highlight(rest));
      } else {
        end = onlyMatch
          ? ''
          : line.slice(endCol);
        rest = line.slice(0, endCol);
        res$.push(highlight(rest) + "" + end);
      }
    }
    outputLines = res$;
    cleanLines = (onlyMatch ? compact : id)(outputLines);
    multiline = cleanLines.length > 1;
    outputString = unlines(cleanLines);
    displayStartLine = node.loc.start.line;
    displayEndLine = node.loc.end.line;
    locationString = options.colNumber
      ? color.green((options.lineNumber ? displayStartLine + "," : '') + "" + startCol) + "" + color.cyan('-') + "" + color.green((options.lineNumber ? displayEndLine + "," : '') + "" + (endCol - 1))
      : options.lineNumber ? multiline
        ? displayStartLine === displayEndLine
          ? color.green(displayStartLine)
          : color.green(displayStartLine) + "" + color.green('-') + "" + color.green(displayEndLine)
        : color.green(displayStartLine) : '';
    separatorString = (multiline ? color.cyan((locationString.length ? ':' : '') + "(multiline)") : '') + "" + (locationString.length || multiline ? color.cyan(':') : '') + "" + (multiline ? '\n' : '');
    nameString = options.displayFilename ? formatName(color, name) + "" + color.cyan(':') : '';
    return nameString + "" + locationString + "" + separatorString + "" + outputString;
  }
  function formatName(color, name){
    return color.magenta(name);
  }
  function formatCount(color, count, name){
    return (name ? formatName(color, name) + "" + color.cyan(':') : '') + "" + count;
  }
}).call(this);

},{"prelude-ls":90}],2:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, flatten, join, lines, unlines, chars, unchars, syntax, syntaxFlat, aliasMap, attrMapInverse, matchesMap, matchesAliasMap, pad, options, generateSyntaxHelp, generateSyntaxHelpForNode, generateCategoryHelp, generateHelpForCategory;
  ref$ = require('prelude-ls'), map = ref$.map, flatten = ref$.flatten, join = ref$.join, lines = ref$.lines, unlines = ref$.unlines, chars = ref$.chars, unchars = ref$.unchars;
  ref$ = require('grasp-syntax-javascript'), syntax = ref$.syntax, syntaxFlat = ref$.syntaxFlat, aliasMap = ref$.aliasMap, attrMapInverse = ref$.attrMapInverse, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap;
  pad = require('./text').pad;
  options = require('./options').options;
  generateSyntaxHelp = function(){
    var maxNameLen, syntaxInfo, res$, category, ref$, nodesInCat, lresult$, nodeName, ref1$, alias, nodes, ref2$, nodeArrays, primitives, getFieldStrings, fieldStrings, nameString, nameStringLen, syntaxInfoStrings, i$, len$, nodesInfo, nodeStrings, prepend, append;
    maxNameLen = 0;
    res$ = [];
    for (category in ref$ = syntax) {
      nodesInCat = ref$[category];
      lresult$ = [];
      for (nodeName in nodesInCat) {
        ref1$ = nodesInCat[nodeName], alias = ref1$.alias, nodes = (ref2$ = ref1$.nodes) != null
          ? ref2$
          : [], nodeArrays = (ref2$ = ref1$.nodeArrays) != null
          ? ref2$
          : [], primitives = (ref2$ = ref1$.primitives) != null
          ? ref2$
          : [];
        getFieldStrings = fn$;
        fieldStrings = getFieldStrings('', nodes).concat(getFieldStrings('%', nodeArrays), getFieldStrings('&', primitives));
        nameString = alias + " (" + nodeName + ")";
        nameStringLen = nameString.length;
        if (nameStringLen > maxNameLen) {
          maxNameLen = nameStringLen;
        }
        lresult$.push([nameString, fieldStrings.join(', ')]);
      }
      res$.push(lresult$);
    }
    syntaxInfo = res$;
    res$ = [];
    for (i$ = 0, len$ = syntaxInfo.length; i$ < len$; ++i$) {
      nodesInfo = syntaxInfo[i$];
      nodeStrings = map(fn1$, nodesInfo);
      res$.push("\n" + unlines(nodeStrings));
    }
    syntaxInfoStrings = res$;
    prepend = 'JavaScript abstract syntax help:\na list of possible node types, and their fields\n`--help node-name` for more information about a node\n`--help categories` for information about categories of nodes\n\nnode-name (FullOfficialName)   field1, field2 (alias), field3...\nfield  - this field contains another node\n%field - this field contains an array of other nodes\n&field - this field contains a primitive value, such as a boolean or a string\n-----------------------------';
    append = 'Based on the Mozilla Parser API <https://developer.mozilla.org/docs/SpiderMonkey/Parser_API>';
    return prepend + "" + unlines(syntaxInfoStrings) + "\n\n" + append;
    function fn$(type, fields){
      return map(function(it){
        var that;
        if (that = attrMapInverse[it]) {
          return type + "" + it + " (" + type + that.join(", " + type) + ")";
        } else {
          return type + "" + it;
        }
      }, fields);
    }
    function fn1$(it){
      return pad(it[0], maxNameLen) + "  " + it[1];
    }
  };
  generateSyntaxHelpForNode = function(nodeName){
    var ref$, alias, nodes, nodeArrays, primitives, syntax, example, note, nameStr, strs, res$, i$, len$, ref1$, type, fields, syntaxStr, exampleStr, examples, ex, line, noteStr;
    ref$ = syntaxFlat[nodeName], alias = ref$.alias, nodes = ref$.nodes, nodeArrays = ref$.nodeArrays, primitives = ref$.primitives, syntax = ref$.syntax, example = ref$.example, note = ref$.note;
    nameStr = alias + " (" + nodeName + ")";
    res$ = [];
    for (i$ = 0, len$ = (ref$ = [['node', nodes], ['node array', nodeArrays], ['primitive', primitives]]).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], type = ref1$[0], fields = ref1$[1];
      if (fields) {
        res$.push("\n" + type + " fields: " + map(fn$, fields).join(', '));
      }
    }
    strs = res$;
    syntaxStr = syntax ? "\nsyntax:\n" + unlines(map(function(it){
      return "  " + it;
    }, lines(syntax))) : '';
    exampleStr = example ? (examples = (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [].concat(example)).length; i$ < len$; ++i$) {
        ex = ref$[i$];
        results$.push(unlines((fn$())));
      }
      return results$;
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = lines(ex)).length; i$ < len$; ++i$) {
          line = ref$[i$];
          results$.push("  " + line);
        }
        return results$;
      }
    }()), "\nexample" + (examples.length > 1 ? 's' : '') + ":\n" + unlines(examples)) : '';
    noteStr = note ? "\nnote: " + note : '';
    return nameStr + "\n" + repeatString$('=', nameStr.length) + unchars(strs) + syntaxStr + exampleStr + noteStr;
    function fn$(it){
      var that;
      if (that = attrMapInverse[it]) {
        return it + " (alias: " + that.join(', ') + ")";
      } else {
        return it;
      }
    }
  };
  generateCategoryHelp = function(){
    var categories, res$, alias, ref$, category, fullNodeNames, names, prepend, append;
    res$ = [];
    for (alias in ref$ = matchesAliasMap) {
      category = ref$[alias];
      fullNodeNames = matchesMap[category];
      names = map(fn$, fullNodeNames);
      res$.push(alias + " (" + category + "): " + names.join(', '));
    }
    categories = res$;
    prepend = 'Categories of node types:';
    append = '`--help syntax` for node information.\n`--help category-name` for further information about a category.';
    return prepend + "\n\n" + unlines(categories) + "\n\n" + append;
    function fn$(it){
      return syntaxFlat[it].alias;
    }
  };
  generateHelpForCategory = function(name){
    var invertedAliases, res$, key, ref$, value, alias, fullNodeNames, names, nameStr;
    res$ = {};
    for (key in ref$ = matchesAliasMap) {
      value = ref$[key];
      res$[value] = key;
    }
    invertedAliases = res$;
    alias = invertedAliases[name];
    fullNodeNames = matchesMap[name];
    names = map(function(it){
      return syntaxFlat[it].alias + " (" + it + ")";
    }, fullNodeNames);
    nameStr = alias + " (" + name + ")";
    return "A node type category.\n\n" + nameStr + "\n" + repeatString$('=', nameStr.length) + "\n" + unlines(names);
  };
  module.exports = function(generateHelp, generateHelpForOption, positional, interpolate){
    var helpStrings, res$, i$, len$, arg, lresult$, that, dashes, optionName, j$, ref$, len1$, o, item, sep, name;
    if (positional.length) {
      res$ = [];
      for (i$ = 0, len$ = positional.length; i$ < len$; ++i$) {
        arg = positional[i$];
        lresult$ = [];
        if (arg === 'advanced') {
          lresult$.push(generateHelp({
            showHidden: true,
            interpolate: interpolate
          }));
        } else if (that = /^(--?)(\S+)/.exec(arg)) {
          dashes = that[1], optionName = that[2];
          if (dashes.length === 2) {
            lresult$.push(generateHelpForOption(optionName));
          } else {
            for (j$ = 0, len1$ = (ref$ = chars(optionName)).length; j$ < len1$; ++j$) {
              o = ref$[j$];
              lresult$.push(generateHelpForOption(o));
            }
          }
        } else if (arg === 'more') {
          lresult$.push(generateHelpForOption('help'));
        } else if (arg === 'verbose') {
          for (j$ = 0, len1$ = (ref$ = options).length; j$ < len1$; ++j$) {
            item = ref$[j$];
            if (that = item.heading) {
              sep = repeatString$('#', that.length + 4);
              lresult$.push(sep + "\n# " + that + " #\n" + sep);
            } else {
              lresult$.push(generateHelpForOption(item.option));
            }
          }
        } else if (arg === 'syntax') {
          lresult$.push(generateSyntaxHelp());
        } else if (arg === 'categories') {
          lresult$.push(generateCategoryHelp());
        } else {
          if (aliasMap[arg] || syntaxFlat[arg]) {
            name = aliasMap[arg] || arg;
            lresult$.push(generateSyntaxHelpForNode(name));
          } else if (matchesMap[arg] || matchesAliasMap[arg]) {
            name = matchesAliasMap[arg] || arg;
            lresult$.push(generateHelpForCategory(name));
          } else {
            lresult$.push("No such help option: " + arg + ".");
          }
        }
        res$.push(lresult$);
      }
      helpStrings = res$;
      return join('\n\n')(
      flatten(
      helpStrings));
    } else {
      return generateHelp({
        interpolate: interpolate
      });
    }
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{"./options":4,"./text":6,"grasp-syntax-javascript":63,"prelude-ls":90}],3:[function(require,module,exports){
(function (process){
// Generated by LiveScript 1.2.0
(function(){
  var path, acorn, squery, equery, async, ref$, min, sortWith, lines, chars, split, join, map, Obj, format, formatResult, formatName, formatCount, replace, parseOptions, generateHelp, generateHelpForOption, help, _console, version, run, getQueryEngine, slice$ = [].slice, toString$ = {}.toString;
  path = require('path');
  acorn = window.acorn;
  squery = require('grasp-squery');
  equery = require('grasp-equery');
  async = require('async');
  ref$ = require('prelude-ls'), min = ref$.min, sortWith = ref$.sortWith, lines = ref$.lines, chars = ref$.chars, split = ref$.split, join = ref$.join, map = ref$.map, Obj = ref$.Obj;
  format = require('./format'), formatResult = format.formatResult, formatName = format.formatName, formatCount = format.formatCount;
  replace = require('./replace').replace;
  ref$ = require('./options'), parseOptions = ref$.parse, generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
  help = require('./help');
  _console = console;
  version = '0.2.1';
  run = function(arg$){
    var ref$, args, error, ref1$, callback, exit, data, stdin, fs, textFormat, input, console, options, positional, debug, e, versionString, getHelp, helpString, queryEngine, parser, parserOptions, that, selector, targets, targetsLen, replacement, isDir, color, bold, textFormatFuncs, resultsData, resultsFormat, callCallback, out, parsedSelector, resultsSortFunc, search, processResults, getToMap, end, exts, testExt, targetPaths, searchTarget, cwd;
    ref$ = arg$ != null
      ? arg$
      : {}, args = ref$.args, error = (ref1$ = ref$.error) != null
      ? ref1$
      : function(it){
        throw new Error(it);
      }, callback = (ref1$ = ref$.callback) != null
      ? ref1$
      : function(){}, exit = (ref1$ = ref$.exit) != null
      ? ref1$
      : function(){}, data = (ref1$ = ref$.data) != null ? ref1$ : false, stdin = ref$.stdin, fs = (ref1$ = ref$.fs) != null
      ? ref1$
      : require('fs'), textFormat = (ref1$ = ref$.textFormat) != null
      ? ref1$
      : require('cli-color'), input = ref$.input, console = (ref1$ = ref$.console) != null ? ref1$ : _console;
    if (args == null) {
      error('Error: Must specify arguments.');
      exit(2);
      return;
    }
    try {
      options = parseOptions(args), positional = options._, debug = options.debug;
    } catch (e$) {
      e = e$;
      error(e.message);
      exit(2);
      return;
    }
    if (debug) {
      console.time('everything');
      console.log('options:');
      console.log(options);
    }
    if (options.version) {
      versionString = "grasp v" + version;
      callback(versionString);
      exit(0, versionString);
      return;
    }
    getHelp = function(positional){
      positional == null && (positional = []);
      return help(generateHelp, generateHelpForOption, positional, {
        version: version
      });
    };
    if (options.help) {
      helpString = getHelp(positional);
      callback(helpString);
      exit(0, helpString);
      return;
    }
    queryEngine = options.engine
      ? require(options.engine)
      : options.squery
        ? squery
        : options.equery ? equery : squery;
    ref$ = (function(){
      switch (options.parser[0]) {
      case 'acorn':
        return [acorn, options.parser[1]];
      default:
        return [require(options.parser[0]), options.parser[1]];
      }
    }()), parser = ref$[0], parserOptions = ref$[1];
    options.context == null && (options.context = (ref$ = options.NUM) != null ? ref$ : 0);
    options.beforeContext == null && (options.beforeContext = options.context);
    options.afterContext == null && (options.afterContext = options.context);
    if (that = options.file) {
      try {
        selector = fs.readFileSync(that, 'utf8');
      } catch (e$) {
        e = e$;
        error("Error: No such file '" + options.file + "'.");
        exit(2);
        return;
      }
      targets = positional;
    } else {
      selector = positional[0];
      targets = slice$.call(positional, 1);
    }
    if (!targets.length) {
      targets = options.recursive
        ? ['.']
        : ['-'];
    }
    targetsLen = targets.length;
    if (that = options.replace || options.replaceFunc) {
      replacement = that;
    } else if (that = options.replaceFile) {
      try {
        replacement = fs.readFileSync(that, 'utf8').replace(/([\s\S]*)\n$/, '$1');
      } catch (e$) {
        e = e$;
        error("Error: No such file '" + options.replaceFile + "'.");
        exit(2);
        return;
      }
    }
    if (selector == null) {
      error('Error: No selector specified.');
      helpString = getHelp();
      callback(helpString);
      exit(2, helpString);
      return;
    }
    if ((that = options.filename) != null) {
      options.displayFilename = that;
    } else if (targetsLen > 1) {
      options.displayFilename = true;
    } else {
      try {
        isDir = targets[0] === '-'
          ? false
          : fs.lstatSync(targets[0]).isDirectory();
        if (isDir && !options.recursive) {
          console.warn("'" + targets[0] + "' is a directory. Use '-r, --recursive' to recursively search directories.");
        }
        options.displayFilename = isDir;
      } catch (e$) {
        e = e$;
        error("Error: No such file or directory '" + targets[0] + "'.");
        exit(2);
        return;
      }
    }
    color = Obj.map(function(it){
      if (options.color) {
        return it;
      } else {
        return function(it){
          return it + "";
        };
      }
    }, {
      green: textFormat.green,
      cyan: textFormat.cyan,
      magenta: textFormat.magenta,
      red: textFormat.red
    });
    bold = textFormat.bold;
    textFormatFuncs = {
      color: color,
      bold: bold
    };
    resultsData = [];
    resultsFormat = 'default';
    callCallback = !options.quiet && !options.json && !options.to && !options.inPlace;
    out = function(it){
      resultsData.push(it);
      if (callCallback) {
        callback(it);
      }
    };
    if (debug) {
      console.time('parse-selector');
    }
    parsedSelector = queryEngine.parse(selector);
    if (debug) {
      console.timeEnd('parse-selector');
      console.log('parsed-selector:');
      console.log(JSON.stringify(parsedSelector));
    }
    resultsSortFunc = function(a, b){
      var aStart, bStart, lineDiff;
      aStart = a.loc.start;
      bStart = b.loc.start;
      lineDiff = aStart.line - bStart.line;
      if (lineDiff === 0) {
        return aStart.column - bStart.column;
      } else {
        return lineDiff;
      }
    };
    search = function(name, input){
      var cleanInput, parsedInput, e, results, resultsLen, count, that, sortedResults, slicedResults, replaced, inputLines, inputLinesLength, i$, len$, result;
      if (debug) {
        console.time("search-total:" + name);
      }
      cleanInput = input.replace(/^#!.*\n/, '');
      try {
        if (debug) {
          console.time("parse-input:" + name);
        }
        parsedInput = parser.parse(cleanInput, parserOptions);
        if (debug) {
          console.timeEnd("parse-input:" + name);
        }
      } catch (e$) {
        e = e$;
        throw new Error("Error: Could not parse JavaScript from '" + name + "'. " + e.message);
      }
      if (debug) {
        console.time("query:" + name);
      }
      results = queryEngine.queryParsed(parsedSelector, parsedInput);
      if (debug) {
        console.timeEnd("query:" + name);
      }
      resultsLen = results.length;
      count = (that = options.maxCount) != null ? min(that, resultsLen) : resultsLen;
      sortedResults = sortWith(resultsSortFunc, results);
      slicedResults = slice$.call(sortedResults, 0, count);
      if (replacement != null) {
        try {
          replaced = replace(replacement, cleanInput, slicedResults, queryEngine);
          if (options.to || options.inPlace) {
            resultsFormat = 'pairs';
            out([name, replaced]);
          } else {
            out(replaced);
          }
        } catch (e$) {
          e = e$;
          console.error(name + ": Error during replacement. " + e.message + ".");
        }
      } else if (options.count) {
        if (options.displayFilename) {
          if (options.json || data) {
            resultsFormat = 'pairs';
            out([name, count]);
          } else {
            out(formatCount(color, count, name));
          }
        } else {
          out(options.json || data
            ? count
            : formatCount(color, count));
        }
      } else if (options.filesWithoutMatch || options.filesWithMatches) {
        if (options.filesWithMatches && count || options.filesWithoutMatch && !count) {
          out(options.json || data
            ? name
            : formatName(color, name));
        }
      } else {
        if (options.json || data) {
          if (options.displayFilename) {
            resultsFormat = 'pairs';
            out([name, slicedResults]);
          } else {
            resultsFormat = 'lists';
            out(slicedResults);
          }
        } else {
          inputLines = lines(cleanInput);
          inputLinesLength = cleanInput.length;
          for (i$ = 0, len$ = slicedResults.length; i$ < len$; ++i$) {
            result = slicedResults[i$];
            out(formatResult(name, inputLines, inputLinesLength, textFormatFuncs, options, result));
          }
        }
      }
      if (debug) {
        console.timeEnd("search-total:" + name);
      }
    };
    processResults = function(){
      if (resultsData.length) {
        if (resultsFormat === 'pairs') {
          return Obj.pairsToObj(resultsData);
        } else if (resultsFormat === 'lists') {
          if (targetsLen === 1) {
            return resultsData[0];
          } else {
            return resultsData;
          }
        } else {
          return resultsData;
        }
      } else {
        return [];
      }
    };
    getToMap = function(inputPaths){
      var mapping, i$, len$, inputPath;
      if (options.inPlace) {
        return Obj.listsToObj(inputPaths, inputPaths);
      } else if (toString$.call(options.to).slice(8, -1) === 'Object') {
        return options.to;
      } else {
        mapping = {};
        for (i$ = 0, len$ = inputPaths.length; i$ < len$; ++i$) {
          inputPath = inputPaths[i$];
          mapping[inputPath] = options.to.replace(/%/, path.basename(inputPath, path.extname(inputPath)));
        }
        return mapping;
      }
    };
    end = function(inputPaths){
      var exitCode, processedResults, toMap, inputPath, contents, targetPath, jsonString;
      exitCode = resultsData.length ? 0 : 1;
      processedResults = processResults();
      if (replacement && options.to || options.inPlace) {
        toMap = getToMap(inputPaths);
        for (inputPath in processedResults) {
          contents = processedResults[inputPath];
          targetPath = toMap[inputPath];
          if (targetPath === '-') {
            callback(contents);
          } else {
            if (targetPath) {
              fs.writeFileSync(targetPath, contents);
            }
          }
        }
      } else if (options.json) {
        jsonString = JSON.stringify(processedResults);
        callback(jsonString);
      }
      if (debug) {
        console.timeEnd('everything');
      }
      return exit(exitCode, options.json ? jsonString : processedResults);
    };
    exts = options.extensions;
    testExt = exts.length === 0 || exts.length === 1 && exts[0] === '.'
      ? function(){
        return true;
      }
      : function(it){
        return it.match(RegExp('\\.(?:' + exts.join('|') + ')$'));
      };
    targetPaths = [];
    searchTarget = function(basePath, upPath){
      return function(target, done){
        var output, targetPath, stat, fileContents, displayPath, e;
        try {
          if (target === '-') {
            if (!stdin) {
              throw new Error('Error: stdin not defined.');
            }
            targetPaths.push('-');
            output = '';
            stdin.setEncoding('utf-8');
            stdin.on('data', (function(it){
              return output += it;
            }));
            stdin.on('end', function(){
              var e;
              try {
                search('(standard input)', output);
              } catch (e$) {
                e = e$;
                console.error(e.message);
              }
              return done();
            });
            stdin.resume();
          } else {
            targetPath = path.resolve(upPath, target);
            stat = fs.lstatSync(targetPath);
            if (stat.isDirectory() && options.recursive) {
              async.eachSeries(fs.readdirSync(targetPath), searchTarget(basePath, targetPath), function(){
                return done();
              });
            } else if (stat.isFile() && testExt(target)) {
              fileContents = fs.readFileSync(targetPath, 'utf8');
              displayPath = path.relative(basePath, targetPath);
              targetPaths.push(displayPath);
              search(displayPath, fileContents);
              done();
            } else {
              done();
            }
          }
        } catch (e$) {
          e = e$;
          console.error(e.message);
          done();
        }
      };
    };
    if (input) {
      search('(input)', input);
      return end(['-']);
    } else {
      cwd = process.cwd();
      async.eachSeries(targets, searchTarget(cwd, cwd), function(){
        return end(targetPaths);
      });
    }
  };
  getQueryEngine = function(it){
    return {
      squery: 'grasp-squery',
      equery: 'grasp-equery'
    }[it] || it;
  };
  run.VERSION = version;
  run.search = curry$(function(engine, selector, input){
    return run({
      args: {
        _: [selector],
        engine: getQueryEngine(engine)
      },
      input: input,
      data: true,
      exit: function(arg$, results){
        return results;
      }
    });
  });
  run.replace = curry$(function(engine, selector, replacement, input){
    var args;
    args = {
      _: [selector],
      engine: getQueryEngine(engine)
    };
    if (toString$.call(replacement).slice(8, -1) === 'Function') {
      args.replaceFunc = replacement;
    } else {
      args.replace = replacement;
    }
    return run({
      args: args,
      input: input,
      exit: function(arg$, results){
        return results;
      }
    });
  });
  module.exports = run;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

}).call(this,require("hXUCVB"))
},{"./format":1,"./help":2,"./options":4,"./replace":5,"async":8,"cli-color":11,"fs":91,"grasp-equery":56,"grasp-squery":60,"hXUCVB":93,"path":92,"prelude-ls":90}],4:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var optionator, options, ref$;
  optionator = require('optionator');
  options = [
    {
      heading: 'Miscellaneous'
    }, {
      option: 'help',
      alias: 'h',
      type: 'Boolean',
      description: "display this help and exit '--help more' for more help info",
      longDescription: '`--help` displays help for options\n`-h` may be used at any time in place of `--help`\n`--help more` displays this help\n`--help --option-name` displays further help for that option\nfor example: `--help --help` would display this information\n`--help verbose` displays the same help as `--help --option-name`, but for all options\n`--help syntax` displays information about JavaScript\'s syntax\n`--help node-name` displays further information about a JavaScript node\nfor example: `--help if` displays more information about an if statement\n`--help categories` displays information about node type categories\n`--help category-name` displays further information about a node type category\n`--help advanced` displays help for all options, including those hidden by default',
      example: ['--help', '--help --replace', '--help -R', '--help syntax'],
      restPositional: true
    }, {
      option: 'version',
      alias: 'v',
      type: 'Boolean',
      description: 'print version information and exit'
    }, {
      option: 'debug',
      alias: 'd',
      type: 'Boolean',
      description: 'output debug information'
    }, {
      option: 'extensions',
      alias: 'x',
      type: '[String]',
      description: 'comma separated list of acceptable file extensions',
      longDescription: "A comma separated list of acceptable file extensions. Use a dot `.` for any extension.",
      example: ['--extensions js,json', '--extensions .'],
      'default': 'js'
    }, {
      option: 'recursive',
      alias: 'r',
      type: 'Boolean',
      description: 'recursively search directories',
      longDescription: "Recursively search directories. If files or paths are left out, then `.` is assumed."
    }, {
      option: 'parser',
      alias: 'p',
      type: '(path::String, options::Maybe Object)',
      description: 'require path for parser, using options when calling parse',
      longDescription: 'Sets the parser and options for the parser. Argument value is a tuple, with the first item being the require path, and the second an optional object with options for the parser when calling its parse function.',
      'default': '(acorn, {locations: true})',
      hidden: true,
      example: '--parser "(./path/to/esprima, {loc: true})"'
    }, {
      heading: 'Replacement'
    }, {
      option: 'replace',
      alias: 'R',
      type: 'replacement::String',
      description: "replace each match with replacement, use `--help --replace` for more info",
      longDescription: 'Each node that is matched will be replaced with the text that you input. There are a couple of special cases:\nThe text `{{}}` will be replaced with the source of the matched node.\n`{{selector}}` will be replaced with the first result of querying the matched node with the selector. If you used equery to get the results, then the replacement selector will be parsed as equery.\nSince positional arguments may appear anywhere, you can place the `--replace replacement` after the selector if you wish, eg. `selector --replace replacement file.js`.\nBy default, the result of using `--replace` will be to print out the results - if you wish to create new file(s) you can check out the `--to` option, or if you wish to edit the input file(s) in place, take a look at the `--in-place` option.',
      example: ['--replace foo', "--replace 'f({{}})'", "--replace 'while ({{.test}}) {\\n{{.then call}};\\n}'"]
    }, {
      option: 'replace-file',
      alias: 'F',
      type: 'file::String',
      description: 'replace each match with contents of file',
      example: '--replace-file path/to/file'
    }, {
      option: 'replace-func',
      type: 'Function',
      description: 'use function instead of string pattern when using as library',
      hidden: true
    }, {
      option: 'to',
      alias: 't',
      type: 'Object | String',
      description: "write replaced output to file(s), `--help --to` for more info",
      longDescription: 'If an object, the keys are the paths to the input files, and the values are the corresponding output paths.\nIf a string, then the output is written to the path specified. The special character `%` is expanded to the current input file\'s filename.',
      example: ['--to "{input.js: output.js, path/to/input2.js: path/to/output2.js}"', '--to "output/%.js"']
    }, {
      option: 'in-place',
      alias: 'i',
      type: 'Boolean',
      description: "overwrite input files with replaced output"
    }, {
      heading: 'Selector interpretation'
    }, {
      option: 'engine',
      alias: 'g',
      type: 'path::String',
      description: 'require path for query engine',
      longDescription: "The require path for the query engine. The query engine must have `parse(selector) -> parsedSelector`, `queryParsed(parsedSelector, ast) -> results`, and `query(selector, ast) -> results` functions exposed.",
      hidden: true,
      example: '--engine path/to/engine'
    }, {
      option: 'squery',
      alias: 's',
      type: 'Boolean',
      description: "use squery - selector query - css style selectors"
    }, {
      option: 'equery',
      alias: 'e',
      type: 'Boolean',
      description: "use equery - example query - use code example with wildcards",
      longDescription: "Use equery - example query - instead of the default squery. Use by typing in an example of the code you want (formatting is irrelevant), with optional wildcards. It is less powerful, but may be easier to use for simpler tasks, than squery. For more information, use `--help equery`."
    }, {
      option: 'file',
      alias: 'f',
      type: 'file::String',
      description: 'obtain selector from file',
      example: '--file path/to/selector-file'
    }, {
      heading: 'Output control'
    }, {
      option: 'max-count',
      alias: 'm',
      type: 'n::Int',
      description: 'stop after n matches',
      example: '--max-count 2'
    }, {
      option: 'line-number',
      alias: 'n',
      type: 'Boolean',
      'default': 'true',
      description: 'print line number with output lines'
    }, {
      option: 'col-number',
      alias: 'b',
      type: 'Boolean',
      description: 'print column number with output lines'
    }, {
      option: 'filename',
      alias: 'H',
      type: 'Boolean',
      description: 'print the file name for each match (opposite: `--no-filename`)'
    }, {
      option: 'only-matching',
      alias: 'o',
      type: 'Boolean',
      description: 'show only the matching part of the line(s)'
    }, {
      option: 'quiet',
      alias: ['q', 'silent'],
      type: 'Boolean',
      description: 'suppress all normal output'
    }, {
      option: 'files-without-match',
      alias: 'W',
      type: 'Boolean',
      description: 'print only names of files containing no match'
    }, {
      option: 'files-with-matches',
      alias: 'w',
      type: 'Boolean',
      description: 'print only names of files containing matches'
    }, {
      option: 'count',
      alias: 'c',
      type: 'Boolean',
      description: 'print only a count of matches per file'
    }, {
      option: 'color',
      alias: ['O', 'colour'],
      type: 'Boolean',
      'default': 'true',
      description: 'use color to highlight matches'
    }, {
      option: 'json',
      alias: 'j',
      type: 'Boolean',
      description: 'JSON output for matches',
      longDescription: 'Prints out JSON for the output instead of formatted results. This will print out the node data as JSON, instead of the formatted text.'
    }, {
      heading: 'Context control'
    }, {
      option: 'before-context',
      alias: 'B',
      type: 'n::Int',
      description: 'print n lines of leading context',
      example: ['--before-context 3', '-B 3']
    }, {
      option: 'after-context',
      alias: 'A',
      type: 'n::Int',
      description: 'print n lines of trailing context',
      example: ['--after-context 2', '-A 2']
    }, {
      option: 'context',
      alias: 'C',
      type: 'n::Int',
      description: 'print n lines of output context',
      example: ['--context 1', '-C 1']
    }, {
      option: 'NUM',
      type: 'Int',
      description: 'same as --context NUM',
      example: '-3'
    }
  ];
  module.exports = (ref$ = optionator({
    prepend: 'Usage: grasp [option]... [selector] [file]...\n\nSearch (or --replace) for selector in file(s) or standard input.\nFor more help \'--help more\', \'--help --option-name\', \'--help syntax\'\nExample: grasp --context 2 \'if.test bi[op="<"]\' file.js file2.js',
    append: "Version {{version}}\n<http://graspjs.com/>",
    mutuallyExclusive: [['replace', 'replace-file', 'replace-func']],
    options: options
  }), ref$.options = options, ref$);
}).call(this);

},{"optionator":77}],5:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, lines, unlines, filter, fold, capitalize, camelize, dasherize, levn, getRaw, filterRegex, replacer, getReplacementFunc, replace, slice$ = [].slice, toString$ = {}.toString;
  ref$ = require('prelude-ls'), lines = ref$.lines, unlines = ref$.unlines, filter = ref$.filter, fold = ref$.fold, capitalize = ref$.capitalize, camelize = ref$.camelize, dasherize = ref$.dasherize;
  levn = require('levn');
  getRaw = function(input, node){
    var raw, that;
    raw = (that = node.raw)
      ? that
      : node.start != null
        ? input.slice(node.start, node.end)
        : node.key != null && node.value != null ? input.slice(node.key.start, node.value.end) : '';
    node.raw = raw;
    return (node.rawPrepend || '') + "" + raw + (node.rawAppend || '');
  };
  filterRegex = /\s+\|\s+([-a-zA-Z]+)((?:\s+(?:'(?:\\'|[^'])*'|"(?:\\"|[^"])*"|[^\|\s]+))*)/;
  replacer = function(input, node, queryEngine){
    return function(arg$, replacementArg){
      var origResults, ref$, filters, selector, that, e, results, rawPrepend, rawAppend, join, textOperations, filterName, argsStr, args, pre, post, i$, len$, arg, result, n, len, rawResults, res$, outputString;
      if (/^\s*\|\s+/.test(replacementArg)) {
        origResults = [node];
        ref$ = (" " + replacementArg.trim()).split(filterRegex), filters = slice$.call(ref$, 1);
      } else {
        ref$ = replacementArg.trim().split(filterRegex), selector = ref$[0], filters = slice$.call(ref$, 1);
        if (that = (ref$ = node._named) != null ? ref$[selector] : void 8) {
          origResults = [].concat(that);
        } else {
          try {
            origResults = queryEngine.query(selector, node);
          } catch (e$) {
            e = e$;
            origResults = queryEngine.query(replacementArg, node);
            filters = [];
          }
        }
      }
      if (origResults.length) {
        results = origResults;
        rawPrepend = '';
        rawAppend = '';
        join = null;
        textOperations = [];
        while (filters.length) {
          filterName = filters.shift();
          argsStr = filters.shift().trim();
          argsStr += filters.shift();
          args = levn.parse('Array', argsStr);
          if (!args.length && (filterName === 'prepend' || filterName === 'before' || filterName === 'after' || filterName === 'prepend' || filterName === 'append' || filterName === 'wrap' || filterName === 'nth' || filterName === 'nth-last' || filterName === 'slice' || filterName === 'each' || filterName === 'replace' || filterName === 'substring' || filterName === 'substr' || filterName === 'str-slice')) {
            throw new Error("No arguments supplied for '" + filterName + "' filter");
          } else if (in$(filterName, ['replace']) && args.length < 2) {
            throw new Error("Must supply at least two arguments for '" + filterName + "' filter");
          }
          switch (filterName) {
          case 'join':
            join = args.length ? args[0] + "" : '';
            break;
          case 'before':
            rawPrepend = args[0] + "" + rawPrepend;
            break;
          case 'after':
            rawAppend += args[0] + "";
            break;
          case 'wrap':
            ref$ = args.length === 1 ? [args[0], args[0]] : args, pre = ref$[0], post = ref$[1];
            rawPrepend = pre + "" + rawPrepend;
            rawAppend += post + "";
            break;
          case 'prepend':
            for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
              arg = args[i$];
              results.unshift({
                type: 'Raw',
                raw: arg + ""
              });
            }
            break;
          case 'append':
            for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
              arg = args[i$];
              results.push({
                type: 'Raw',
                raw: arg + ""
              });
            }
            break;
          case 'each':
            if (args.length < 2) {
              throw new Error("No arguments supplied for 'each " + args[0] + "'");
            }
            switch (args[0]) {
            case 'before':
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawPrepend = args[1] + "" + ((ref$ = result.rawPrepend) != null ? ref$ : '');
              }
              break;
            case 'after':
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawAppend = ((ref$ = result.rawAppend) != null ? ref$ : '') + "" + args[1];
              }
              break;
            case 'wrap':
              ref$ = args.length === 2
                ? [args[1], args[1]]
                : [args[1], args[2]], pre = ref$[0], post = ref$[1];
              for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
                result = results[i$];
                result.rawPrepend = pre + "" + ((ref$ = result.rawPrepend) != null ? ref$ : '');
                result.rawAppend = ((ref$ = result.rawAppend) != null ? ref$ : '') + "" + post;
              }
              break;
            default:
              throw new Error("'" + args[0] + "' is not supported by 'each'");
            }
            break;
          case 'nth':
            n = +args[0];
            results = results.slice(n, n + 1);
            break;
          case 'nth-last':
            n = results.length - +args[0] - 1;
            results = results.slice(n, n + 1);
            break;
          case 'first':
          case 'head':
            results = results.slice(0, 1);
            break;
          case 'tail':
            results = results.slice(1);
            break;
          case 'last':
            len = results.length;
            results = results.slice(len - 1, len);
            break;
          case 'initial':
            results = results.slice(0, results.length - 1);
            break;
          case 'slice':
            results = [].slice.apply(results, args);
            break;
          case 'reverse':
            results.reverse();
            break;
          case 'replace':
            (fn$.call(this, args));
            break;
          case 'lowercase':
            textOperations.push(fn1$);
            break;
          case 'uppercase':
            textOperations.push(fn2$);
            break;
          case 'capitalize':
            textOperations.push(capitalize);
            break;
          case 'uncapitalize':
            textOperations.push(fn3$);
            break;
          case 'camelize':
            textOperations.push(camelize);
            break;
          case 'dasherize':
            textOperations.push(dasherize);
            break;
          case 'trim':
            textOperations.push(fn4$);
            break;
          case 'substring':
            (fn5$.call(this, args));
            break;
          case 'substr':
            (fn6$.call(this, args));
            break;
          case 'str-slice':
            (fn7$.call(this, args));
            break;
          default:
            throw new Error("Invalid filter: " + filterName + (argsStr ? " " + argsStr : ''));
          }
        }
        res$ = [];
        for (i$ = 0, len$ = results.length; i$ < len$; ++i$) {
          result = results[i$];
          res$.push(getRaw(input, result));
        }
        rawResults = res$;
        outputString = rawPrepend + "" + (join != null
          ? rawResults.join(join)
          : rawResults[0]) + rawAppend;
        if (textOperations.length) {
          return fold(curry$(function(x$, y$){
            return y$(x$);
          }), outputString, textOperations);
        } else {
          return outputString;
        }
      } else {
        return '';
      }
      function fn$(args){
        textOperations.push(function(it){
          return it.replace(args[0], args[1]);
        });
      }
      function fn1$(it){
        return it.toLowerCase();
      }
      function fn2$(it){
        return it.toUpperCase();
      }
      function fn3$(it){
        return it.charAt(0).toLowerCase() + it.slice(1);
      }
      function fn4$(it){
        return it.trim();
      }
      function fn5$(args){
        textOperations.push(function(it){
          return it.substring(args[0], args[1]);
        });
      }
      function fn6$(args){
        textOperations.push(function(it){
          return it.substr(args[0], args[1]);
        });
      }
      function fn7$(args){
        textOperations.push(function(it){
          return it.slice(args[0], args[1]);
        });
      }
    };
  };
  getReplacementFunc = function(replacement, input, queryEngine){
    var replacementPrime;
    if (toString$.call(replacement).slice(8, -1) === 'Function') {
      return function(node){
        return replacement(function(it){
          return getRaw(input, it);
        }, node, function(it){
          return queryEngine.query(it, node);
        }, node._named);
      };
    } else {
      replacementPrime = replacement.replace(/\\n/g, '\n');
      return function(node){
        return replacementPrime.replace(/{{}}/g, function(){
          return getRaw(input, node);
        }).replace(/{{((?:[^}]|}[^}])+)}}/g, replacer(input, node, queryEngine));
      };
    }
  };
  replace = function(replacement, input, nodes, queryEngine){
    var inputLines, colOffset, lineOffset, lastLine, prevNode, replaceNode, i$, len$, node, ref$, start, end, startLineNum, endLineNum, numberOfLines, startCol, endCol, replaceLines, startLine, endLine, startContext, endContext, replaceLast, endLen;
    inputLines = lines(input);
    colOffset = 0;
    lineOffset = 0;
    lastLine = null;
    prevNode = {
      end: 0
    };
    replaceNode = getReplacementFunc(replacement, input, queryEngine);
    for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
      node = nodes[i$];
      if (node.start < prevNode.end) {
        continue;
      }
      ref$ = node.loc, start = ref$.start, end = ref$.end;
      startLineNum = start.line - 1 + lineOffset;
      endLineNum = end.line - 1 + lineOffset;
      numberOfLines = endLineNum - startLineNum + 1;
      colOffset = lastLine === startLineNum ? colOffset : 0;
      startCol = start.column + colOffset;
      endCol = end.column + (startLineNum === endLineNum ? colOffset : 0);
      replaceLines = lines(replaceNode(node));
      startLine = inputLines[startLineNum];
      endLine = inputLines[endLineNum];
      startContext = startLine.slice(0, startCol);
      endContext = endLine.slice(endCol);
      replaceLines[0] = startContext + "" + replaceLines[0];
      replaceLast = replaceLines[replaceLines.length - 1];
      endLen = replaceLast.length;
      replaceLines[replaceLines.length - 1] = replaceLast + "" + endContext;
      inputLines.splice.apply(inputLines, [startLineNum, numberOfLines].concat(slice$.call(replaceLines)));
      lineOffset += replaceLines.length - numberOfLines;
      colOffset += endLen - endCol;
      lastLine = endLineNum + lineOffset;
      prevNode = node;
    }
    return unlines(inputLines);
  };
  module.exports = {
    replace: replace
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);

},{"levn":71,"prelude-ls":90}],6:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var pad;
  pad = function(str, num){
    var len, padAmount;
    len = str.length;
    padAmount = num - len;
    return str + "" + repeatString$(' ', padAmount > 0 ? padAmount : 0);
  };
  module.exports = {
    pad: pad
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{}],7:[function(require,module,exports){
window.grasp = require("./lib");

},{"./lib":3}],8:[function(require,module,exports){
(function (process){
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require("hXUCVB"))
},{"hXUCVB":93}],9:[function(require,module,exports){
'use strict';

module.exports = [
	"000000", "800000", "008000", "808000", "000080", "800080", "008080", "c0c0c0",
	"808080", "ff0000", "00ff00", "ffff00", "0000ff", "ff00ff", "00ffff", "ffffff",

	"000000", "00005f", "000087", "0000af", "0000d7", "0000ff",
	"005f00", "005f5f", "005f87", "005faf", "005fd7", "005fff",
	"008700", "00875f", "008787", "0087af", "0087d7", "0087ff",
	"00af00", "00af5f", "00af87", "00afaf", "00afd7", "00afff",
	"00d700", "00d75f", "00d787", "00d7af", "00d7d7", "00d7ff",
	"00ff00", "00ff5f", "00ff87", "00ffaf", "00ffd7", "00ffff",

	"5f0000", "5f005f", "5f0087", "5f00af", "5f00d7", "5f00ff",
	"5f5f00", "5f5f5f", "5f5f87", "5f5faf", "5f5fd7", "5f5fff",
	"5f8700", "5f875f", "5f8787", "5f87af", "5f87d7", "5f87ff",
	"5faf00", "5faf5f", "5faf87", "5fafaf", "5fafd7", "5fafff",
	"5fd700", "5fd75f", "5fd787", "5fd7af", "5fd7d7", "5fd7ff",
	"5fff00", "5fff5f", "5fff87", "5fffaf", "5fffd7", "5fffff",

	"870000", "87005f", "870087", "8700af", "8700d7", "8700ff",
	"875f00", "875f5f", "875f87", "875faf", "875fd7", "875fff",
	"878700", "87875f", "878787", "8787af", "8787d7", "8787ff",
	"87af00", "87af5f", "87af87", "87afaf", "87afd7", "87afff",
	"87d700", "87d75f", "87d787", "87d7af", "87d7d7", "87d7ff",
	"87ff00", "87ff5f", "87ff87", "87ffaf", "87ffd7", "87ffff",

	"af0000", "af005f", "af0087", "af00af", "af00d7", "af00ff",
	"af5f00", "af5f5f", "af5f87", "af5faf", "af5fd7", "af5fff",
	"af8700", "af875f", "af8787", "af87af", "af87d7", "af87ff",
	"afaf00", "afaf5f", "afaf87", "afafaf", "afafd7", "afafff",
	"afd700", "afd75f", "afd787", "afd7af", "afd7d7", "afd7ff",
	"afff00", "afff5f", "afff87", "afffaf", "afffd7", "afffff",

	"d70000", "d7005f", "d70087", "d700af", "d700d7", "d700ff",
	"d75f00", "d75f5f", "d75f87", "d75faf", "d75fd7", "d75fff",
	"d78700", "d7875f", "d78787", "d787af", "d787d7", "d787ff",
	"d7af00", "d7af5f", "d7af87", "d7afaf", "d7afd7", "d7afff",
	"d7d700", "d7d75f", "d7d787", "d7d7af", "d7d7d7", "d7d7ff",
	"d7ff00", "d7ff5f", "d7ff87", "d7ffaf", "d7ffd7", "d7ffff",

	"ff0000", "ff005f", "ff0087", "ff00af", "ff00d7", "ff00ff",
	"ff5f00", "ff5f5f", "ff5f87", "ff5faf", "ff5fd7", "ff5fff",
	"ff8700", "ff875f", "ff8787", "ff87af", "ff87d7", "ff87ff",
	"ffaf00", "ffaf5f", "ffaf87", "ffafaf", "ffafd7", "ffafff",
	"ffd700", "ffd75f", "ffd787", "ffd7af", "ffd7d7", "ffd7ff",
	"ffff00", "ffff5f", "ffff87", "ffffaf", "ffffd7", "ffffff",

	"080808", "121212", "1c1c1c", "262626", "303030", "3a3a3a",
	"444444", "4e4e4e", "585858", "626262", "6c6c6c", "767676",
	"808080", "8a8a8a", "949494", "9e9e9e", "a8a8a8", "b2b2b2",
	"bcbcbc", "c6c6c6", "d0d0d0", "dadada", "e4e4e4", "eeeeee"
];

},{}],10:[function(require,module,exports){
'use strict';

var push = Array.prototype.push, reduce = Array.prototype.reduce, abs = Math.abs
  , colors, match, result, i;

colors = require('./_xterm-colors').map(function (color) {
	return {
		r: parseInt(color.slice(0, 2), 16),
		g: parseInt(color.slice(2, 4), 16),
		b: parseInt(color.slice(4), 16)
	};
});

match = colors.slice(0, 16);

module.exports = result = [];

i = 0;
while (i < 8) {
	result.push(30 + i++);
}
i = 0;
while (i < 8) {
	result.push(90 + i++);
}
push.apply(result, colors.slice(16).map(function (data) {
	var index, diff = Infinity;
	match.every(function (match, i) {
		var ndiff = reduce.call('rgb', function (diff, channel) {
			return (diff += abs(match[channel] - data[channel]));
		}, 0);
		if (ndiff < diff) {
			index = i;
			diff = ndiff;
		}
		return ndiff;
	});
	return result[index];
}));

},{"./_xterm-colors":9}],11:[function(require,module,exports){
(function (process){
'use strict';

var d       = require('es5-ext/lib/Object/descriptor')
  , extend  = require('es5-ext/lib/Object/extend')
  , map     = require('es5-ext/lib/Object/map')
  , reduce  = require('es5-ext/lib/Object/reduce')
  , repeat  = require('es5-ext/lib/String/prototype/repeat')
  , memoize = require('memoizee')
  , tty     = require('tty')

  , join = Array.prototype.join, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties, abs = Math.abs
  , floor = Math.floor, max = Math.max, min = Math.min

  , mods, proto, getFn, getMove, xtermMatch
  , up, down, right, left, getHeight, memoized;

mods = extend({
	// Style
	bold:      { _bold: [1, 22] },
	italic:    { _italic: [3, 23] },
	underline: { _underline: [4, 24] },
	blink:     { _blink: [5, 25] },
	inverse:   { _inverse: [7, 27] },
	strike:    { _strike: [9, 29] }
},

	// Color
	['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white']
		.reduce(function (obj, color, index) {
		// foreground
		obj[color] = { _fg: [30 + index, 39] };
		obj[color + 'Bright'] = { _fg: [90 + index, 39] };

		// background
		obj['bg' + color[0].toUpperCase() + color.slice(1)] =
			{ _bg: [40 + index, 49] };
		obj['bg' + color[0].toUpperCase() + color.slice(1) + 'Bright'] =
			{ _bg: [100 + index, 49] };

		return obj;
	}, {}));

// Some use cli-color as: console.log(clc.red('Error!'));
// Which is inefficient as on each call it configures new clc object
// with memoization we reuse once created object
memoized = memoize(function (scope, mod) {
	return defineProperty(getFn(), '_cliColorData',
		d(extend({}, scope._cliColorData, mod)));
});

proto = Object.create(Function.prototype, extend(map(mods, function (mod) {
	return d.gs(function () { return memoized(this, mod); });
}), {
	// xterm (255) color
	xterm: d(memoize(function (code) {
		code = isNaN(code) ? 255 : min(max(code, 0), 255);
		return defineProperty(getFn(), '_cliColorData',
			d(extend({}, this._cliColorData, {
				_fg: [xtermMatch ? xtermMatch[code] : ('38;5;' + code), 39]
			})));
	}, { method: 'xterm' })),
	bgXterm: d(memoize(function (code) {
		code = isNaN(code) ? 255 : min(max(code, 0), 255);
		return defineProperty(getFn(), '_cliColorData',
			d(extend({}, this._cliColorData, {
				_bg: [xtermMatch ? (xtermMatch[code] + 10) : ('48;5;' + code), 49]
			})));
	}, { method: 'bgXterm' }))
}));

if (process.platform === 'win32') {
	xtermMatch = require('./_xterm-match');
}

getFn = function () {
	var fn = function (/*…msg*/) {
		var data = fn._cliColorData, close = '';
		return reduce(data, function (str, mod) {
			close = '\x1b[' + mod[1] + 'm' + close;
			return str + '\x1b[' + mod[0] + 'm';
		}, '', true) + join.call(arguments, ' ') + close;
	};
	fn.__proto__ = proto;
	return fn;
};

getMove = function (control) {
	return function (num) {
		num = isNaN(num) ? 0 : max(floor(num), 0);
		return num ? ('\x1b[' + num + control) : '';
	};
};

module.exports = defineProperties(getFn(), {
	width: d.gs(false ? function () {
		return false()[0];
	} : function () {
		return tty.getWindowSize ? tty.getWindowSize()[1] : 0;
	}),
	height: d.gs(getHeight = false ? function () {
		return false()[1];
	} : function () {
		return tty.getWindowSize ? tty.getWindowSize()[0] : 0;
	}),
	reset: d.gs(function () {
		return repeat.call('\n', getHeight() - 1) + '\x1bc';
	}),
	up: d(up = getMove('A')),
	down: d(down = getMove('B')),
	right: d(right = getMove('C')),
	left: d(left = getMove('D')),
	move: d(function (x, y) {
		x = isNaN(x) ? 0 : floor(x);
		y = isNaN(y) ? 0 : floor(y);
		return ((x > 0) ? right(x) : left(-x)) + ((y > 0) ? down(y) : up(-y));
	}),
	moveTo: d(function (x, y) {
		x = isNaN(x) ? 1 : (max(floor(x), 0) + 1);
		y = isNaN(y) ? 1 : (max(floor(y), 0) + 1);
		return '\x1b[' + y + ';' + x + 'H';
	}),
	bol: d(function (n/*, erase*/) {
		var dir;
		n = isNaN(n) ? 0 : Number(n);
		dir = (n >= 0) ? 'E' : 'F';
		n = floor(abs(n));
		return arguments[1] ?
				(((!n || (dir === 'F')) ? '\x1b[0E\x1bK' : '') +
					repeat.call('\x1b[1' + dir + '\x1b[K', n)) : '\x1b[' + n + dir;
	}),
	beep: d('\x07'),
	xtermSupported: d(!xtermMatch),
	_cliColorData: d({})
});

}).call(this,require("hXUCVB"))
},{"./_xterm-match":10,"es5-ext/lib/Object/descriptor":25,"es5-ext/lib/Object/extend":26,"es5-ext/lib/Object/map":32,"es5-ext/lib/Object/reduce":33,"es5-ext/lib/String/prototype/repeat":38,"hXUCVB":93,"memoizee":48,"tty":94}],12:[function(require,module,exports){
'use strict';

var isArguments   = require('../Function/is-arguments')

  , isArray = Array.isArray, slice = Array.prototype.slice;

module.exports = function (obj) {
	if (isArray(obj)) {
		return obj;
	} else if (isArguments(obj)) {
		return (obj.length === 1) ? [obj[0]] : Array.apply(null, obj);
	} else {
		return slice.call(obj);
	}
};

},{"../Function/is-arguments":17}],13:[function(require,module,exports){
'use strict';

var numIsNaN = require('../../Number/is-nan')
  , ois      = require('../../Object/is')
  , value    = require('../../Object/valid-value')

  , indexOf = Array.prototype.indexOf;

module.exports = function (searchElement/*, fromIndex*/) {
	var i;
	if (!numIsNaN(searchElement) && (searchElement !== 0)) {
		return indexOf.apply(this, arguments);
	}

	for (i = (arguments[1] >>> 0); i < (value(this).length >>> 0); ++i) {
		if (this.hasOwnProperty(i) && ois(searchElement, this[i])) {
			return i;
		}
	}
	return -1;
};

},{"../../Number/is-nan":19,"../../Object/is":31,"../../Object/valid-value":35}],14:[function(require,module,exports){
'use strict';

var value = require('../../Object/valid-value');

module.exports = function () {
	var i, l;
	if (!(l = (value(this).length >>> 0))) {
		return null;
	}
	i = l - 1;
	while (!this.hasOwnProperty(i)) {
		if (--i === -1) {
			return null;
		}
	}
	return i;
};

},{"../../Object/valid-value":35}],15:[function(require,module,exports){
'use strict';

var lastIndex = require('./last-index');

module.exports = function () {
	var i;
	if ((i = lastIndex.call(this)) !== null) {
		return this[i];
	}
	return undefined;
};

},{"./last-index":14}],16:[function(require,module,exports){
'use strict';

var d      = require('../Object/descriptor')
  , extend = require('../Object/extend')

  , captureStackTrace = Error.captureStackTrace
  , CustomError;

CustomError = module.exports = function CustomError(message, code/*, ext*/) {
	var ext = arguments[2];
	if (ext != null) extend(this, ext);
	this.message = String(message);
	if (code != null) this.code = String(code);
	if (captureStackTrace) captureStackTrace(this, CustomError);
};

CustomError.prototype = Object.create(Error.prototype, {
	constructor: d(CustomError),
	name: d('CustomError')
});

},{"../Object/descriptor":25,"../Object/extend":26}],17:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call((function () { return arguments; }()));

module.exports = function (x) {
	return toString.call(x) === id;
};

},{}],18:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	value = Number(value);
	if (isNaN(value) || (value === 0)) {
		return value;
	}
	return (value > 0) ? 1 : -1;
};

},{}],19:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	return (value !== value); //jslint: skip
};

},{}],20:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call(1);

module.exports = function (x) {
	return ((typeof x === 'number') ||
		((x instanceof Number) ||
			((typeof x === 'object') && (toString.call(x) === id))));
};

},{}],21:[function(require,module,exports){
'use strict';

var sign = require('../Math/sign')

  , abs = Math.abs, floor = Math.floor;

module.exports = function (value) {
	if (isNaN(value)) {
		return 0;
	}
	value = Number(value);
	if ((value === 0) || !isFinite(value)) {
		return value;
	}

	return sign(value) * floor(abs(value));
};

},{"../Math/sign":18}],22:[function(require,module,exports){
'use strict';

var toInt = require('./to-int')

  , max = Math.max;

module.exports = function (value) { return max(0, toInt(value)); };

},{"./to-int":21}],23:[function(require,module,exports){
// Internal method, used by iteration functions.
// Calls a function for each key-value pair found in object
// Optionally takes compareFn to iterate object in specific order

'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , value      = require('./valid-value')

  , call = Function.prototype.call, keys = Object.keys;

module.exports = function (method) {
	return function (obj, cb/*, thisArg, compareFn*/) {
		var list, thisArg = arguments[2], compareFn = arguments[3];
		obj = Object(value(obj));
		callable(cb);

		list = keys(obj);
		if (compareFn) {
			list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
		}
		return list[method](function (key, index) {
			return call.call(cb, thisArg, obj[key], key, obj, index);
		});
	};
};

},{"./is-callable":28,"./valid-callable":34,"./valid-value":35}],24:[function(require,module,exports){
'use strict';

var isPlainObject = require('./is-plain-object')
  , forEach       = require('./for-each')
  , extend        = require('./extend')
  , value         = require('./valid-value')

  , recursive;

recursive = function (to, from, cloned) {
	forEach(from, function (value, key) {
		var index;
		if (isPlainObject(value)) {
			if ((index = cloned[0].indexOf(value)) === -1) {
				cloned[0].push(value);
				cloned[1].push(to[key] = extend({}, value));
				recursive(to[key], value, cloned);
			} else {
				to[key] = cloned[1][index];
			}
		}
	}, from);
};

module.exports = function (obj/*, deep*/) {
	var copy;
	if ((copy = Object(value(obj))) === obj) {
		copy = extend({}, obj);
		if (arguments[1]) {
			recursive(copy, obj, [[obj], [copy]]);
		}
	}
	return copy;
};

},{"./extend":26,"./for-each":27,"./is-plain-object":30,"./valid-value":35}],25:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , validValue = require('./valid-value')
  , copy       = require('./copy')
  , map        = require('./map')
  , isString   = require('../String/is-string')
  , contains   = require('../String/prototype/contains')

  , bind = Function.prototype.bind
  , defineProperty = Object.defineProperty
  , d;

d = module.exports = function (dscr, value) {
	var c, e, w;
	if (arguments.length < 2) {
		value = dscr;
		dscr = null;
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	return { value: value, configurable: c, enumerable: e, writable: w };
};

d.gs = function (dscr, get, set) {
	var c, e;
	if (isCallable(dscr)) {
		set = (get == null) ? undefined : callable(get);
		get = dscr;
		dscr = null;
	} else {
		get = (get == null) ? undefined : callable(get);
		set = (set == null) ? undefined : callable(set);
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	return { get: get, set: set, configurable: c, enumerable: e };
};

d.binder = function self(name, dv) {
	var value, dgs;
	if (!isString(name)) {
		return map(name, function (dv, name) { return self(name, dv); });
	}
	value = validValue(dv) && callable(dv.value);
	dgs = copy(dv);
	delete dgs.writable;
	delete dgs.value;
	dgs.get = function () {
		dv.value = bind.call(value, this);
		defineProperty(this, name, dv);
		return this[name];
	};
	return dgs;
};

},{"../String/is-string":36,"../String/prototype/contains":37,"./copy":24,"./is-callable":28,"./map":32,"./valid-callable":34,"./valid-value":35}],26:[function(require,module,exports){
'use strict';

var value = require('./valid-value')

  , forEach = Array.prototype.forEach, slice = Array.prototype.slice
  , keys = Object.keys

  , extend;

extend = function (src) {
	keys(Object(src)).forEach(function (key) {
		this[key] = src[key];
	}, this);
};

module.exports = function (dest/*, …src*/) {
	forEach.call(arguments, value);
	slice.call(arguments, 1).forEach(extend, dest);
	return dest;
};

},{"./valid-value":35}],27:[function(require,module,exports){
'use strict';

module.exports = require('./_iterate')('forEach');

},{"./_iterate":23}],28:[function(require,module,exports){
// Inspired by: http://www.davidflanagan.com/2009/08/typeof-isfuncti.html

'use strict';

var forEach = Array.prototype.forEach.bind([]);

module.exports = function (obj) {
	var type;
	if (!obj) {
		return false;
	}
	type = typeof obj;
	if (type === 'function') {
		return true;
	}
	if (type !== 'object') {
		return false;
	}

	try {
		forEach(obj);
		return true;
	} catch (e) {
		if (e instanceof TypeError) {
			return false;
		}
		throw e;
	}
};

},{}],29:[function(require,module,exports){
'use strict';

var value = require('./valid-value');

module.exports = function (obj) {
	var i;
	value(obj);
	for (i in obj) { //jslint: skip
		if (obj.propertyIsEnumerable(i)) return false;
	}
	return true;
};

},{"./valid-value":35}],30:[function(require,module,exports){
'use strict';

var getPrototypeOf = Object.getPrototypeOf, prototype = Object.prototype
  , toString = prototype.toString

  , id = {}.toString();

module.exports = function (value) {
	var proto;
	if (!value || (typeof value !== 'object') || (toString.call(value) !== id)) {
		return false;
	}
	proto = getPrototypeOf(value);
	return (proto === prototype) || (getPrototypeOf(proto) === null);
};

},{}],31:[function(require,module,exports){
// Implementation credits go to:
// http://wiki.ecmascript.org/doku.php?id=harmony:egal

'use strict';

module.exports = function (x, y) {
	return (x === y) ?
			((x !== 0) || ((1 / x) === (1 / y))) :
			((x !== x) && (y !== y)); //jslint: skip
};

},{}],32:[function(require,module,exports){
'use strict';

var callable = require('./valid-callable')
  , forEach  = require('./for-each')

  , call = Function.prototype.call;

module.exports = function (obj, cb/*, thisArg*/) {
	var o = {}, thisArg = arguments[2];
	callable(cb);
	forEach(obj, function (value, key, obj, index) {
		o[key] = call.call(cb, thisArg, value, key, obj, index);
	});
	return o;
};

},{"./for-each":27,"./valid-callable":34}],33:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable')
  , callable   = require('./valid-callable')
  , value      = require('./valid-value')

  , call = Function.prototype.call, keys = Object.keys;

module.exports = exports = function self(obj, cb/*, initial, compareFn*/) {
	var list, fn, initial, compareFn, initialized;
	value(obj) && callable(cb);

	obj = Object(obj);
	initial = arguments[2];
	compareFn = arguments[3];

	list = keys(obj);
	if (compareFn) {
		list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
	}

	fn = function (value, key, index) {
		if (initialized) {
			return call.call(cb, undefined, value, obj[key], key, obj, index);
		} else {
			initialized = true;
			return call.call(cb, undefined, obj[value], obj[key], key, obj, index,
				value);
		}
	};

	if ((arguments.length < 3) || (initial === self.NO_INITIAL)) {
		return list.reduce(fn);
	} else {
		initialized = true;
		return list.reduce(fn, initial);
	}
};
exports.NO_INITIAL = {};

},{"./is-callable":28,"./valid-callable":34,"./valid-value":35}],34:[function(require,module,exports){
'use strict';

var isCallable = require('./is-callable');

module.exports = function (fn) {
	if (!isCallable(fn)) {
		throw new TypeError(fn + " is not a function");
	}
	return fn;
};

},{"./is-callable":28}],35:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) {
		throw new TypeError("Cannot use null or undefined");
	}
	return value;
};

},{}],36:[function(require,module,exports){
'use strict';

var toString = Object.prototype.toString

  , id = toString.call('');

module.exports = function (x) {
	return (typeof x === 'string') || (x && (typeof x === 'object') &&
		((x instanceof String) || (toString.call(x) === id))) || false;
};

},{}],37:[function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],38:[function(require,module,exports){
// Not rocket science but taken from:
// http://closure-library.googlecode.com/svn/trunk/closure/goog/string/string.js

'use strict';

var value  = require('../../Object/valid-value')
  , toUint = require('../../Number/to-uint');

module.exports = function (n) {
	return new Array((isNaN(n) ? 1 : toUint(n)) + 1).join(String(value(this)));
};

},{"../../Number/to-uint":22,"../../Object/valid-value":35}],39:[function(require,module,exports){
'use strict';

module.exports = new Function("return this")();

},{}],40:[function(require,module,exports){
// To be used internally, memoize factory

'use strict';

var callable = require('es5-ext/lib/Object/valid-callable')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , ee       = require('event-emitter/lib/core')

  , ext;

module.exports = exports = function (core) {
	return function self(fn/*, options */) {
		var options, length, get, clear, conf;

		callable(fn);
		if (fn.memoized) {
			// Do not memoize already memoized function
			return fn;
		}

		options = Object(arguments[1]);
		conf = ee({ memoize: self, fn: fn });

		// Normalize length
		if (isNaN(options.length)) {
			length = fn.length;
			// Special case
			if (options.async && ext.async) {
				--length;
			}
		} else {
			length = (options.length === false) ? false : (options.length >>> 0);
		}

		core(conf, length);

		forEach(ext, function (fn, name) {
			if (fn.force) {
				fn(conf, options);
			} else if (options[name]) {
				fn(options[name], conf, options);
			}
		});

		fn = conf.fn;
		get = conf.get;
		clear = conf.clear;

		conf.memoized.clear = function () { clear(get(arguments)); };
		conf.memoized.clearAll = function () {
			conf.emit('purgeall');
			conf.clearAll();
		};
		conf.memoized.memoized = true;
		conf.emit('ready');
		return conf.memoized;
	};
};
ext = exports.ext = {};

},{"es5-ext/lib/Object/for-each":27,"es5-ext/lib/Object/valid-callable":34,"event-emitter/lib/core":52}],41:[function(require,module,exports){
// Support for asynchronous functions

'use strict';

var toArray     = require('es5-ext/lib/Array/from')
  , last        = require('es5-ext/lib/Array/prototype/last')
  , isArguments = require('es5-ext/lib/Function/is-arguments')
  , forEach     = require('es5-ext/lib/Object/for-each')
  , isCallable  = require('es5-ext/lib/Object/is-callable')
  , nextTick    = require('next-tick')

  , isArray = Array.isArray, slice = Array.prototype.slice
  , apply = Function.prototype.apply;

require('../_base').ext.async = function (ignore, conf) {
	var cache, purge;

	cache = conf.async = {};

	(function (org) {
		var value, cb, initContext, initArgs, fn, resolver;

		conf.on('init', function (id) {
			value.id = id;
			cache[id] = cb ? [cb] : [];
		});

		conf.on('hit', function (id, syncArgs, syncCtx) {
			if (!cb) {
				return;
			}

			if (isArray(cache[id])) {
				cache[id].push(cb);
			} else {
				nextTick(function (cb, id, ctx, args) {
					if (cache[id]) {
						conf.emit('hitasync', id, syncArgs, syncCtx);
						apply.call(cb, this.context, this);
					} else {
						// Purged in a meantime, we shouldn't rely on cached value, recall
						fn.apply(ctx, args);
					}
				}.bind(cache[id], cb, id, initContext, initArgs));
				initContext = initArgs = null;
			}
		});
		conf.fn = function () {
			var args, asyncArgs;
			args = arguments;
			asyncArgs = toArray(args);
			asyncArgs.push(value = function self(err) {
				var i, cb, waiting, res;
				if (self.id == null) {
					// Shouldn't happen, means async callback was called sync way
					nextTick(apply.bind(self, this, arguments));
					return;
				}
				waiting = cache[self.id];
				if (conf.cache.hasOwnProperty(self.id)) {
					if (err) {
						delete cache[self.id];
						conf.clear(self.id);
					} else {
						arguments.context = this;
						cache[self.id] = arguments;
						conf.emit('initasync', self.id, waiting.length);
					}
				} else {
					delete cache[self.id];
				}
				for (i = 0; (cb = waiting[i]); ++i) {
					res = apply.call(cb, this, arguments);
				}
				return res;
			});
			return apply.call(org, this, asyncArgs);
		};

		fn = conf.memoized;
		resolver = function (args) {
			cb = last.call(args);
			if (isCallable(cb)) {
				return slice.call(args, 0, -1);
			} else {
				cb = null;
				return args;
			}
		};
		conf.memoized = function () {
			return fn.apply(initContext = this, initArgs = resolver(arguments));
		};
		forEach(fn, function (value, name) {
			conf.memoized[name] = function () {
				return fn[name].apply(this, resolver(arguments));
			};
		});

	}(conf.fn));

	conf.on('purge', purge = function (id) {
		// If false, we don't have value yet, so we assume that intention is not
		// to memoize this call. After value is obtained we don't cache it but
		// gracefully pass to callback
		if (isArguments(cache[id])) {
			conf.emit('purgeasync', id);
			delete cache[id];
		}
	});

	conf.on('purgeall', function () {
		forEach(conf.async, function (value, id) { purge(id); });
	});
};

},{"../_base":40,"es5-ext/lib/Array/from":12,"es5-ext/lib/Array/prototype/last":15,"es5-ext/lib/Function/is-arguments":17,"es5-ext/lib/Object/for-each":27,"es5-ext/lib/Object/is-callable":28,"next-tick":54}],42:[function(require,module,exports){
// Call dispose callback on each cache purge

'use strict';

var callable = require('es5-ext/lib/Object/valid-callable')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , ext      = require('../_base').ext

  , slice = Array.prototype.slice;

ext.dispose = function (dispose, conf, options) {
	var clear, async;

	callable(dispose);

	async = (options.async && ext.async);
	conf.on('purge' + (async ? 'async' : ''), clear =  async ? function (id) {
		var value = conf.async[id];
		delete conf.cache[id];
		dispose.apply(conf.memoized['_memoize:context_'], slice.call(value, 1));
	} : function (id) {
		var value = conf.cache[id];
		delete conf.cache[id];
		dispose.call(conf.memoized['_memoize:context_'], value);
	});

	if (!async) {
		conf.on('purgeall', function () {
			forEach(conf.cache, function (value, id) { clear(id); });
		});
	}
};

},{"../_base":40,"es5-ext/lib/Object/for-each":27,"es5-ext/lib/Object/valid-callable":34}],43:[function(require,module,exports){
// Timeout cached values

'use strict';

var isNumber = require('es5-ext/lib/Number/is-number')
  , forEach  = require('es5-ext/lib/Object/for-each')
  , nextTick = require('next-tick')
  , ext      = require('../_base').ext

  , max = Math.max, min = Math.min;

ext.maxAge = function (maxAge, conf, options) {
	var cache, async, preFetchAge, preFetchCache;

	maxAge = maxAge >>> 0;
	if (!maxAge) {
		return;
	}

	cache = {};
	async = options.async && ext.async;
	conf.on('init' + (async ? 'async' : ''), function (id) {
		cache[id] = setTimeout(function () { conf.clear(id); }, maxAge);
		if (preFetchCache) {
			preFetchCache[id] = setTimeout(function () { delete preFetchCache[id]; },
				preFetchAge);
		}
	});
	conf.on('purge' + (async ? 'async' : ''), function (id) {
		clearTimeout(cache[id]);
		if (preFetchCache && preFetchCache[id]) {
			clearTimeout(preFetchCache[id]);
			delete preFetchCache[id];
		}
		delete cache[id];
	});

	if (options.preFetch) {
		if (isNumber(options.preFetch)) {
			preFetchAge = max(min(Number(options.preFetch), 1), 0);
		} else {
			preFetchAge = 0.333;
		}
		if (preFetchAge) {
			preFetchCache = {};
			preFetchAge = (1 - preFetchAge) * maxAge;
			conf.on('hit' + (async ? 'async' : ''), function (id, args, ctx) {
				if (!preFetchCache[id]) {
					preFetchCache[id] = true;
					nextTick(function () {
						if (preFetchCache[id] === true) {
							delete preFetchCache[id];
							conf.clear(id);
							conf.memoized.apply(ctx, args);
						}
					});
				}
			});
		}
	}

	if (!async) {
		conf.on('purgeall', function () {
			forEach(cache, function (id) {
				clearTimeout(id);
			});
			cache = {};
			if (preFetchCache) {
				forEach(preFetchCache, function (id) {
					clearTimeout(id);
				});
				preFetchCache = {};
			}
		});
	}
};

},{"../_base":40,"es5-ext/lib/Number/is-number":20,"es5-ext/lib/Object/for-each":27,"next-tick":54}],44:[function(require,module,exports){
// Limit cache size, LRU (least recently used) algorithm.

'use strict';

var ext = require('../_base').ext;

ext.max = function (max, conf, options) {
	var index, base, size, queue, map, async;

	max = max >>> 0;
	if (!max) {
		return;
	}

	index = -1;
	base = size = 0;
	queue = {};
	map = {};
	async = options.async && ext.async;

	conf.on('init' + (async ? 'async' : ''), function (id) {
		queue[++index] = id;
		map[id] = index;
		++size;
		if (size > max) {
			conf.clear(queue[base]);
		}
	});

	conf.on('hit' + (async ? 'async' : ''), function (id) {
		var oldIndex = map[id];
		queue[++index] = id;
		map[id] = index;
		delete queue[oldIndex];
		if (base === oldIndex) {
			while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
		}
	});

	conf.on('purge' + (async ? 'async' : ''), function (id) {
		var oldIndex = map[id];
		delete queue[oldIndex];
		--size;
		if (base === oldIndex) {
			if (!size) {
				index = -1;
				base = 0;
			} else {
				while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
			}
		}
	});

	if (!async) {
		conf.on('purgeall', function () {
			index = -1;
			base = size = 0;
			queue = {};
			map = {};
		});
	}
};

},{"../_base":40}],45:[function(require,module,exports){
// Memoized methods factory

'use strict';

var d        = require('es5-ext/lib/Object/descriptor')
  , global   = require('es5-ext/lib/global')
  , extend   = require('es5-ext/lib/Object/extend')
  , isString = require('es5-ext/lib/String/is-string')

  , create = Object.create, defineProperty = Object.defineProperty;

require('../_base').ext.method = function (method, conf, options) {
	if (isString(options.method)) {
		method = { name: String(options.method),
			descriptor: { configurable: true, writable: true } };
	} else {
		method = options.method;
		method.name = String(method.name);
		method.descriptor = (method.descriptor == null) ?
				{ configurable: true, writable: true } : Object(method.descriptor);
	}
	options = create(options);
	options.method = undefined;

	(function (fn) {
		conf.memoized = function () {
			var memoized;
			if (this && (this !== global)) {
				memoized = method.descriptor.value =
					conf.memoize(conf.fn.bind(this), options);
				defineProperty(this, method.name, method.descriptor);
				defineProperty(memoized, '_memoize:context_', d(this));
				return memoized.apply(this, arguments);
			}
			return fn.apply(this, arguments);
		};
		extend(conf.memoized, fn);
	}(conf.memoized));
};

},{"../_base":40,"es5-ext/lib/Object/descriptor":25,"es5-ext/lib/Object/extend":26,"es5-ext/lib/String/is-string":36,"es5-ext/lib/global":39}],46:[function(require,module,exports){
// Reference counter, useful for garbage collector like functionality

'use strict';

var ext = require('../_base').ext;

ext.refCounter = function (ignore, conf, options) {
	var cache, async;

	cache = {};
	async = options.async && ext.async;

	conf.on('init' + (async ? 'async' : ''), async ? function (id, length) {
		cache[id] = length;
	} : function (id) { cache[id] = 1; });
	conf.on('hit' + (async ? 'async' : ''), function (id) { ++cache[id]; });
	conf.on('purge' + (async ? 'async' : ''), function (id) {
		delete cache[id];
	});
	if (!async) {
		conf.on('purgeall', function () { cache = {}; });
	}

	conf.memoized.clearRef = function () {
		var id = conf.get(arguments);
		if (cache.hasOwnProperty(id)) {
			if (!--cache[id]) {
				conf.clear(id);
				return true;
			}
			return false;
		}
		return null;
	};
};

},{"../_base":40}],47:[function(require,module,exports){
// Normalize arguments before passing them to underlying function

'use strict';

var toArray    = require('es5-ext/lib/Array/from')
  , forEach    = require('es5-ext/lib/Object/for-each')
  , callable   = require('es5-ext/lib/Object/valid-callable')

  , slice = Array.prototype.slice

  , resolve;

resolve = function (args) {
	return this.map(function (r, i) {
		return r ? r(args[i]) : args[i];
	}).concat(slice.call(args, this.length));
};

require('../_base').ext.resolvers = function (resolvers, conf) {
	var resolver;

	resolver = toArray(resolvers);
	resolver.forEach(function (r) { (r == null) || callable(r); });
	resolver = resolve.bind(resolver);

	(function (fn) {
		conf.memoized = function () {
			var value;
			conf.memoized.args = arguments;
			value = fn.apply(this, resolver(arguments));
			delete conf.memoized.args;
			return value;
		};
		forEach(fn, function (value, name) {
			conf.memoized[name] = function () {
				return fn[name].apply(this, resolver(arguments));
			};
		});
	}(conf.memoized));
};

},{"../_base":40,"es5-ext/lib/Array/from":12,"es5-ext/lib/Object/for-each":27,"es5-ext/lib/Object/valid-callable":34}],48:[function(require,module,exports){
// Provides memoize with all options

'use strict';

var regular   = require('./regular')
  , primitive = require('./primitive')

  , call = Function.prototype.call;

// Order is significant!
require('./ext/dispose');
require('./ext/resolvers');
require('./ext/async');
require('./ext/ref-counter');
require('./ext/method');
require('./ext/max-age');
require('./ext/max');

module.exports = function (fn/* options */) {
	var options = Object(arguments[1]);
	return call.call(options.primitive ? primitive : regular, this, fn, options);
};

},{"./ext/async":41,"./ext/dispose":42,"./ext/max":44,"./ext/max-age":43,"./ext/method":45,"./ext/ref-counter":46,"./ext/resolvers":47,"./primitive":49,"./regular":50}],49:[function(require,module,exports){
// Memoize working in primitive mode

'use strict';

var CustomError  = require('es5-ext/lib/Error/custom')
  , hasListeners = require('event-emitter/lib/has-listeners')

  , getId0 = function () { return ''; }
  , getId1 = function (args) { return args[0]; }

  , apply = Function.prototype.apply, call = Function.prototype.call;

module.exports = require('./_base')(function (conf, length) {
	var get, cache = conf.cache = {}, fn
	  , hitListeners, initListeners, purgeListeners;

	if (length === 1) {
		get = conf.get = getId1;
	} else if (length === false) {
		get = conf.get = function (args) {
			var id = '', i, length = args.length;
			if (length) {
				id += args[i = 0];
				while (--length) {
					id += '\u0001' + args[++i];
				}
			} else {
				id = '\u0002';
			}
			return id;
		};
	} else if (length) {
		get = conf.get = function (args) {
			var id = String(args[0]), i = 0, l = length;
			while (--l) { id += '\u0001' + args[++i]; }
			return id;
		};
	} else {
		get = conf.get = getId0;
	}

	conf.memoized = (length === 1) ? function (id) {
		var value;
		if (cache.hasOwnProperty(id)) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			if (arguments.length === 1) {
				value = call.call(fn, this, id);
			} else {
				value = apply.call(fn, this, arguments);
			}
			if (cache.hasOwnProperty(id)) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	} : function () {
		var id = get(arguments), value;
		if (cache.hasOwnProperty(id)) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			value = apply.call(conf.fn, this, arguments);
			if (cache.hasOwnProperty(id)) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	};

	conf.clear = function (id) {
		if (cache.hasOwnProperty(id)) {
			purgeListeners && conf.emit('purge', id);
			delete cache[id];
		}
	};
	conf.clearAll = function () { cache = conf.cache = {}; };

	conf.once('ready', function () {
		fn = conf.fn;
		hitListeners = hasListeners(conf, 'hit');
		initListeners = hasListeners(conf, 'init');
		purgeListeners = hasListeners(conf, 'purge');
	});
});

},{"./_base":40,"es5-ext/lib/Error/custom":16,"event-emitter/lib/has-listeners":53}],50:[function(require,module,exports){
// Memoize working in object mode (supports any type of arguments)

'use strict';

var CustomError  = require('es5-ext/lib/Error/custom')
  , indexOf      = require('es5-ext/lib/Array/prototype/e-index-of')
  , hasListeners = require('event-emitter/lib/has-listeners')

  , apply = Function.prototype.apply;

// Results are saved internally within array matrix:
// [0] -> Result of calling function with no arguments
// [1] -> Matrix that keeps results when function is called with one argument
//        [1][0] -> Array of arguments with which
//                 function have been called
//        [1][1] -> Array of results that matches [1][0] array
// [2] -> Matrix that keeps results when function is called with two arguments
//        [2][0] -> Array of first (of two) arguments with which
//                function have been called
//        [2][1] -> Matrixes that keeps results for two arguments function calls
//                  Each matrix matches first argument found in [2][0]
//                  [2][1][x][0] -> Array of second arguments with which
//                                  function have been called.
//                  [2][1][x][1] -> Array of results that matches [2][1][x][0]
//                                   arguments array
// ...and so on
module.exports = require('./_base')(function (conf, length) {
	var map, map1, map2, get, set, clear, count, fn
	  , hitListeners, initListeners, purgeListeners
	  , cache = conf.cache = {}, argsCache;

	if (length === 0) {
		map = null;
		get = conf.get = function () { return map; };
		set = function () { return ((map = 1)); };
		clear = function () { map = null; };
		conf.clearAll = function () {
			map = null;
			cache = conf.cache = {};
		};
	} else {
		count = 0;
		if (length === 1) {
			map1 = [];
			map2 = [];
			get = conf.get = function (args) {
				var index = indexOf.call(map1, args[0]);
				return (index === -1) ? null : map2[index];
			};
			set = function (args) {
				map1.push(args[0]);
				map2.push(++count);
				return count;
			};
			clear = function (id) {
				var index = indexOf.call(map2, id);
				if (index !== -1) {
					map1.splice(index, 1);
					map2.splice(index, 1);
				}
			};
			conf.clearAll = function () {
				map1 = [];
				map2 = [];
				cache = conf.cache = {};
			};
		} else if (length === false) {
			map = [];
			argsCache = {};
			get = conf.get = function (args) {
				var index = 0, set = map, i, length = args.length;
				if (length === 0) {
					return set[length] || null;
				} else if ((set = set[length])) {
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) return null;
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					return set[1][i] || null;
				}
				return null;
			};
			set = function (args) {
				var index = 0, set = map, i, length = args.length;
				if (length === 0) {
					set[length] = ++count;
				} else {
					if (!set[length]) {
						set[length] = [[], []];
					}
					set = set[length];
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							i = set[0].push(args[index]) - 1;
							set[1].push([[], []]);
						}
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
					}
					set[1][i] = ++count;
				}
				argsCache[count] = args;
				return count;
			};
			clear = function (id) {
				var index = 0, set = map, i, args = argsCache[id], length = args.length
				  , path = [];
				if (length === 0) {
					delete set[length];
				} else if ((set = set[length])) {
					while (index < (length - 1)) {
						i = indexOf.call(set[0], args[index]);
						if (i === -1) {
							return;
						}
						path.push(set, i);
						set = set[1][i];
						++index;
					}
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					id = set[1][i];
					set[0].splice(i, 1);
					set[1].splice(i, 1);
					while (!set[0].length && path.length) {
						i = path.pop();
						set = path.pop();
						set[0].splice(i, 1);
						set[1].splice(i, 1);
					}
				}
				delete argsCache[id];
			};
			conf.clearAll = function () {
				map = [];
				cache = conf.cache = {};
				argsCache = {};
			};
		} else {
			map = [[], []];
			argsCache = {};
			get = conf.get = function (args) {
				var index = 0, set = map, i;
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) return null;
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) return null;
				return set[1][i] || null;
			};
			set = function (args) {
				var index = 0, set = map, i;
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						i = set[0].push(args[index]) - 1;
						set[1].push([[], []]);
					}
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					i = set[0].push(args[index]) - 1;
				}
				set[1][i] = ++count;
				argsCache[count] = args;
				return count;
			};
			clear = function (id) {
				var index = 0, set = map, i, path = [], args = argsCache[id];
				while (index < (length - 1)) {
					i = indexOf.call(set[0], args[index]);
					if (i === -1) {
						return;
					}
					path.push(set, i);
					set = set[1][i];
					++index;
				}
				i = indexOf.call(set[0], args[index]);
				if (i === -1) {
					return;
				}
				id = set[1][i];
				set[0].splice(i, 1);
				set[1].splice(i, 1);
				while (!set[0].length && path.length) {
					i = path.pop();
					set = path.pop();
					set[0].splice(i, 1);
					set[1].splice(i, 1);
				}
				delete argsCache[id];
			};
			conf.clearAll = function () {
				map = [[], []];
				cache = conf.cache = {};
				argsCache = {};
			};
		}
	}
	conf.memoized = function () {
		var id = get(arguments), value;
		if (id != null) {
			hitListeners && conf.emit('hit', id, arguments, this);
			return cache[id];
		} else {
			value = apply.call(fn, this, arguments);
			id = get(arguments);
			if (id != null) {
				throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
			}
			id = set(arguments);
			cache[id] = value;
			initListeners && conf.emit('init', id);
			return value;
		}
	};
	conf.clear = function (id) {
		if (cache.hasOwnProperty(id)) {
			purgeListeners && conf.emit('purge', id);
			clear(id);
			delete cache[id];
		}
	};

	conf.once('ready', function () {
		fn = conf.fn;
		hitListeners = hasListeners(conf, 'hit');
		initListeners = hasListeners(conf, 'init');
		purgeListeners = hasListeners(conf, 'purge');
	});
});

},{"./_base":40,"es5-ext/lib/Array/prototype/e-index-of":13,"es5-ext/lib/Error/custom":16,"event-emitter/lib/has-listeners":53}],51:[function(require,module,exports){
'use strict';

module.exports = '_ee2_';

},{}],52:[function(require,module,exports){
'use strict';

var d        = require('es5-ext/lib/Object/descriptor')
  , callable = require('es5-ext/lib/Object/valid-callable')
  , id       = require('./_id')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit
  , colId, methods, descriptors, base;

colId = id + 'l_';

on = function (type, listener) {
	var data;

	callable(listener);

	if (!this.hasOwnProperty(id)) {
		data = descriptor.value = {};
		defineProperty(this, id, descriptor);
		descriptor.value = null;
	} else {
		data = this[id];
	}
	if (!data.hasOwnProperty(type)) data[type] = listener;
	else if (data[type].hasOwnProperty(colId)) data[type].push(listener);
	else (data[type] = [data[type], listener])[colId] = true;

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once._listener = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!this.hasOwnProperty(id)) return this;
	data = this[id];
	if (!data.hasOwnProperty(type)) return this;
	listeners = data[type];

	if (listeners.hasOwnProperty(colId)) {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) || (candidate._listener === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) || (listeners._listener === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var data, i, l, listener, listeners, args;

	if (!this.hasOwnProperty(id)) return;
	data = this[id];
	if (!data.hasOwnProperty(type)) return;
	listeners = data[type];

	if (listeners.hasOwnProperty(colId)) {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) {
			args[i - 1] = arguments[i];
		}

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"./_id":51,"es5-ext/lib/Object/descriptor":25,"es5-ext/lib/Object/valid-callable":34}],53:[function(require,module,exports){
'use strict';

var isEmpty = require('es5-ext/lib/Object/is-empty')
  , value   = require('es5-ext/lib/Object/valid-value')
  , id      = require('./_id');

module.exports = function (obj/*, type*/) {
	var type;
	value(obj);
	type = arguments[1];
	if (arguments.length > 1) {
		return obj.hasOwnProperty(id) && obj[id].hasOwnProperty(type);
	} else {
		return obj.hasOwnProperty(id) && !isEmpty(obj[id]);
	}
};

},{"./_id":51,"es5-ext/lib/Object/is-empty":29,"es5-ext/lib/Object/valid-value":35}],54:[function(require,module,exports){
(function (process){
'use strict';

if ((typeof process !== 'undefined') && process &&
		(typeof process.nextTick === 'function')) {

	// Node.js
	module.exports = process.nextTick;

} else if (typeof setImmediate === 'function') {

	// W3C Draft
	// https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	module.exports = function (cb) { setImmediate(cb); };

} else {

	// Wide available standard
	module.exports = function (cb) { setTimeout(cb, 0); };
}

}).call(this,require("hXUCVB"))
},{"hXUCVB":93}],55:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var attrMap, getNodeAtPath;
  attrMap = require('grasp-syntax-javascript').attrMap;
  getNodeAtPath = function(node, path){
    var i$, len$, prop, that;
    for (i$ = 0, len$ = path.length; i$ < len$; ++i$) {
      prop = path[i$];
      if ((that = node[attrMap[prop] || prop]) != null) {
        node = that;
      } else {
        return;
      }
    }
    return node;
  };
  module.exports = {
    getNodeAtPath: getNodeAtPath
  };
}).call(this);

},{"grasp-syntax-javascript":63}],56:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parse, matchNode, VERSION, query, queryParsed;
  parse = require('./parse').parse;
  matchNode = require('./match').matchNode;
  VERSION = '0.2.1';
  query = function(selector, ast){
    return queryParsed(parse(selector), ast);
  };
  queryParsed = function(parsedSelector, ast){
    var results;
    results = [];
    matchNode(results, parsedSelector, ast);
    return results;
  };
  module.exports = {
    parse: parse,
    queryParsed: queryParsed,
    query: query,
    VERSION: VERSION
  };
}).call(this);

},{"./match":57,"./parse":58}],57:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, primitiveOnlyAttributes, eitherAttributes, all, tail, getNodeAtPath, toString$ = {}.toString, slice$ = [].slice;
  ref$ = require('grasp-syntax-javascript'), primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  ref$ = require('prelude-ls'), all = ref$.all, tail = ref$.tail;
  getNodeAtPath = require('./common').getNodeAtPath;
  function matchNode(results, query, mainNode){
    var key, val, ref$;
    if (eq(mainNode, query)) {
      results.push(mainNode);
    }
    for (key in mainNode) {
      val = mainNode[key];
      if ((key !== 'loc' && key !== 'start' && key !== 'end' && key !== '_named') && ((ref$ = toString$.call(val).slice(8, -1)) === 'Object' || ref$ === 'Array')) {
        matchNode(results, query, val);
      }
    }
    function eq(targetNode, selectorNode){
      var selectorNodeType, prop;
      selectorNodeType = toString$.call(selectorNode).slice(8, -1);
      if (selectorNode === targetNode) {
        return true;
      } else if (selectorNodeType !== toString$.call(targetNode).slice(8, -1)) {
        return false;
      } else if (selectorNodeType === 'Object') {
        if (selectorNode.type === 'Grasp') {
          return matchSpecial(targetNode, selectorNode);
        } else {
          for (prop in targetNode) {
            if (prop !== 'loc' && prop !== 'start' && prop !== 'end' && prop !== '_named') {
              if (!eq(targetNode[prop], selectorNode[prop])) {
                return false;
              }
            }
          }
          return true;
        }
      } else if (selectorNodeType === 'Array') {
        return matchArray(selectorNode, targetNode);
      } else {
        return false;
      }
    }
    function matchArray(pattern, input){
      var patternLen, that, ref$, patternFirst, patternRest, inputFirst, inputRest, arrayWildcardName, wildcardName;
      patternLen = pattern.length;
      if (patternLen === 0) {
        return input.length === 0;
      } else if (patternLen === 1) {
        if (that = isArrayWildcard(pattern[0])) {
          if (that = that.name) {
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[that] == null && (ref$[that] = []);
            (ref$ = mainNode._named)[that] = ref$[that].concat(input);
          }
          return true;
        } else {
          return input.length === 1 && eq(input[0], pattern[0]);
        }
      } else if (input.length === 0) {
        return false;
      } else {
        patternFirst = pattern[0], patternRest = slice$.call(pattern, 1);
        inputFirst = input[0], inputRest = slice$.call(input, 1);
        if (that = isArrayWildcard(patternFirst)) {
          if (that = that.name) {
            arrayWildcardName = that;
            mainNode._named == null && (mainNode._named = {});
            (ref$ = mainNode._named)[arrayWildcardName] == null && (ref$[arrayWildcardName] = []);
          }
          if (that = eq(inputFirst, patternRest[0])) {
            wildcardName = that;
            if (matchArray(tail(patternRest), inputRest)) {
              return true;
            } else {
              if (toString$.call(wildcardName).slice(8, -1) === 'String') {
                delete mainNode._named[wildcardName];
              }
              return matchArray(pattern, inputRest);
            }
          } else {
            if (arrayWildcardName) {
              mainNode._named[arrayWildcardName].push(inputFirst);
            }
            return matchArray(pattern, inputRest);
          }
        } else {
          return eq(inputFirst, patternFirst) && matchArray(patternRest, inputRest);
        }
      }
    }
    function matchSpecial(targetNode, selectorNode){
      var named, name, that, identMatch, attrMatch;
      switch (selectorNode.graspType) {
      case 'wildcard':
        return true;
      case 'named-wildcard':
        mainNode._named == null && (mainNode._named = {});
        named = mainNode._named;
        name = selectorNode.name;
        if (that = named[name]) {
          if (eq(targetNode, that)) {
            return true;
          } else {
            return false;
          }
        } else {
          named[name] = targetNode;
          return name;
        }
        break;
      case 'node-type':
        return targetNode.type === selectorNode.value;
      case 'matches':
        return in$(targetNode.type, selectorNode.value);
      case 'literal':
        return targetNode.type === 'Literal' && toString$.call(targetNode.value).slice(8, -1) === selectorNode.value;
      case 'compound':
        identMatch = matchSpecial(targetNode, selectorNode.ident);
        attrMatch = all(matchAttr(targetNode), selectorNode.attrs);
        return identMatch && attrMatch;
      }
    }
    function isArrayWildcard(node){
      var cleanNode;
      cleanNode = node.type === 'ExpressionStatement' ? node.expression : node;
      return cleanNode.type === 'Grasp' && cleanNode.graspType === 'array-wildcard' && cleanNode;
    }
    function matchAttr(targetNode){
      return function(attr){
        var node, attrValue, lastPath, ref$;
        node = getNodeAtPath(targetNode, attr.path);
        if (node != null) {
          attrValue = attr.value;
          if (attrValue) {
            lastPath = (ref$ = attr.path)[ref$.length - 1];
            if (in$(lastPath, primitiveOnlyAttributes)) {
              return matchPrimitive(attr.op, node, attrValue);
            } else if (in$(lastPath, eitherAttributes)) {
              return matchEither(attr.op, node, attrValue);
            } else {
              return matchComplex(attr.op, node, attrValue);
            }
          } else {
            return true;
          }
        } else {
          return false;
        }
      };
    }
    function matchPrimitive(op, node, attrValue){
      if (op === '=') {
        return node === attrValue.value;
      } else {
        return node !== attrValue.value;
      }
    }
    function matchComplex(op, node, attrValue){
      if (op === '=') {
        return eq(node, attrValue);
      } else {
        return !eq(node, attrValue);
      }
    }
    function matchEither(op, node, attrValue){
      return matchPrimitive(op, node, attrValue) || matchComplex(op, node, attrValue);
    }
  }
  module.exports = {
    matchNode: matchNode
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"./common":55,"grasp-syntax-javascript":63,"prelude-ls":90}],58:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var acorn, ref$, aliasMap, matchesMap, matchesAliasMap, literalMap, getNodeAtPath, toString$ = {}.toString;
  acorn = window.acorn;
  ref$ = require('grasp-syntax-javascript'), aliasMap = ref$.aliasMap, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap, literalMap = ref$.literalMap;
  getNodeAtPath = require('./common').getNodeAtPath;
  function parse(selector){
    var attempts, i$, len$, attempt, code, parsedSelector, path, e, selectorBody, extractedSelector, finalSelector, root;
    attempts = [
      {
        code: selector,
        path: []
      }, {
        code: "function f(){ " + selector + "; }",
        path: ['body', 'body', 0]
      }, {
        code: "(" + selector + ")",
        path: []
      }, {
        code: "while (true) { " + selector + "; }",
        path: ['body', 'body', 0]
      }, {
        code: "switch (x) { " + selector + " }",
        path: ['cases', 0]
      }, {
        code: "try { } " + selector,
        path: ['handlers', 0]
      }
    ];
    for (i$ = 0, len$ = attempts.length; i$ < len$; ++i$) {
      attempt = attempts[i$], code = attempt.code;
      try {
        parsedSelector = acorn.parse(code);
        path = attempt.path;
        break;
      } catch (e$) {
        e = e$;
        continue;
      }
    }
    if (!parsedSelector) {
      throw new Error("Error processing selector '" + selector + "'.");
    }
    selectorBody = parsedSelector.body;
    if (selectorBody.length > 1) {
      throw new Error("Selector body can't be more than one statement");
    }
    extractedSelector = getNodeAtPath(selectorBody[0], path);
    finalSelector = extractedSelector.type === 'ExpressionStatement' && !/;\s*$/.test(selector) ? extractedSelector.expression : extractedSelector;
    root = {
      type: 'Root',
      value: finalSelector
    };
    processSelector(root);
    return root.value;
  }
  function processSelector(ast){
    var key, node, nodeType, i$, len$, i, n, that;
    delete ast.start;
    delete ast.end;
    for (key in ast) {
      node = ast[key];
      if (key !== 'type') {
        nodeType = toString$.call(node).slice(8, -1);
        if (nodeType === 'Array') {
          for (i$ = 0, len$ = node.length; i$ < len$; ++i$) {
            i = i$;
            n = node[i$];
            if (that = processNode(n)) {
              node[i] = that;
            } else {
              processSelector(n);
            }
          }
        } else if (nodeType === 'Object') {
          if (that = processNode(node)) {
            ast[key] = that;
          } else {
            processSelector(node);
          }
        }
      }
    }
  }
  function processNode(node){
    var name, that, ident, attrs, n, processedAttrs, i$, len$, attr, nodeKey, nodeValue;
    switch (node.type) {
    case 'Identifier':
      name = node.name;
      if (name === '_') {
        return null;
      } else if (name === '__') {
        return {
          type: 'Grasp',
          graspType: 'wildcard'
        };
      } else if (that = /^_\$(\w*)$/.exec(name)) {
        return {
          type: 'Grasp',
          graspType: 'array-wildcard',
          name: that[1]
        };
      } else if (that = /^\$(\w+)$/.exec(name)) {
        return {
          type: 'Grasp',
          graspType: 'named-wildcard',
          name: that[1]
        };
      } else if (that = /^_([_a-zA-Z]+)/.exec(name)) {
        ident = that[1].replace(/_/, '-');
        if (ident in matchesMap || ident in matchesAliasMap) {
          return {
            type: 'Grasp',
            graspType: 'matches',
            value: matchesMap[matchesAliasMap[ident] || ident]
          };
        } else if (ident in literalMap) {
          return {
            type: 'Grasp',
            graspType: 'literal',
            value: literalMap[ident]
          };
        } else {
          return {
            type: 'Grasp',
            graspType: 'node-type',
            value: aliasMap[ident] || ident
          };
        }
      }
      break;
    case 'MemberExpression':
      if (!node.computed) {
        return;
      }
      attrs = [];
      n = node;
      while (n.type === 'MemberExpression') {
        if (!n.computed) {
          return;
        }
        attrs.unshift(n.property);
        n = n.object;
      }
      if (n.type !== 'Identifier') {
        return;
      }
      ident = processNode(n);
      if (!ident) {
        return;
      }
      processedAttrs = [];
      for (i$ = 0, len$ = attrs.length; i$ < len$; ++i$) {
        attr = attrs[i$];
        if (that = processAttr(attr)) {
          processedAttrs.push(that);
        } else {
          return;
        }
      }
      return {
        type: 'Grasp',
        graspType: 'compound',
        ident: ident,
        attrs: processedAttrs
      };
    case 'ExpressionStatement':
      return processNode(node.expression);
    default:
      if (!(!node.type && node.key != null && node.value != null)) {
        return;
      }
      nodeKey = node.key, nodeValue = node.value;
      if (!(nodeKey.type === 'Identifier' && nodeValue.type === 'Identifier')) {
        return;
      }
      if (nodeKey.name === '_') {
        if (node.value.name === '_') {
          return {
            type: 'Grasp',
            graspType: 'wildcard'
          };
        } else if (/^\$/.test(nodeValue.name)) {
          return {
            type: 'Grasp',
            graspType: 'array-wildcard',
            name: /^\$(\w*)$/.exec(nodeValue.name)[1]
          };
        }
      } else if (nodeKey.name === '$') {
        return {
          type: 'Grasp',
          graspType: 'named-wildcard',
          name: nodeValue.name
        };
      }
    }
  }
  function processAttr(attr){
    var attrType, path, ref$;
    attrType = attr.type;
    if (attrType === 'Identifier') {
      if (processNode(attr)) {} else {
        return {
          path: [attr.name]
        };
      }
    } else if (attrType === 'MemberExpression') {
      path = getMemberPath(attr);
      if (!path) {
        return;
      }
      return {
        path: path
      };
    } else if ((attrType === 'AssignmentExpression' || attrType === 'BinaryExpression') && ((ref$ = attr.operator) === '=' || ref$ === '!=')) {
      path = getMemberPath(attr.left);
      if (!path) {
        return;
      }
      return {
        path: path,
        op: attr.operator,
        value: attr.right
      };
    }
  }
  function getMemberPath(node){
    var path;
    path = [];
    while (node.type === 'MemberExpression') {
      if (node.computed) {
        return;
      }
      path.unshift(node.property.name);
      node = node.object;
    }
    path.unshift(node.name);
    return path;
  }
  module.exports = {
    parse: parse
  };
}).call(this);

},{"./common":55,"grasp-syntax-javascript":63}],59:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var syntaxFlat, toString$ = {}.toString;
  syntaxFlat = require('grasp-syntax-javascript').syntaxFlat;
  function Cache(ast){
    var nodes, types;
    this.ast = ast;
    nodes = [];
    types = [];
    visitPre(ast, function(node){
      var type, i$, ref$, len$, property;
      type = node.type;
      if (type === 'ObjectExpression') {
        for (i$ = 0, len$ = (ref$ = node.properties).length; i$ < len$; ++i$) {
          property = ref$[i$];
          property.type = 'Property';
          property.start = property.key.start;
          property.end = property.value.end;
          if (property.key.loc) {
            property.loc = {
              start: property.key.loc.start,
              end: property.value.loc.end
            };
          }
        }
      }
      nodes.push(node);
      types[type] == null && (types[type] = []);
      types[type].push(node);
    });
    this.nodes = nodes;
    this.types = types;
  }
  function visitPre(ast, fn, path){
    var ref$, nodes, nodeArrays, i$, len$, nodeName, node, newPath, nodeArrayName, nodeArray, j$, len1$;
    fn(ast, path);
    ref$ = syntaxFlat[ast.type], nodes = ref$.nodes, nodeArrays = ref$.nodeArrays;
    if (nodes) {
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
        nodeName = nodes[i$];
        node = ast[nodeName];
        if (!node) {
          continue;
        }
        newPath = path ? path + "." + nodeName : nodeName;
        visitPre(node, fn, newPath);
      }
    }
    if (nodeArrays) {
      for (i$ = 0, len$ = nodeArrays.length; i$ < len$; ++i$) {
        nodeArrayName = nodeArrays[i$];
        nodeArray = ast[nodeArrayName];
        newPath = path ? path + "." + nodeArrayName : nodeArrayName;
        for (j$ = 0, len1$ = nodeArray.length; j$ < len1$; ++j$) {
          node = nodeArray[j$];
          visitPre(node, fn, newPath);
        }
      }
    }
  }
  function visitChildren(ast, fn){
    var ref$, nodes, nodeArrays, i$, len$, nodeName, nodeArrayName, j$, len1$, node;
    ref$ = syntaxFlat[ast.type], nodes = ref$.nodes, nodeArrays = ref$.nodeArrays;
    if (nodes) {
      for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
        nodeName = nodes[i$];
        fn(ast[nodeName]);
      }
    }
    if (nodeArrays) {
      for (i$ = 0, len$ = nodeArrays.length; i$ < len$; ++i$) {
        nodeArrayName = nodeArrays[i$];
        for (j$ = 0, len1$ = (ref$ = ast[nodeArrayName]).length; j$ < len1$; ++j$) {
          node = ref$[j$];
          fn(node);
        }
      }
    }
  }
  function getPath(obj, key){
    var value, i$, ref$, len$, k, newValue;
    value = obj;
    for (i$ = 0, len$ = (ref$ = key.split('.')).length; i$ < len$; ++i$) {
      k = ref$[i$];
      newValue = value[k];
      if (toString$.call(newValue).slice(8, -1) !== 'Undefined') {
        value = newValue;
      } else {
        return;
      }
    }
    return value;
  }
  module.exports = {
    Cache: Cache,
    visitPre: visitPre,
    visitChildren: visitChildren,
    getPath: getPath
  };
}).call(this);

},{"grasp-syntax-javascript":63}],60:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, Cache, parse, ref$, finalMatches, matchAst, queryParsed, query;
  VERSION = '0.2.2';
  Cache = require('./common').Cache;
  parse = require('./parse').parse;
  ref$ = require('./match'), finalMatches = ref$.finalMatches, matchAst = ref$.matchAst;
  queryParsed = function(parsedSelector, ast, cache){
    return finalMatches(matchAst(ast, parsedSelector, cache || new Cache(ast)));
  };
  query = function(selector, ast, cache){
    return queryParsed(parse(selector), ast, cache);
  };
  module.exports = {
    parse: parse,
    queryParsed: queryParsed,
    query: query,
    Cache: Cache,
    VERSION: VERSION
  };
}).call(this);

},{"./common":59,"./match":61,"./parse":62}],61:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, any, all, literalMap, syntaxFlat, Cache, visitPre, visitChildren, getPath, toString$ = {}.toString, slice$ = [].slice;
  ref$ = require('prelude-ls'), map = ref$.map, any = ref$.any, all = ref$.all;
  ref$ = require('grasp-syntax-javascript'), literalMap = ref$.literalMap, syntaxFlat = ref$.syntaxFlat;
  ref$ = require('./common'), Cache = ref$.Cache, visitPre = ref$.visitPre, visitChildren = ref$.visitChildren, getPath = ref$.getPath;
  function finalMatches(results){
    var matches, i$, ref$, len$, subjects;
    matches = [];
    if (results.subject.length > 0) {
      for (i$ = 0, len$ = (ref$ = results.subject).length; i$ < len$; ++i$) {
        subjects = ref$[i$];
        matches = matches.concat(subjects);
      }
    } else {
      matches = results.matches;
    }
    return matches;
  }
  function matchAst(ast, selector, cache){
    var subject, matches, isSubject, i$, ref$, len$, node, selVal, name, op, value, valueType, sel, left, props, subjects, leftResults, leftSubject, result, subs, propsLen, hasMatch, previousNode, j$, len1$, i, prop, newNode, k$, len2$, p, nodeInfo, l$, len3$, field, res$, propValue, sub, matchesSelector, ref1$, rightResults, leftMatches, rightSubject, rightMatches, leftI, leftNode;
    subject = [];
    matches = [];
    if (!selector) {
      return {
        subject: subject,
        matches: matches
      };
    }
    isSubject = selector.subject;
    switch (selector.type) {
    case 'wildcard':
      for (i$ = 0, len$ = (ref$ = cache.nodes).length; i$ < len$; ++i$) {
        node = ref$[i$];
        matches.push(node);
        if (isSubject) {
          subject.push([node]);
        }
      }
      break;
    case 'root':
      matches.push(ast);
      if (isSubject) {
        subject.push([ast]);
      }
      break;
    case 'identifier':
      if (cache.types.hasOwnProperty(selector.value)) {
        for (i$ = 0, len$ = (ref$ = cache.types[selector.value]).length; i$ < len$; ++i$) {
          node = ref$[i$];
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'nth-child':
      visitPre(ast, function(node){
        var index, i$, val, len;
        index = selector.index.value;
        for (i$ in node) {
          val = node[i$];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            len = val.length;
            if (0 <= index && index < len) {
              matches.push(val[index]);
              if (isSubject) {
                subject.push([val[index]]);
              }
            }
          }
        }
      });
      break;
    case 'nth-last-child':
      visitPre(ast, function(node){
        var index, i$, val, len, i;
        index = selector.index.value;
        for (i$ in node) {
          val = node[i$];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            len = val.length;
            i = len - index - 1;
            if (0 <= i && i < len) {
              matches.push(val[i]);
              if (isSubject) {
                subject.push([val[i]]);
              }
            }
          }
        }
      });
      break;
    case 'attribute':
      selVal = selector.value;
      name = selector.name;
      if (selVal != null) {
        op = selector.operator;
        value = selVal.value;
        valueType = toString$.call(value).slice(8, -1);
        switch (selector.valType) {
        case 'primitive':
          switch (selVal.type) {
          case 'literal':
            visitPre(ast, function(node){
              if (isMatchPrimitiveLiteral(getPath(node, name), op, value, valueType)) {
                matches.push(node);
                if (isSubject) {
                  subject.push([node]);
                }
              }
            });
            break;
          case 'type':
            visitPre(ast, function(node){
              if (isMatchType(getPath(node, name), op, value)) {
                matches.push(node);
                if (isSubject) {
                  subject.push([node]);
                }
              }
            });
          }
          break;
        case 'either':
          sel = selVal.sel;
          visitPre(ast, function(node){
            var nodeValue;
            nodeValue = getPath(node, name);
            if ('object' === typeof nodeValue && (nodeValue != null && nodeValue.type) && isMatchComplex(nodeValue, op, value, sel) || isMatchPrimitiveLiteral(nodeValue, op, value, valueType)) {
              matches.push(node);
              if (isSubject) {
                subject.push([node]);
              }
            }
          });
          break;
        case 'complex':
          visitPre(ast, function(node){
            if (isMatchComplex(getPath(node, name), op, value, selVal)) {
              matches.push(node);
              if (isSubject) {
                subject.push([node]);
              }
            }
          });
        }
      } else {
        visitPre(ast, function(node){
          if (getPath(node, name) != null) {
            matches.push(node);
            if (isSubject) {
              subject.push([node]);
            }
          }
        });
      }
      break;
    case 'prop':
      left = selector.left, props = selector.props, subjects = selector.subjects;
      leftResults = finalMatches(matchAst(ast, left, cache));
      leftSubject = left.subject;
      for (i$ = 0, len$ = leftResults.length; i$ < len$; ++i$) {
        result = leftResults[i$];
        node = result;
        subs = [];
        propsLen = props.length;
        hasMatch = false;
        for (j$ = 0, len1$ = props.length; j$ < len1$; ++j$) {
          i = j$;
          prop = props[j$];
          previousNode = node;
          if (prop.type === 'wildcard') {
            if (toString$.call(node).slice(8, -1) === 'Array') {
              newNode = [];
              for (k$ = 0, len2$ = node.length; k$ < len2$; ++k$) {
                p = node[k$];
                nodeInfo = syntaxFlat[p.type];
                for (l$ = 0, len3$ = (ref$ = nodeInfo.nodes.concat(nodeInfo.nodeArrays)).length; l$ < len3$; ++l$) {
                  field = ref$[l$];
                  if (p[field] != null) {
                    newNode.push(p[field]);
                  }
                }
              }
              node = newNode;
            } else {
              nodeInfo = syntaxFlat[node.type];
              res$ = [];
              for (k$ = 0, len2$ = (ref$ = nodeInfo.nodes.concat(nodeInfo.nodeArrays)).length; k$ < len2$; ++k$) {
                field = ref$[k$];
                if (node[field] != null) {
                  res$.push(node[field]);
                }
              }
              node = res$;
            }
          } else if (prop.type === 'string') {
            propValue = prop.value;
            if (toString$.call(node).slice(8, -1) === 'Array') {
              res$ = [];
              for (k$ = 0, len2$ = node.length; k$ < len2$; ++k$) {
                p = node[k$];
                if (p[propValue] != null) {
                  res$.push(p[propValue]);
                }
              }
              node = res$;
            } else {
              node = node[propValue];
            }
          } else if (toString$.call(node).slice(8, -1) === 'Array') {
            switch (prop.type) {
            case 'first':
            case 'head':
              node = node[0];
              break;
            case 'tail':
              node = node.slice(1);
              break;
            case 'last':
              node = node[node.length - 1];
              break;
            case 'initial':
              node = node.slice(0, node.length - 1);
              break;
            case 'nth':
              node = node[prop.index.value];
              break;
            case 'nth-last':
              node = node[node.length - prop.index.value - 1];
              break;
            case 'slice':
              node = node.slice.apply(node, map(fn$, prop.indicies));
            }
          } else {
            break;
          }
          if (node == null) {
            break;
          }
          if (toString$.call(node).slice(8, -1) === 'String' && prop.value === 'operator') {
            node = {
              type: 'Operator',
              value: node,
              loc: {
                start: (ref$ = previousNode.left.loc) != null ? ref$.end : void 8,
                end: (ref$ = previousNode.right.loc) != null ? ref$.start : void 8
              },
              raw: node
            };
          }
          if (node.type != null) {
            if (subjects[i]) {
              subs.push(node);
            }
          } else if (toString$.call(node).slice(8, -1) === 'Array' && node.length) {
            if (subjects[i]) {
              subs = subs.concat(node);
            }
          } else {
            break;
          }
          if (i === propsLen - 1) {
            hasMatch = true;
          }
        }
        if (hasMatch) {
          if (toString$.call(node).slice(8, -1) === 'Array') {
            matches = matches.concat(node);
          } else {
            matches.push(node);
          }
          if (leftSubject) {
            subject.push([result]);
          }
          if (subs.length) {
            for (j$ = 0, len1$ = subs.length; j$ < len1$; ++j$) {
              sub = subs[j$];
              subject.push([sub]);
            }
          }
        }
      }
      break;
    case 'matches':
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        matchesSelector = ref$[i$];
        for (j$ = 0, len1$ = (ref1$ = finalMatches(matchAst(ast, matchesSelector, cache))).length; j$ < len1$; ++j$) {
          node = ref1$[j$];
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'not':
      rightResults = [];
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        sel = ref$[i$];
        rightResults = rightResults.concat(finalMatches(matchAst(ast, sel, cache)));
      }
      visitPre(ast, function(node){
        if (!in$(node, rightResults)) {
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      });
      break;
    case 'compound':
      res$ = [];
      for (i$ = 0, len$ = (ref$ = selector.selectors).length; i$ < len$; ++i$) {
        sel = ref$[i$];
        res$.push(finalMatches(matchAst(ast, sel, cache)));
      }
      rightResults = res$;
      isSubject = isSubject || any(function(it){
        return it.subject;
      }, selector.selectors);
      for (i$ = 0, len$ = (ref$ = rightResults[0]).length; i$ < len$; ++i$) {
        node = ref$[i$];
        if (all((fn1$), slice$.call(rightResults, 1))) {
          matches.push(node);
          if (isSubject) {
            subject.push([node]);
          }
        }
      }
      break;
    case 'descendant':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      for (i$ = 0, len$ = leftMatches.length; i$ < len$; ++i$) {
        leftI = i$;
        leftNode = leftMatches[i$];
        visitPre(leftNode, fn2$);
      }
      break;
    case 'child':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      for (i$ = 0, len$ = leftMatches.length; i$ < len$; ++i$) {
        leftI = i$;
        leftNode = leftMatches[i$];
        visitChildren(leftNode, fn3$);
      }
      break;
    case 'sibling':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      visitPre(ast, function(node, context){
        var key, val, i$, len$, i, x, leftI, j, rightI, newSubject, that;
        for (key in node) {
          val = node[key];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
              i = i$;
              x = val[i$];
              leftI = leftMatches.indexOf(x);
              if (leftI > -1) {
                j = i + 1;
                for (; j < val.length; j++) {
                  rightI = rightMatches.indexOf(val[j]);
                  if (rightI > -1) {
                    matches.push(val[j]);
                    newSubject = [];
                    if (that = leftSubject[leftI]) {
                      newSubject = that;
                    }
                    if (that = rightSubject[rightI]) {
                      newSubject = newSubject.concat(that);
                    }
                    if (newSubject.length > 0) {
                      subject.push(newSubject);
                    }
                  }
                }
              }
            }
          }
        }
      });
      break;
    case 'adjacent':
      ref$ = matchAst(ast, selector.left, cache), leftSubject = ref$.subject, leftMatches = ref$.matches;
      ref$ = matchAst(ast, selector.right, cache), rightSubject = ref$.subject, rightMatches = ref$.matches;
      visitPre(ast, function(node, context){
        var key, val, i$, len$, i, x, leftI, rightI, newSubject, that;
        for (key in node) {
          val = node[key];
          if (toString$.call(val).slice(8, -1) === 'Array') {
            for (i$ = 0, len$ = val.length; i$ < len$; ++i$) {
              i = i$;
              x = val[i$];
              leftI = leftMatches.indexOf(x);
              if (leftI > -1) {
                rightI = rightMatches.indexOf(val[i + 1]);
                if (rightI > -1) {
                  matches.push(val[i + 1]);
                  newSubject = [];
                  if (that = leftSubject[leftI]) {
                    newSubject = that;
                  }
                  if (that = rightSubject[rightI]) {
                    newSubject = newSubject.concat(that);
                  }
                  if (newSubject.length > 0) {
                    subject.push(newSubject);
                  }
                }
              }
            }
          }
        }
      });
    }
    return {
      subject: subject,
      matches: matches
    };
    function fn$(it){
      return it.value;
    }
    function fn1$(it){
      return in$(node, it);
    }
    function fn2$(rightNode){
      var rightI, newSubject, that;
      if (leftNode === rightNode) {
        return;
      }
      rightI = rightMatches.indexOf(rightNode);
      if (rightI > -1) {
        matches.push(rightNode);
        newSubject = [];
        if (that = leftSubject[leftI]) {
          newSubject = that;
        }
        if (that = rightSubject[rightI]) {
          newSubject = newSubject.concat(that);
        }
        if (newSubject.length > 0) {
          subject.push(newSubject);
        }
      }
    }
    function fn3$(child){
      var rightI, newSubject, that;
      rightI = rightMatches.indexOf(child);
      if (rightI > -1) {
        matches.push(child);
        newSubject = [];
        if (that = leftSubject[leftI]) {
          newSubject = that;
        }
        if (that = rightSubject[rightI]) {
          newSubject = newSubject.concat(that);
        }
        if (newSubject.length > 0) {
          subject.push(newSubject);
        }
      }
    }
  }
  function isMatchPrimitiveLiteral(nodeValue, op, value, valueType){
    var nodeType;
    nodeType = toString$.call(nodeValue).slice(8, -1);
    if (nodeType === 'Undefined' || nodeType === 'Object') {
      return false;
    }
    return op === '=' && (nodeValue === value || (nodeType === valueType && valueType === 'RegExp') && nodeValue.toString() === value.toString()) || op === '!=' && (nodeType !== 'RegExp' && nodeValue !== value || (nodeType === valueType && valueType === 'RegExp') && nodeValue.toString() !== value.toString()) || (op === '=~' || op === '~=') && value.test(nodeValue) || op === '<=' && nodeValue <= value || op === '>=' && nodeValue >= value || op === '<' && nodeValue < value || op === '>' && nodeValue > value;
  }
  function isMatchType(nodeValue, op, value){
    var test;
    test = (literalMap[value] || value).match(RegExp(toString$.call(nodeValue).slice(8, -1) + '', 'i'));
    return op === '=' && test || op === '!=' && !test;
  }
  function addSubjectToFirst(sel){
    var ref$;
    if ((ref$ = sel.type) === 'descendant' || ref$ === 'child' || ref$ === 'sibling' || ref$ === 'adjacent') {
      return addSubjectToFirst(sel.left);
    } else {
      return sel.subject = true;
    }
  }
  function isMatchComplex(nodeValue, op, value, selector){
    var cache, sel, subMatches, subMatchesLen;
    if (nodeValue == null) {
      return false;
    }
    cache = new Cache(nodeValue);
    addSubjectToFirst(selector);
    sel = {
      type: 'compound',
      selectors: [
        selector, {
          type: 'root'
        }
      ]
    };
    subMatches = finalMatches(matchAst(nodeValue, sel, cache));
    subMatchesLen = subMatches.length;
    return op === '=' && subMatchesLen || op === '!=' && !subMatchesLen;
  }
  module.exports = {
    finalMatches: finalMatches,
    matchAst: matchAst
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"./common":59,"grasp-syntax-javascript":63,"prelude-ls":90}],62:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, map, last, lines, compact, join, aliasMap, matchesMap, matchesAliasMap, literalMap, complexTypeMap, attrMap, primitiveOnlyAttributes, eitherAttributes, tokenSplit, operatorMap, toString$ = {}.toString;
  ref$ = require('prelude-ls'), map = ref$.map, last = ref$.last, lines = ref$.lines, compact = ref$.compact, join = ref$.join;
  ref$ = require('grasp-syntax-javascript'), aliasMap = ref$.aliasMap, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap, literalMap = ref$.literalMap, complexTypeMap = ref$.complexTypeMap, attrMap = ref$.attrMap, primitiveOnlyAttributes = ref$.primitiveOnlyAttributes, eitherAttributes = ref$.eitherAttributes;
  function parse(selector){
    return processTokens(tokenize(selector + ""));
  }
  tokenSplit = /\s*(\/(?:\\\/|[^\/])*\/[gimy]*)\s*|(type\([a-zA-Z]*\))|([-a-zA-Z$_][-a-zA-Z$_0-9]*)|([-+]?[0-9]*\.?[0-9]+)|("(?:\\"|[^"])*")|('(?:\\'|[^'])*')|(\*|::?|\+\+|#)|\s*(!=|<=|>=|=~|~=)\s*|\s*(\]|\)|!|\.)|(\[&|\[)\s*|\s*(\,|~|<|>|=|\+|\||\(|\s)\s*/;
  function tokenize(selector){
    var cleanSelector, i$, ref$, len$, token, that, results$ = [];
    cleanSelector = join(',')(
    compact(
    map(function(it){
      return it.replace(/^\s*|\s*$/g, '');
    })(
    lines(
    selector))));
    for (i$ = 0, len$ = (ref$ = cleanSelector.split(tokenSplit)).length; i$ < len$; ++i$) {
      token = ref$[i$];
      if (token) {
        if (token === '*') {
          results$.push({
            type: 'wildcard',
            value: '*'
          });
        } else if (that = /^type\(([a-zA-Z]*)\)$/.exec(token)) {
          results$.push({
            type: 'type',
            value: that[1]
          });
        } else if (token === 'type' || token === 'root' || token === 'not' || token === 'matches' || token === 'first' || token === 'head' || token === 'tail' || token === 'last' || token === 'initial' || token === 'nth' || token === 'nth-last' || token === 'slice' || token === 'first-child' || token === 'nth-child' || token === 'nth-last-child' || token === 'last-child') {
          results$.push({
            type: 'keyword',
            value: token
          });
        } else if (token === 'true' || token === 'false') {
          results$.push({
            type: 'boolean',
            value: token === 'true'
          });
        } else if (token === 'null') {
          results$.push({
            type: 'null',
            value: null
          });
        } else if (that = /^['"](.*)['"]$/.exec(token)) {
          results$.push({
            type: 'string',
            value: that[1].replace(/\\"/, '"').replace(/\\'/, "'")
          });
        } else if (/^[-+]?[0-9]*\.?[0-9]+$/.test(token)) {
          results$.push({
            type: 'number',
            value: parseFloat(token)
          });
        } else if (that = /^\/(.*)\/([gimy]*)$/.exec(token)) {
          results$.push({
            type: 'regexp',
            value: new RegExp(that[1], that[2])
          });
        } else if ((token === '!=' || token === '<=' || token === '>=' || token === '=~' || token === '~=' || token === '>' || token === '<' || token === ',' || token === '~' || token === '=' || token === '!' || token === '#' || token === '.' || token === ':' || token === '::' || token === '+' || token === '[&' || token === '[' || token === ']' || token === '(' || token === ')') || token.match(/\s/)) {
          results$.push({
            type: 'operator',
            value: token
          });
        } else {
          results$.push({
            type: 'identifier',
            value: token
          });
        }
      }
    }
    return results$;
  }
  function processTokens(tokens){
    if (!tokens.length) {
      return null;
    }
    tokens.unshift({
      type: 'operator',
      value: '('
    });
    tokens.push({
      type: 'operator',
      value: ')'
    });
    return consumeImplicitMatches(tokens);
  }
  function consumeImplicitMatches(tokens){
    var args;
    args = consumeComplexArgList(tokens);
    if (args.length > 1) {
      return {
        type: 'matches',
        selectors: args
      };
    } else {
      return args[0];
    }
  }
  function peekOp(tokens, opValue){
    if (tokens.length > 0 && peekType(tokens, 'operator') && (toString$.call(opValue).slice(8, -1) === 'RegExp' && opValue.test(tokens[0].value) || tokens[0].value === opValue)) {
      return tokens[0];
    }
  }
  function consumeOp(tokens, opValue){
    if (peekOp(tokens, opValue)) {
      return tokens.shift();
    } else {
      throw createError("Expected operator " + opValue + ", but found:", tokens[0], tokens);
    }
  }
  function peekType(tokens, type){
    if (tokens.length > 0 && (tokens[0].type === type || toString$.call(type).slice(8, -1) === 'Array' && in$(tokens[0].type, type))) {
      return tokens[0];
    }
  }
  function consumeType(tokens, type){
    if (peekType(tokens, type)) {
      return tokens.shift();
    } else {
      throw createError("Expected type " + type + ", but found:", tokens[0], tokens);
    }
  }
  operatorMap = {
    ' ': 'descendant',
    '>': 'child',
    '~': 'sibling',
    '+': 'adjacent'
  };
  function consumeComplexSelector(tokens){
    var ops, root, wildcard, result, op, opVal, selector;
    ops = /^[\s>~+]$/;
    root = {
      type: 'root'
    };
    wildcard = {
      type: 'wildcard'
    };
    result = peekOp(tokens, ops)
      ? root
      : consumeCompoundSelector(tokens);
    while (peekOp(tokens, ops)) {
      op = tokens.shift();
      opVal = op.value;
      selector = consumeCompoundSelector(tokens);
      result = {
        type: operatorMap[opVal],
        operator: opVal,
        left: result,
        right: selector || wildcard
      };
    }
    return result;
  }
  function consumeCompoundSelector(tokens){
    var result, that, selector;
    result = consumeSelector(tokens);
    if (that = consumeProps(tokens)) {
      result = (that.left = result, that);
    }
    while (tokens.length > 0) {
      selector = consumeSelector(tokens);
      if (selector) {
        if (result.type !== 'compound') {
          result = {
            type: 'compound',
            selectors: [result]
          };
        }
        result.selectors.push(selector);
        if (that = consumeProps(tokens)) {
          result = (that.left = result, that);
        }
      } else {
        break;
      }
    }
    return result || selector;
  }
  function mapSimpleSelector(value){
    return {
      type: 'identifier',
      value: aliasMap[value] || value
    };
  }
  function consumeIdentifier(tokens){
    var value, val;
    value = tokens.shift().value;
    if (value in literalMap) {
      return {
        type: 'compound',
        selectors: [
          {
            type: 'identifier',
            value: 'Literal'
          }, {
            type: 'attribute',
            name: 'value',
            operator: '=',
            valType: 'primitive',
            value: {
              type: 'type',
              value: literalMap[value]
            }
          }
        ]
      };
    } else if (value in matchesMap || value in matchesAliasMap) {
      return {
        type: 'matches',
        selectors: (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = matchesMap[matchesAliasMap[value] || value]).length; i$ < len$; ++i$) {
            val = ref$[i$];
            results$.push({
              type: 'identifier',
              value: val
            });
          }
          return results$;
        }())
      };
    } else if (value in complexTypeMap) {
      switch (complexTypeMap[value]) {
      case 'ImmediatelyInvokedFunctionExpression':
        return {
          type: 'compound',
          selectors: [
            {
              type: 'identifier',
              value: 'CallExpression'
            }, {
              type: 'attribute',
              name: 'callee',
              operator: '=',
              valType: 'complex',
              value: {
                type: 'matches',
                selectors: [
                  {
                    type: 'identifier',
                    value: 'FunctionExpression'
                  }, {
                    type: 'compound',
                    selectors: [
                      {
                        type: 'identifier',
                        value: 'MemberExpression'
                      }, {
                        type: 'attribute',
                        name: 'object',
                        operator: '=',
                        valType: 'complex',
                        value: {
                          type: 'identifier',
                          value: 'FunctionExpression'
                        }
                      }, {
                        type: 'attribute',
                        name: 'property',
                        operator: '=',
                        valType: 'complex',
                        value: {
                          type: 'matches',
                          selectors: [
                            {
                              type: 'compound',
                              selectors: [
                                {
                                  type: 'identifier',
                                  value: 'Identifier'
                                }, {
                                  type: 'attribute',
                                  name: 'name',
                                  operator: '=',
                                  valType: 'primitive',
                                  value: {
                                    type: 'literal',
                                    value: 'call'
                                  }
                                }
                              ]
                            }, {
                              type: 'compound',
                              selectors: [
                                {
                                  type: 'identifier',
                                  value: 'Identifier'
                                }, {
                                  type: 'attribute',
                                  name: 'name',
                                  operator: '=',
                                  valType: 'primitive',
                                  value: {
                                    type: 'literal',
                                    value: 'apply'
                                  }
                                }
                              ]
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            }
          ]
        };
      }
    } else {
      return mapSimpleSelector(value);
    }
  }
  function consumeSelector(tokens){
    var selector, token, value;
    selector = peekType(tokens, 'wildcard')
      ? tokens.shift()
      : peekOp(tokens, '::')
        ? (tokens.shift(), consumeIdentifier(tokens))
        : peekType(tokens, ['keyword', 'identifier'])
          ? consumeIdentifier(tokens)
          : peekType(tokens, ['number', 'string', 'regexp', 'boolean', 'null'])
            ? consumeLiteral(tokens)
            : peekOp(tokens, ':')
              ? consumePseudo(tokens)
              : peekOp(tokens, /\[&?/)
                ? consumeAttribute(tokens)
                : peekOp(tokens, '#')
                  ? (consumeOp(tokens, '#'), token = tokens.shift(), value = token.value, {
                    type: 'compound',
                    selectors: [
                      {
                        type: 'identifier',
                        value: 'Identifier'
                      }, {
                        type: 'attribute',
                        name: 'name',
                        operator: token.type === 'regexp' ? '=~' : '=',
                        valType: 'primitive',
                        value: {
                          type: 'literal',
                          value: value
                        }
                      }
                    ]
                  })
                  : peekOp(tokens, '(')
                    ? consumeImplicitMatches(tokens)
                    : peekOp(tokens, '.') ? {
                      type: 'root'
                    } : void 8;
    if (selector) {
      if (peekOp(tokens, '!')) {
        tokens.shift();
        selector.subject = true;
      }
    }
    return selector;
  }
  function consumeProps(tokens){
    var props, propSubjectIndices, i, ref$;
    props = [];
    propSubjectIndices = {};
    i = 0;
    while (peekOp(tokens, '.') || peekOp(tokens, ':') && ((ref$ = tokens[1].value) === 'first' || ref$ === 'head' || ref$ === 'tail' || ref$ === 'last' || ref$ === 'initial' || ref$ === 'nth' || ref$ === 'nth-last' || ref$ === 'slice')) {
      props.push(peekOp(tokens, '.')
        ? consumeProp(tokens)
        : consumePseudo(tokens));
      if (peekOp(tokens, '!')) {
        consumeOp(tokens, '!');
        propSubjectIndices[i] = true;
      }
      i++;
    }
    if (props.length) {
      return {
        type: 'prop',
        props: props,
        subjects: propSubjectIndices
      };
    }
  }
  function consumeLiteral(tokens){
    var token, value;
    token = tokens.shift();
    value = token.value;
    return {
      type: 'compound',
      selectors: [
        {
          type: 'identifier',
          value: 'Literal'
        }, {
          type: 'attribute',
          name: 'value',
          operator: '=',
          valType: 'primitive',
          value: {
            type: 'literal',
            value: value
          }
        }
      ]
    };
  }
  function consumePseudo(tokens){
    var op, id, that;
    op = consumeOp(tokens, ':');
    id = consumeType(tokens, 'keyword');
    switch (that = id.value) {
    case 'root':
    case 'first':
    case 'head':
    case 'tail':
    case 'last':
    case 'initial':
      return {
        type: that
      };
    case 'nth':
    case 'nth-last':
    case 'nth-child':
    case 'nth-last-child':
      return {
        type: that,
        index: consumeArg(tokens)
      };
    case 'slice':
      return {
        type: that,
        indicies: consumeArgList(tokens)
      };
    case 'first-child':
      return {
        type: 'nth-child',
        index: {
          type: 'literal',
          value: 0
        }
      };
    case 'last-child':
      return {
        type: 'nth-last-child',
        index: {
          type: 'literal',
          value: 0
        }
      };
    case 'matches':
      return consumeImplicitMatches(tokens);
    case 'not':
      return {
        type: that,
        selectors: consumeComplexArgList(tokens)
      };
    default:
      throw createError('Unexpected keyword:', id, tokens);
    }
  }
  function consumeName(tokens){
    var name, val;
    name = '';
    while (!name || peekOp(tokens, '.')) {
      if (name) {
        consumeOp(tokens, '.');
        name += '.';
      }
      val = consumeType(tokens, ['keyword', 'identifier']).value;
      name += attrMap[val] || val;
    }
    return name;
  }
  function consumeAttribute(tokens){
    var op, name, lastName, nextOp, nextToken, val, ref$, valType, value, selector;
    op = consumeType(tokens, 'operator').value;
    name = consumeName(tokens);
    lastName = last(name.split('.'));
    nextOp = consumeType(tokens, 'operator').value;
    if (nextOp === ']') {
      return {
        type: 'attribute',
        name: name
      };
    } else {
      nextToken = tokens[0];
      ref$ = op === '[&' || nextToken.type === 'type' || in$(lastName, primitiveOnlyAttributes)
        ? ['primitive', consumeValue(tokens)]
        : in$(lastName, eitherAttributes)
          ? (val = consumeValue([tokens[0]]), [
            'either', {
              type: val.type,
              value: val.value,
              sel: consumeSelector(tokens)
            }
          ])
          : ['complex', consumeComplexSelector(tokens)], valType = ref$[0], value = ref$[1];
      selector = {
        type: 'attribute',
        name: name,
        operator: nextOp,
        valType: valType,
        value: value
      };
      consumeOp(tokens, ']');
      return selector;
    }
  }
  function consumeProp(tokens){
    var token, name;
    consumeOp(tokens, '.');
    if (peekType(tokens, ['identifier', 'number', 'null', 'boolean'])) {
      token = consumeType(tokens, ['identifier', 'number', 'null', 'boolean']);
      name = token.value;
      return {
        type: 'string',
        value: attrMap[name] || name
      };
    } else {
      return {
        type: 'wildcard'
      };
    }
  }
  function consumeComplexArgList(tokens){
    var result, arg;
    consumeOp(tokens, '(');
    result = [];
    while (tokens.length > 0) {
      arg = consumeComplexSelector(tokens);
      if (arg) {
        result.push(arg);
      } else {
        throw createError('Expected selector argument:', tokens[0], tokens);
      }
      if (peekOp(tokens, ',')) {
        consumeOp(tokens, ',');
      } else {
        break;
      }
    }
    consumeOp(tokens, ')');
    return result;
  }
  function consumeArgList(tokens){
    var result, arg;
    consumeOp(tokens, '(');
    result = [];
    while (tokens.length > 0) {
      arg = consumeValue(tokens);
      if (arg) {
        result.push(arg);
      } else {
        throw createError('Expected argument:', tokens[0], tokens);
      }
      if (peekOp(tokens, ',')) {
        consumeOp(tokens, ',');
      } else {
        break;
      }
    }
    consumeOp(tokens, ')');
    return result;
  }
  function consumeArg(tokens){
    var value;
    consumeOp(tokens, '(');
    value = consumeValue(tokens);
    consumeOp(tokens, ')');
    return value;
  }
  function consumeValue(tokens){
    var token, value, type;
    token = tokens.shift(), value = token.value, type = token.type;
    if (type === 'type') {
      if (!value) {
        throw createError("Expected argument for 'type'.", token, tokens);
      }
      return token;
    } else if (value !== ',' && value !== '(' && value !== ')' && value !== '[' && value !== ']' && value !== '[&') {
      return {
        type: 'literal',
        value: value
      };
    }
  }
  function createError(message, token, tokens){
    return new Error(message + " " + JSON.stringify(token) + "\nRemaining tokens: " + JSON.stringify(tokens, null, '  '));
  }
  module.exports = {
    parse: parse,
    tokenize: tokenize
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{"grasp-syntax-javascript":63,"prelude-ls":90}],63:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, each, keys, difference, intersection, syntax, syntaxFlat, i$, category, nodeName, node, complexTypes, complexTypeMap, key, val, aliasMap, matchesMap, matchesAliasMap, literals, literalMap, attrMap, attrMapInverse, alias, name, primitiveAttributesSet, nonPrimitiveAttributesSet, that, nonPrimitiveAttributes, primitiveAttributes, eitherAttributes, primitiveOnlyAttributes;
  ref$ = require('prelude-ls'), each = ref$.each, keys = ref$.keys, difference = ref$.difference, intersection = ref$.intersection;
  syntax = {
    Misc: {
      Program: {
        alias: 'program',
        nodeArrays: ['body'],
        note: "The root node of a JavaScript program's AST."
      },
      Identifier: {
        alias: 'ident',
        primitives: ['name'],
        example: 'x'
      },
      Literal: {
        alias: 'literal',
        primitives: ['value'],
        example: ['true', '1', '"string"']
      },
      Property: {
        alias: 'prop',
        nodes: ['key', 'value'],
        primitives: ['kind'],
        syntax: '*key*: *value*',
        example: 'a: 1',
        note: 'An object expression (obj) has a list of properties, each being a property.'
      }
    },
    Statements: {
      EmptyStatement: {
        alias: 'empty',
        example: ';'
      },
      BlockStatement: {
        alias: 'block',
        nodeArrays: ['body'],
        syntax: '{\n  *statement_1*\n  *statement_2*\n  *...*\n  *statement_n*\n}',
        example: '{\n  x = 1;\n  f();\n  x++;\n}'
      },
      ExpressionStatement: {
        alias: 'exp-statement',
        nodes: ['expression'],
        syntax: '*expression*;',
        example: '2;',
        note: 'When an expression is used where a statement should be, it is wrapped in an expression statement.'
      },
      IfStatement: {
        alias: 'if',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: 'if (*test*)\n  *consequent*\n[else\n  *alternate*]',
        example: ['if (even(x)) {\n  f(x);\n}', 'if (x === 2) {\n  x++;\n} else {\n  f(x);\n}']
      },
      LabeledStatement: {
        alias: 'label',
        nodes: ['label', 'body'],
        syntax: '*label*: *body*;',
        example: 'outer:\nfor (i = 0; i < xs.length; i++) {\n  for (j = 0; j < ys.length; j++) {\n    if (xs[i] === ys[j]) {\n      break outer;\n    }\n  }\n}'
      },
      BreakStatement: {
        alias: 'break',
        nodes: ['label'],
        syntax: 'break [*label*];',
        example: ['break;', 'break outer;']
      },
      ContinueStatement: {
        alias: 'continue',
        nodes: ['label'],
        syntax: 'continue [*label*];',
        example: ['continue;', 'continue outerLoop;']
      },
      WithStatement: {
        alias: 'with',
        nodes: ['object', 'body'],
        syntax: 'with (*object*)\n  *body*',
        example: 'with ({x: 42}) {\n  f(x);\n}'
      },
      SwitchStatement: {
        alias: 'switch',
        nodes: ['discriminant'],
        nodeArrays: ['cases'],
        syntax: 'switch (*discriminant*) {\n  *case_1*\n  *case_2*\n  *...*\n  *case_n*\n}',
        example: 'switch (num) {\n  case 1:\n    f(\'one\');\n    break;\n  case 2:\n    f(\'two\');\n    break;\n  default:\n    f(\'too many\');\n}'
      },
      ReturnStatement: {
        alias: 'return',
        nodes: ['argument'],
        syntax: 'return *argument*;',
        example: 'return f(2);'
      },
      ThrowStatement: {
        alias: 'throw',
        nodes: ['argument'],
        syntax: 'throw *argument*;',
        example: 'throw new Error("oops");'
      },
      TryStatement: {
        alias: 'try',
        nodes: ['block', 'handler', 'finalizer'],
        syntax: 'try\n  *block*\n[*handler*]\n[finally\n   *finalizer*]',
        example: 'try {\n  result = parse(input);\n} catch (error) {\n  console.error(error.message);\n  result = \'\';\n} finally {\n  g(result);\n}'
      },
      WhileStatement: {
        alias: 'while',
        nodes: ['test', 'body'],
        syntax: 'while (*test*)\n  *body*',
        example: 'while (x < 2) {\n  f(x);\n  x++;\n}'
      },
      DoWhileStatement: {
        alias: 'do-while',
        nodes: ['test', 'body'],
        syntax: 'do\n  *body*\nwhile (*test*);',
        example: 'do {\n  f(x);\n  x++;\n} while (x < 2);'
      },
      ForStatement: {
        alias: 'for',
        nodes: ['init', 'test', 'update', 'body'],
        syntax: 'for ([*init*]; [*test*]; [*update*])\n  *body*',
        example: 'for (var x = 0; x < 2; x++) {\n  f(x);\n}'
      },
      ForInStatement: {
        alias: 'for-in',
        nodes: ['left', 'right', 'body'],
        syntax: 'for (*left* in *right*)\n  *body*',
        example: 'for (prop in object) {\n  f(object[prop]);\n}'
      },
      DebuggerStatement: {
        alias: 'debugger',
        syntax: 'debugger;',
        example: 'debugger;'
      }
    },
    Declarations: {
      FunctionDeclaration: {
        alias: 'func-dec',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        syntax: 'function *id*([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'function f(x, y) {\n  return x * y;\n}',
        note: 'A function declaration contrasts with a function expression (func-exp).'
      },
      VariableDeclaration: {
        alias: 'var-decs',
        nodeArrays: ['declarations'],
        primitives: ['kind'],
        syntax: 'var *declaration_1*[, *declaration_2*, ..., *declaration_n*]',
        example: 'var x = 1, y = 2;',
        note: 'Each declaration is a variable declarator (var-dec).'
      },
      VariableDeclarator: {
        alias: 'var-dec',
        nodes: ['id', 'init'],
        syntax: '*id* = *init*',
        example: 'var x = 2'
      }
    },
    Expressions: {
      ThisExpression: {
        alias: 'this',
        example: 'this'
      },
      ArrayExpression: {
        alias: 'arr',
        nodeArrays: ['elements'],
        syntax: '[*element_0*, *element_1*, *...*, *element_n*]',
        example: ['[1, 2, 3]', '[]']
      },
      ObjectExpression: {
        alias: 'obj',
        nodeArrays: ['properties'],
        syntax: '{\n  *property_1*,\n  *property_2*,\n  *...*,\n  *property_n*\n}',
        example: ['{a: 1, b: 2}', '{}']
      },
      FunctionExpression: {
        alias: 'func-exp',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        syntax: 'function [*id*]([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'var f = function (x, y) {\n  return x * y;\n}',
        note: 'A function expression contrasts with a function declaration (func-dec).'
      },
      SequenceExpression: {
        alias: 'seq',
        nodeArrays: ['expressions'],
        syntax: '*expression_1*, *expression_2*, *...*, *expression_n*',
        example: 'a, b, c'
      },
      UnaryExpression: {
        alias: 'unary',
        nodes: ['argument'],
        primitive: ['operator', 'prefix'],
        syntax: '*operator**argument*',
        example: ['+x', 'typeof x']
      },
      BinaryExpression: {
        alias: 'bi',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x === z'
      },
      AssignmentExpression: {
        alias: 'assign',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: '(y = 2)'
      },
      UpdateExpression: {
        alias: 'update',
        nodes: ['argument'],
        primitives: ['operator', 'prefix'],
        syntax: '*argument**operator*\n\n*or, if prefix*\n\n*operator**argument*',
        example: ['++x', 'x--']
      },
      LogicalExpression: {
        alias: 'logic',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x && y'
      },
      ConditionalExpression: {
        alias: 'cond',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: '*test* ? *consequent* : *alternate*',
        example: 'x % 2 ? "odd" : "even"'
      },
      NewExpression: {
        alias: 'new',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: 'new *callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'new Date(2011, 11, 11)'
      },
      CallExpression: {
        alias: 'call',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: '*callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'f(1,2,3)'
      },
      MemberExpression: {
        alias: 'member',
        nodes: ['object', 'property'],
        primitives: ['computed'],
        syntax: '*object*.*property*',
        example: 'Math.PI'
      }
    },
    Clauses: {
      SwitchCase: {
        alias: 'switch-case',
        nodes: ['test'],
        nodeArrays: ['consequent'],
        syntax: 'case *test* | default :\n  *consequent*',
        example: ['case 1:\n  z = \'one\';\n  break;', 'default:\n  z = \'two\'']
      },
      CatchClause: {
        alias: 'catch',
        nodes: ['param', 'body'],
        syntax: 'catch (*param*)\n  *body*',
        example: 'catch (e) {\n  console.error(e.message);\n}'
      }
    }
  };
  syntaxFlat = {};
  for (i$ in syntax) {
    category = syntax[i$];
    for (nodeName in category) {
      node = category[nodeName];
      syntaxFlat[nodeName] = node;
    }
  }
  complexTypes = {
    iife: 'ImmediatelyInvokedFunctionExpression'
  };
  complexTypeMap = {};
  for (key in complexTypes) {
    val = complexTypes[key];
    complexTypeMap[key] = val;
    complexTypeMap[val] = val;
  }
  aliasMap = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    aliasMap[node.alias] = nodeName;
  }
  matchesMap = {
    Statement: keys(syntax.Statements),
    Declaration: keys(syntax.Declarations),
    Expression: keys(syntax.Expressions),
    Clause: keys(syntax.Clauses),
    BiOp: ['BinaryExpression', 'LogicalExpression', 'AssignmentExpression'],
    Function: ['FunctionDeclaration', 'FunctionExpression'],
    ForLoop: ['ForStatement', 'ForInStatement'],
    WhileLoop: ['DoWhileStatement', 'WhileStatement'],
    Loop: ['ForStatement', 'ForInStatement', 'DoWhileStatement', 'WhileStatement']
  };
  matchesAliasMap = {
    statement: 'Statement',
    dec: 'Declaration',
    exp: 'Expression',
    clause: 'Clause',
    biop: 'BiOp',
    func: 'Function',
    'for-loop': 'ForLoop',
    'while-loop': 'WhileLoop',
    loop: 'Loop'
  };
  literals = {
    'null': 'Null',
    bool: 'Boolean',
    num: 'Number',
    str: 'String',
    regex: 'RegExp'
  };
  literalMap = {};
  for (key in literals) {
    val = literals[key];
    literalMap[key] = val;
    literalMap[val] = val;
  }
  attrMap = {
    exp: 'expression',
    exps: 'expressions',
    then: 'consequent',
    alt: 'alternate',
    'else': 'alternate',
    op: 'operator',
    l: 'left',
    r: 'right',
    arg: 'argument',
    args: 'arguments',
    els: 'elements',
    val: 'value',
    obj: 'object',
    prop: 'property',
    props: 'properties',
    decs: 'declarations'
  };
  attrMapInverse = {};
  for (alias in attrMap) {
    name = attrMap[alias];
    attrMapInverse[name] == null && (attrMapInverse[name] = []);
    attrMapInverse[name].push(alias);
  }
  primitiveAttributesSet = {};
  nonPrimitiveAttributesSet = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    if (that = node.primitives) {
      each(fn$, that);
    }
    if (that = node.nodes) {
      each(fn1$, that);
    }
    if (that = node.nodeArrays) {
      each(fn2$, that);
    }
  }
  nonPrimitiveAttributes = keys(nonPrimitiveAttributesSet);
  primitiveAttributes = keys(primitiveAttributesSet);
  eitherAttributes = intersection(primitiveAttributes, nonPrimitiveAttributes);
  primitiveOnlyAttributes = difference(primitiveAttributes, nonPrimitiveAttributes);
  module.exports = {
    syntax: syntax,
    syntaxFlat: syntaxFlat,
    complexTypeMap: complexTypeMap,
    aliasMap: aliasMap,
    matchesMap: matchesMap,
    matchesAliasMap: matchesAliasMap,
    literalMap: literalMap,
    attrMap: attrMap,
    attrMapInverse: attrMapInverse,
    primitiveOnlyAttributes: primitiveOnlyAttributes,
    eitherAttributes: eitherAttributes
  };
  function fn$(it){
    return primitiveAttributesSet[it] = true;
  }
  function fn1$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
  function fn2$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
}).call(this);

},{"prelude-ls":69}],64:[function(require,module,exports){
var curry, flip, fix, apply;
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g, x){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g, x){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
apply = curry$(function(f, list){
  return f.apply(null, list);
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],65:[function(require,module,exports){
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = curry$(function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
});
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  if (!xs.length) {
    return;
  }
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  if (!xs.length) {
    return;
  }
  return xs[xs.length - 1];
};
initial = function(xs){
  var len;
  len = xs.length;
  if (!len) {
    return;
  }
  return xs.slice(0, len - 1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  return fold(f, memo, xs.concat().reverse());
});
foldr1 = curry$(function(f, xs){
  var ys;
  ys = xs.concat().reverse();
  return fold(f, ys[0], ys.slice(1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = curry$(function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
});
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  if (!xs.length) {
    return [];
  }
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  if (!xs.length) {
    return [];
  }
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, len, i$, i;
  sum = 0;
  len = xs.length;
  for (i$ = 0; i$ < len; ++i$) {
    i = i$;
    sum += xs[i];
  }
  return sum / len;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else if (!xs.length) {
    return xs;
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0 || !xs.length) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(compose$([not$, p]), xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, arr){
  var i = -1, l = arr.length >>> 0;
  while (++i < l) if (x === arr[i] && i in arr) return true;
  return false;
}
function compose$(fs){
  return function(){
    var i, args = arguments;
    for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
    return args[0];
  };
}
function not$(x){ return !x; }

},{}],66:[function(require,module,exports){
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],67:[function(require,module,exports){
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(objectect){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in objectect) {
    value = objectect[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = curry$(function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
});
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],68:[function(require,module,exports){
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var out, res$, i$;
  res$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    res$.push(str);
  }
  out = res$;
  return out.join('');
});
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{}],69:[function(require,module,exports){
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.0.3';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}

},{"./Func.js":64,"./List.js":65,"./Num.js":66,"./Obj.js":67,"./Str.js":68}],70:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parsedTypeCheck, types, toString$ = {}.toString;
  parsedTypeCheck = require('type-check').parsedTypeCheck;
  types = {
    '*': function(value, options){
      switch (toString$.call(value).slice(8, -1)) {
      case 'Array':
        return typeCast(value, {
          type: 'Array'
        }, options);
      case 'Object':
        return typeCast(value, {
          type: 'Object'
        }, options);
      default:
        return {
          type: 'Just',
          value: typesCast(value, [
            {
              type: 'Undefined'
            }, {
              type: 'Null'
            }, {
              type: 'NaN'
            }, {
              type: 'Boolean'
            }, {
              type: 'Number'
            }, {
              type: 'Date'
            }, {
              type: 'RegExp'
            }, {
              type: 'Array'
            }, {
              type: 'Object'
            }, {
              type: 'String'
            }
          ], (options.explicit = true, options))
        };
      }
    },
    Undefined: function(it){
      if (it === 'undefined' || it === void 8) {
        return {
          type: 'Just',
          value: void 8
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Null: function(it){
      if (it === 'null') {
        return {
          type: 'Just',
          value: null
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    NaN: function(it){
      if (it === 'NaN') {
        return {
          type: 'Just',
          value: NaN
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Boolean: function(it){
      if (it === 'true') {
        return {
          type: 'Just',
          value: true
        };
      } else if (it === 'false') {
        return {
          type: 'Just',
          value: false
        };
      } else {
        return {
          type: 'Nothing'
        };
      }
    },
    Number: function(it){
      return {
        type: 'Just',
        value: +it
      };
    },
    Int: function(it){
      return {
        type: 'Just',
        value: parseInt(it)
      };
    },
    Float: function(it){
      return {
        type: 'Just',
        value: parseFloat(it)
      };
    },
    Date: function(value, options){
      var that;
      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
        return {
          type: 'Just',
          value: new Date(+that[1] || that[1])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new Date(+value || value)
        };
      }
    },
    RegExp: function(value, options){
      var that;
      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
        return {
          type: 'Just',
          value: new RegExp(that[1], that[2])
        };
      } else if (options.explicit) {
        return {
          type: 'Nothing'
        };
      } else {
        return {
          type: 'Just',
          value: new RegExp(value)
        };
      }
    },
    Array: function(value, options){
      return castArray(value, {
        of: [{
          type: '*'
        }]
      }, options);
    },
    Object: function(value, options){
      return castFields(value, {
        of: {}
      }, options);
    },
    String: function(it){
      var that;
      if (toString$.call(it).slice(8, -1) !== 'String') {
        return {
          type: 'Nothing'
        };
      }
      if (that = it.match(/^'([\s\S]*)'$/)) {
        return {
          type: 'Just',
          value: that[1].replace(/\\'/g, "'")
        };
      } else if (that = it.match(/^"([\s\S]*)"$/)) {
        return {
          type: 'Just',
          value: that[1].replace(/\\"/g, '"')
        };
      } else {
        return {
          type: 'Just',
          value: it
        };
      }
    }
  };
  function castArray(node, type, options){
    var typeOf, element;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
          element = ref$[i$];
          results$.push(typesCast(element, typeOf, options));
        }
        return results$;
      }())
    };
  }
  function castTuple(node, type, options){
    var result, i, i$, ref$, len$, types, cast;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      };
    }
    result = [];
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      cast = typesCast(node[i], types, options);
      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
        result.push(cast);
      }
      i++;
    }
    if (node.length <= i) {
      return {
        type: 'Just',
        value: result
      };
    } else {
      return {
        type: 'Nothing'
      };
    }
  }
  function castFields(node, type, options){
    var typeOf, key, value;
    if (toString$.call(node).slice(8, -1) !== 'Object') {
      return {
        type: 'Nothing'
      };
    }
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var ref$, results$ = {};
        for (key in ref$ = node) {
          value = ref$[key];
          results$[typesCast(key, [{
            type: 'String'
          }], options)] = typesCast(value, typeOf[key] || [{
            type: '*'
          }], options);
        }
        return results$;
      }())
    };
  }
  function typeCast(node, typeObj, options){
    var type, structure, castFunc, ref$;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
      if (!castFunc) {
        throw new Error("Type not defined: " + type + ".");
      }
      return castFunc(node, options, typesCast);
    } else {
      switch (structure) {
      case 'array':
        return castArray(node, typeObj, options);
      case 'tuple':
        return castTuple(node, typeObj, options);
      case 'fields':
        return castFields(node, typeObj, options);
      }
    }
  }
  function typesCast(node, types, options){
    var i$, len$, type, ref$, valueType, value;
    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
      type = types[i$];
      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
      if (valueType === 'Nothing') {
        continue;
      }
      if (parsedTypeCheck([type], value, {
        customTypes: options.customTypes
      })) {
        return value;
      }
    }
    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  }
  module.exports = typesCast;
}).call(this);

},{"type-check":74}],71:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
  parseString = require('./parse-string');
  cast = require('./cast');
  parseType = require('type-check').parseType;
  VERSION = '0.2.5';
  parsedTypeParse = function(parsedType, string, options){
    options == null && (options = {});
    options.explicit == null && (options.explicit = false);
    options.customTypes == null && (options.customTypes = {});
    return cast(parseString(parsedType, string, options), parsedType, options);
  };
  parse = function(type, string, options){
    return parsedTypeParse(parseType(type), string, options);
  };
  module.exports = {
    VERSION: VERSION,
    parse: parse,
    parsedTypeParse: parsedTypeParse
  };
}).call(this);

},{"./cast":70,"./parse-string":72,"type-check":74}],72:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var reject, special, tokenRegex;
  reject = require('prelude-ls').reject;
  function consumeOp(tokens, op){
    if (tokens[0] === op) {
      return tokens.shift();
    } else {
      throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
    }
  }
  function maybeConsumeOp(tokens, op){
    if (tokens[0] === op) {
      return tokens.shift();
    }
  }
  function consumeList(tokens, arg$, hasDelimiters){
    var open, close, result, untilTest;
    open = arg$[0], close = arg$[1];
    if (hasDelimiters) {
      consumeOp(tokens, open);
    }
    result = [];
    untilTest = "," + (hasDelimiters ? close : '');
    while (tokens.length && (hasDelimiters && tokens[0] !== close)) {
      result.push(consumeElement(tokens, untilTest));
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, close);
    }
    return result;
  }
  function consumeArray(tokens, hasDelimiters){
    return consumeList(tokens, ['[', ']'], hasDelimiters);
  }
  function consumeTuple(tokens, hasDelimiters){
    return consumeList(tokens, ['(', ')'], hasDelimiters);
  }
  function consumeFields(tokens, hasDelimiters){
    var result, untilTest, key;
    if (hasDelimiters) {
      consumeOp(tokens, '{');
    }
    result = {};
    untilTest = "," + (hasDelimiters ? '}' : '');
    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
      key = consumeValue(tokens, ':');
      consumeOp(tokens, ':');
      result[key] = consumeElement(tokens, untilTest);
      maybeConsumeOp(tokens, ',');
    }
    if (hasDelimiters) {
      consumeOp(tokens, '}');
    }
    return result;
  }
  function consumeValue(tokens, untilTest){
    var out;
    untilTest == null && (untilTest = '');
    out = '';
    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
      out += tokens.shift();
    }
    return out;
  }
  function consumeElement(tokens, untilTest){
    switch (tokens[0]) {
    case '[':
      return consumeArray(tokens, true);
    case '(':
      return consumeTuple(tokens, true);
    case '{':
      return consumeFields(tokens, true);
    default:
      return consumeValue(tokens, untilTest);
    }
  }
  function consumeTopLevel(tokens, types, options){
    var ref$, type, structure, origTokens, result, finalResult, x$, y$;
    ref$ = types[0], type = ref$.type, structure = ref$.structure;
    origTokens = tokens.concat();
    if (!options.explicit && types.length === 1 && ((!type && structure) || (type === 'Array' || type === 'Object'))) {
      result = structure === 'array' || type === 'Array'
        ? consumeArray(tokens, tokens[0] === '[')
        : structure === 'tuple'
          ? consumeTuple(tokens, tokens[0] === '(')
          : consumeFields(tokens, tokens[0] === '{');
      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'
        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)
        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
    } else {
      finalResult = consumeElement(tokens);
    }
    return finalResult;
  }
  special = /\[\]\(\)}{:,/.source;
  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
  module.exports = function(types, string, options){
    var tokens, node;
    options == null && (options = {});
    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return "'" + string.replace(/\\'/g, "\\\\'") + "'";
    }
    tokens = reject(not$, string.split(tokenRegex));
    node = consumeTopLevel(tokens, types, options);
    if (!node) {
      throw new Error("Error parsing '" + string + "'.");
    }
    return node;
  };
  function not$(x){ return !x; }
}).call(this);

},{"prelude-ls":90}],73:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, any, all, isItNaN, types, defaultType, customTypes, toString$ = {}.toString;
  ref$ = require('prelude-ls'), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
  types = {
    Number: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it);
      }
    },
    NaN: {
      typeOf: 'Number',
      validate: isItNaN
    },
    Int: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it) && it % 1 === 0;
      }
    },
    Float: {
      typeOf: 'Number',
      validate: function(it){
        return !isItNaN(it);
      }
    },
    Date: {
      typeOf: 'Date',
      validate: function(it){
        return !isItNaN(it.getTime());
      }
    }
  };
  defaultType = {
    array: 'Array',
    tuple: 'Array'
  };
  function checkArray(input, type){
    return all(function(it){
      return checkMultiple(it, type.of);
    }, input);
  }
  function checkTuple(input, type){
    var i, i$, ref$, len$, types;
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      if (!checkMultiple(input[i], types)) {
        return false;
      }
      i++;
    }
    return input.length <= i;
  }
  function checkFields(input, type){
    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
    inputKeys = {};
    numInputKeys = 0;
    for (k in input) {
      inputKeys[k] = true;
      numInputKeys++;
    }
    numOfKeys = 0;
    for (key in ref$ = type.of) {
      types = ref$[key];
      if (!checkMultiple(input[key], types)) {
        return false;
      }
      if (inputKeys[key]) {
        numOfKeys++;
      }
    }
    return type.subset || numInputKeys === numOfKeys;
  }
  function checkStructure(input, type){
    if (!(input instanceof Object)) {
      return false;
    }
    switch (type.structure) {
    case 'fields':
      return checkFields(input, type);
    case 'array':
      return checkArray(input, type);
    case 'tuple':
      return checkTuple(input, type);
    }
  }
  function check(input, typeObj){
    var type, structure, setting, that;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      if (type === '*') {
        return true;
      }
      setting = customTypes[type] || types[type];
      if (setting) {
        return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
      } else {
        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
      }
    } else if (structure) {
      if (that = defaultType[structure]) {
        if (that !== toString$.call(input).slice(8, -1)) {
          return false;
        }
      }
      return checkStructure(input, typeObj);
    } else {
      throw new Error("No type defined. Input: " + input + ".");
    }
  }
  function checkMultiple(input, types){
    if (toString$.call(types).slice(8, -1) !== 'Array') {
      throw new Error("Types must be in an array. Input: " + input + ".");
    }
    return any(function(it){
      return check(input, it);
    }, types);
  }
  module.exports = function(parsedType, input, options){
    options == null && (options = {});
    customTypes = options.customTypes || {};
    return checkMultiple(input, parsedType);
  };
}).call(this);

},{"prelude-ls":90}],74:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, parseType, parsedTypeCheck, typeCheck;
  VERSION = '0.3.1';
  parseType = require('./parse-type');
  parsedTypeCheck = require('./check');
  typeCheck = function(type, input, options){
    return parsedTypeCheck(parseType(type), input, options);
  };
  module.exports = {
    VERSION: VERSION,
    typeCheck: typeCheck,
    parsedTypeCheck: parsedTypeCheck,
    parseType: parseType
  };
}).call(this);

},{"./check":73,"./parse-type":75}],75:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens){
    var token;
    token = tokens[0];
    if (token == null) {
      throw new Error('Unexpected end of input.');
    }
    return token;
  }
  function consumeIdent(tokens){
    var token;
    token = peek(tokens);
    if (!identifierRegex.test(token)) {
      throw new Error("Expected text, got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function consumeOp(tokens, op){
    var token;
    token = peek(tokens);
    if (token !== op) {
      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
    }
    return tokens.shift();
  }
  function maybeConsumeOp(tokens, op){
    var token;
    token = tokens[0];
    if (token === op) {
      return tokens.shift();
    } else {
      return null;
    }
  }
  function consumeArray(tokens){
    var types;
    consumeOp(tokens, '[');
    if (peek(tokens) === ']') {
      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
    }
    types = consumeTypes(tokens);
    consumeOp(tokens, ']');
    return {
      structure: 'array',
      of: types
    };
  }
  function consumeTuple(tokens){
    var components;
    components = [];
    consumeOp(tokens, '(');
    if (peek(tokens) === ')') {
      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
    }
    for (;;) {
      components.push(consumeTypes(tokens));
      maybeConsumeOp(tokens, ',');
      if (')' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, ')');
    return {
      structure: 'tuple',
      of: components
    };
  }
  function consumeFields(tokens){
    var fields, subset, ref$, key, types;
    fields = {};
    consumeOp(tokens, '{');
    subset = false;
    for (;;) {
      if (maybeConsumeOp(tokens, '...')) {
        subset = true;
        break;
      }
      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
      fields[key] = types;
      maybeConsumeOp(tokens, ',');
      if ('}' === peek(tokens)) {
        break;
      }
    }
    consumeOp(tokens, '}');
    return {
      structure: 'fields',
      of: fields,
      subset: subset
    };
  }
  function consumeField(tokens){
    var key, types;
    key = consumeIdent(tokens);
    consumeOp(tokens, ':');
    types = consumeTypes(tokens);
    return [key, types];
  }
  function maybeConsumeStructure(tokens){
    switch (tokens[0]) {
    case '[':
      return consumeArray(tokens);
    case '(':
      return consumeTuple(tokens);
    case '{':
      return consumeFields(tokens);
    }
  }
  function consumeType(tokens){
    var token, wildcard, type, structure;
    token = peek(tokens);
    wildcard = token === '*';
    if (wildcard || identifierRegex.test(token)) {
      type = wildcard
        ? consumeOp(tokens, '*')
        : consumeIdent(tokens);
      structure = maybeConsumeStructure(tokens);
      if (structure) {
        return structure.type = type, structure;
      } else {
        return {
          type: type
        };
      }
    } else {
      structure = maybeConsumeStructure(tokens);
      if (!structure) {
        throw new Error("Unexpected character: " + token);
      }
      return structure;
    }
  }
  function consumeTypes(tokens){
    var lookahead, types, typesSoFar, typeObj, type;
    if ('::' === peek(tokens)) {
      throw new Error("No comment before comment separator '::' found.");
    }
    lookahead = tokens[1];
    if (lookahead != null && lookahead === '::') {
      tokens.shift();
      tokens.shift();
    }
    types = [];
    typesSoFar = {};
    if ('Maybe' === peek(tokens)) {
      tokens.shift();
      types = [
        {
          type: 'Undefined'
        }, {
          type: 'Null'
        }
      ];
      typesSoFar = {
        Undefined: true,
        Null: true
      };
    }
    for (;;) {
      typeObj = consumeType(tokens), type = typeObj.type;
      if (!typesSoFar[type]) {
        types.push(typeObj);
      }
      typesSoFar[type] = true;
      if (!maybeConsumeOp(tokens, '|')) {
        break;
      }
    }
    return types;
  }
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function(input){
    var tokens, e;
    if (!input.length) {
      throw new Error('No type specified.');
    }
    tokens = input.match(tokenRegex) || [];
    if (in$('->', tokens)) {
      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
    }
    try {
      return consumeTypes(tokens);
    } catch (e$) {
      e = e$;
      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
    }
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);

},{}],76:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var ref$, id, find, sort, min, max, map, partition, unlines, nameToRaw, dasherize, wordwrap, getPreText, setHelpStyleDefaults, generateHelpForOption, generateHelp;
  ref$ = require('prelude-ls'), id = ref$.id, find = ref$.find, sort = ref$.sort, min = ref$.min, max = ref$.max, map = ref$.map, partition = ref$.partition, unlines = ref$.unlines;
  ref$ = require('./util'), nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize;
  wordwrap = require('wordwrap');
  getPreText = function(option, arg$, maxWidth){
    var mainName, aliases, ref$, type, description, aliasSeparator, typeSeparator, initialIndent, shortNames, longNames, names, namesString, namesStringLen, typeSeparatorString, typeSeparatorStringLen, typeString, that, wrap;
    mainName = option.option, aliases = (ref$ = option.aliases) != null
      ? ref$
      : [], type = option.type, description = option.description;
    aliasSeparator = arg$.aliasSeparator, typeSeparator = arg$.typeSeparator, initialIndent = arg$.initialIndent;
    ref$ = partition(function(it){
      return it.length === 1;
    }, aliases), shortNames = ref$[0], longNames = ref$[1];
    names = mainName.length === 1
      ? [mainName].concat(shortNames, longNames)
      : shortNames.concat([mainName], longNames);
    namesString = map(nameToRaw, names).join(aliasSeparator);
    namesStringLen = namesString.length;
    typeSeparatorString = mainName === 'NUM' ? '::' : typeSeparator;
    typeSeparatorStringLen = typeSeparatorString.length;
    typeString = (that = option['enum']) ? "One of: " + that.join(', ') : type;
    if (maxWidth != null && !option.boolean && initialIndent + namesStringLen + typeSeparatorStringLen + typeString.length > maxWidth) {
      wrap = wordwrap(initialIndent + namesStringLen + typeSeparatorStringLen, maxWidth);
      return namesString + "" + typeSeparatorString + wrap(typeString).replace(/^\s+/, '');
    } else {
      return namesString + "" + (option.boolean
        ? ''
        : typeSeparatorString + "" + typeString);
    }
  };
  setHelpStyleDefaults = function(helpStyle){
    helpStyle.aliasSeparator == null && (helpStyle.aliasSeparator = ', ');
    helpStyle.typeSeparator == null && (helpStyle.typeSeparator = ' ');
    helpStyle.descriptionSeparator == null && (helpStyle.descriptionSeparator = '  ');
    helpStyle.initialIndent == null && (helpStyle.initialIndent = 2);
    helpStyle.secondaryIndent == null && (helpStyle.secondaryIndent = 4);
    helpStyle.maxPadFactor == null && (helpStyle.maxPadFactor = 1.5);
  };
  generateHelpForOption = function(getOption, arg$){
    var stdout, helpStyle, ref$;
    stdout = arg$.stdout, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : {};
    setHelpStyleDefaults(helpStyle);
    return function(optionName){
      var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString, exampleString, examples, seperator;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      wrap = maxWidth ? wordwrap(maxWidth) : id;
      try {
        option = getOption(dasherize(optionName));
      } catch (e$) {
        e = e$;
        return e.message;
      }
      pre = getPreText(option, helpStyle);
      defaultString = option['default'] ? "\ndefault: " + option['default'] : '';
      restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks like an option.' : '';
      description = option.longDescription || option.description && sentencize(option.description);
      fullDescription = description && restPositionalString
        ? description + " " + restPositionalString
        : (that = description || restPositionalString) ? that : '';
      preDescription = 'description:';
      descriptionString = !fullDescription
        ? ''
        : maxWidth && fullDescription.length - 1 - preDescription.length > maxWidth
          ? "\n" + preDescription + "\n" + wrap(fullDescription)
          : "\n" + preDescription + " " + fullDescription;
      exampleString = (that = option.example) ? (examples = [].concat(that), examples.length > 1
        ? "\nexamples:\n" + unlines(examples)
        : "\nexample: " + examples[0]) : '';
      seperator = defaultString || descriptionString || exampleString ? "\n" + repeatString$('=', pre.length) : '';
      return pre + "" + seperator + defaultString + descriptionString + exampleString;
    };
  };
  generateHelp = function(arg$){
    var options, prepend, append, helpStyle, ref$, stdout, aliasSeparator, typeSeparator, descriptionSeparator, maxPadFactor, initialIndent, secondaryIndent;
    options = arg$.options, prepend = arg$.prepend, append = arg$.append, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : {}, stdout = arg$.stdout;
    setHelpStyleDefaults(helpStyle);
    aliasSeparator = helpStyle.aliasSeparator, typeSeparator = helpStyle.typeSeparator, descriptionSeparator = helpStyle.descriptionSeparator, maxPadFactor = helpStyle.maxPadFactor, initialIndent = helpStyle.initialIndent, secondaryIndent = helpStyle.secondaryIndent;
    return function(arg$){
      var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen, totalLen, initialSpace, wrapAllFull, i, wrap;
      ref$ = arg$ != null
        ? arg$
        : {}, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      output = [];
      out = function(it){
        return output.push(it != null ? it : '');
      };
      if (prepend) {
        out(interpolate ? interp(prepend, interpolate) : prepend);
        out();
      }
      data = [];
      optionCount = 0;
      totalPreLen = 0;
      preLens = [];
      for (i$ = 0, len$ = (ref$ = options).length; i$ < len$; ++i$) {
        item = ref$[i$];
        if (showHidden || !item.hidden) {
          if (that = item.heading) {
            data.push({
              type: 'heading',
              value: that
            });
          } else {
            pre = getPreText(item, helpStyle, maxWidth);
            desc = item['default']
              ? (that = item.description) != null
                ? that + " - default: " + item['default']
                : "default: " + item['default']
              : (that = item.description) != null ? that : '';
            data.push({
              type: 'option',
              pre: pre,
              desc: desc,
              descLen: desc.length
            });
            preLen = pre.length;
            optionCount++;
            totalPreLen += preLen;
            preLens.push(preLen);
          }
        }
      }
      sortedPreLens = sort(preLens);
      maxPreLen = sortedPreLens[sortedPreLens.length - 1];
      preLenMean = initialIndent + totalPreLen / optionCount;
      x = optionCount > 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
      for (i$ = sortedPreLens.length - 1; i$ >= 0; --i$) {
        preLen = sortedPreLens[i$];
        if (preLen <= x) {
          padAmount = preLen;
          break;
        }
      }
      descSepLen = descriptionSeparator.length;
      if (maxWidth != null) {
        fullWrapCount = 0;
        partialWrapCount = 0;
        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
          item = data[i$];
          if (item.type === 'option') {
            pre = item.pre, desc = item.desc, descLen = item.descLen;
            if (descLen === 0) {
              item.wrap = 'none';
            } else {
              preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
              totalLen = preLen + descLen;
              if (totalLen > maxWidth) {
                if (descLen / 2.5 > maxWidth - preLen) {
                  fullWrapCount++;
                  item.wrap = 'full';
                } else {
                  partialWrapCount++;
                  item.wrap = 'partial';
                }
              } else {
                item.wrap = 'none';
              }
            }
          }
        }
      }
      initialSpace = repeatString$(' ', initialIndent);
      wrapAllFull = optionCount > 1 && fullWrapCount + partialWrapCount * 0.5 > optionCount * 0.5;
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        i = i$;
        item = data[i$];
        if (item.type === 'heading') {
          if (i !== 0) {
            out();
          }
          out(item.value + ":");
        } else {
          pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
          if (maxWidth != null) {
            if (wrapAllFull || wrap === 'full') {
              wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
              out(initialSpace + "" + pre + "\n" + wrap(desc));
              continue;
            } else if (wrap === 'partial') {
              wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
              out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, ''));
              continue;
            }
          }
          if (descLen === 0) {
            out(initialSpace + "" + pre);
          } else {
            out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + desc);
          }
        }
      }
      if (append) {
        out();
        out(interpolate ? interp(append, interpolate) : append);
      }
      return unlines(output);
    };
  };
  function pad(str, num){
    var len, padAmount;
    len = str.length;
    padAmount = num - len;
    return str + "" + repeatString$(' ', padAmount > 0 ? padAmount : 0);
  }
  function sentencize(str){
    var first, rest, period;
    first = str.charAt(0).toUpperCase();
    rest = str.slice(1);
    period = /[\.!\?]$/.test(str) ? '' : '.';
    return first + "" + rest + period;
  }
  function interp(string, object){
    return string.replace(/{{([a-zA-Z$_][a-zA-Z$_0-9]*)}}/g, function(arg$, key){
      var ref$;
      return (ref$ = object[key]) != null
        ? ref$
        : "{{" + key + "}}";
    });
  }
  module.exports = {
    generateHelp: generateHelp,
    generateHelpForOption: generateHelpForOption
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);

},{"./util":78,"prelude-ls":90,"wordwrap":84}],77:[function(require,module,exports){
(function (process){
// Generated by LiveScript 1.2.0
(function(){
  var VERSION, ref$, id, map, compact, any, groupBy, chars, isItNaN, keys, Obj, camelize, deepIs, closestString, nameToRaw, dasherize, generateHelp, generateHelpForOption, parsedTypeCheck, parseType, parseLevn, camelizeKeys, parseString, main, toString$ = {}.toString, slice$ = [].slice;
  VERSION = '0.3.0';
  ref$ = require('prelude-ls'), id = ref$.id, map = ref$.map, compact = ref$.compact, any = ref$.any, groupBy = ref$.groupBy, chars = ref$.chars, isItNaN = ref$.isItNaN, keys = ref$.keys, Obj = ref$.Obj, camelize = ref$.camelize;
  deepIs = require('deep-is');
  ref$ = require('./util'), closestString = ref$.closestString, nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize;
  ref$ = require('./help'), generateHelp = ref$.generateHelp, generateHelpForOption = ref$.generateHelpForOption;
  ref$ = require('type-check'), parsedTypeCheck = ref$.parsedTypeCheck, parseType = ref$.parseType;
  parseLevn = require('levn').parsedTypeParse;
  camelizeKeys = function(obj){
    var key, value, results$ = {};
    for (key in obj) {
      value = obj[key];
      results$[camelize(key)] = value;
    }
    return results$;
  };
  parseString = function(string){
    var assignOpt, regex, replaceRegex, result;
    assignOpt = '--?[a-zA-Z][-a-z-A-Z0-9]*=';
    regex = RegExp('(?:' + assignOpt + ')?(?:\'(?:\\\\\'|[^\'])+\'|"(?:\\\\"|[^"])+")|[^\'"\\s]+', 'g');
    replaceRegex = RegExp('^(' + assignOpt + ')?[\'"]([\\s\\S]*)[\'"]$');
    result = map(function(it){
      return it.replace(replaceRegex, '$1$2');
    }, string.match(regex) || []);
    return result;
  };
  main = function(libOptions){
    var opts, defaults, required, traverse, getOption, parse;
    opts = {};
    defaults = {};
    required = [];
    if (toString$.call(libOptions.stdout).slice(8, -1) === 'Undefined') {
      libOptions.stdout = process.stdout;
    }
    traverse = function(options){
      var i$, len$, option, name, e, parsedPossibilities, parsedType, j$, ref$, len1$, possibility, that, rawDependsType, dependsOpts, dependsType, alias;
      if (toString$.call(options).slice(8, -1) !== 'Array') {
        throw new Error('No options defined.');
      }
      for (i$ = 0, len$ = options.length; i$ < len$; ++i$) {
        option = options[i$];
        if (option.heading == null) {
          name = option.option;
          if (opts[name] != null) {
            throw new Error("Option '" + name + "' already defined.");
          }
          if (option.type === 'Boolean') {
            option.boolean == null && (option.boolean = true);
          }
          if (option.parsedType == null) {
            if (!option.type) {
              throw new Error("No type defined for option '" + name + "'.");
            }
            try {
              option.parsedType = parseType(option.type);
            } catch (e$) {
              e = e$;
              throw new Error("Option '" + name + "': Error parsing type '" + option.type + "': " + e.message);
            }
          }
          if (option['default']) {
            try {
              defaults[name] = parseLevn(option.parsedType, option['default']);
            } catch (e$) {
              e = e$;
              throw new Error("Option '" + name + "': Error parsing default value '" + option['default'] + "' for type '" + option.type + "': " + e.message);
            }
          }
          if (option['enum'] && !option.parsedPossiblities) {
            parsedPossibilities = [];
            parsedType = option.parsedType;
            for (j$ = 0, len1$ = (ref$ = option['enum']).length; j$ < len1$; ++j$) {
              possibility = ref$[j$];
              try {
                parsedPossibilities.push(parseLevn(parsedType, possibility));
              } catch (e$) {
                e = e$;
                throw new Error("Option '" + name + "': Error parsing enum value '" + possibility + "' for type '" + option.type + "': " + e.message);
              }
            }
            option.parsedPossibilities = parsedPossibilities;
          }
          if (that = option.dependsOn) {
            if (that.length) {
              ref$ = [].concat(option.dependsOn), rawDependsType = ref$[0], dependsOpts = slice$.call(ref$, 1);
              dependsType = rawDependsType.toLowerCase();
              if (dependsOpts.length) {
                if (dependsType === 'and' || dependsType === 'or') {
                  option.dependsOn = [dependsType].concat(slice$.call(dependsOpts));
                } else {
                  throw new Error("Option '" + name + "': If you have more than one dependency, you must specify either 'and' or 'or'");
                }
              } else {
                if ((ref$ = dependsType.toLowerCase()) === 'and' || ref$ === 'or') {
                  option.dependsOn = null;
                } else {
                  option.dependsOn = ['and', rawDependsType];
                }
              }
            } else {
              option.dependsOn = null;
            }
          }
          if (option.required) {
            required.push(name);
          }
          opts[name] = option;
          if (option.alias || option.aliases) {
            if (name === 'NUM') {
              throw new Error("-NUM option can't have aliases.");
            }
            if (option.alias) {
              option.aliases == null && (option.aliases = [].concat(option.alias));
            }
            for (j$ = 0, len1$ = (ref$ = option.aliases).length; j$ < len1$; ++j$) {
              alias = ref$[j$];
              if (opts[alias] != null) {
                throw new Error("Option '" + alias + "' already defined.");
              }
              opts[alias] = option;
            }
          }
        }
      }
    };
    traverse(libOptions.options);
    getOption = function(name){
      var opt, possiblyMeant;
      opt = opts[name];
      if (opt == null) {
        possiblyMeant = closestString(keys(opts), name);
        throw new Error("Invalid option '" + nameToRaw(name) + "'" + (possiblyMeant ? " - perhaps you meant '" + nameToRaw(possiblyMeant) + "'?" : '.'));
      }
      return opt;
    };
    parse = function(input, arg$){
      var slice, obj, positional, restPositional, overrideRequired, prop, setValue, setDefaults, checkRequired, mutuallyExclusiveError, checkMutuallyExclusive, checkDependency, checkDependencies, args, key, value, option, ref$, i$, len$, arg, that, result, short, argName, usingAssign, val, flags, len, j$, len1$, i, flag, opt, name, negated, noedName, valPrime;
      slice = (arg$ != null
        ? arg$
        : {}).slice;
      obj = {};
      positional = [];
      restPositional = false;
      overrideRequired = false;
      prop = null;
      setValue = function(name, value){
        var opt, val, e;
        opt = getOption(name);
        if (opt.boolean) {
          val = value;
        } else {
          try {
            val = parseLevn(opt.parsedType, value);
          } catch (e$) {
            e = e$;
            throw new Error("Invalid value for option '" + name + "' - expected type " + opt.type + ", received value: " + value + ".");
          }
          if (opt['enum'] && !any(function(it){
            return deepIs(it, val);
          }, opt.parsedPossibilities)) {
            throw new Error("Option " + name + ": '" + val + "' not in [" + opt['enum'].join(', ') + "].");
          }
        }
        if (obj[name] != null) {
          if (libOptions.concatRepeatedArrays && toString$.call(obj[name]).slice(8, -1) === 'Array') {
            obj[name] = obj[name].concat(val);
          } else {
            obj[name] = val;
          }
        } else {
          obj[name] = val;
        }
        if (opt.restPositional) {
          restPositional = true;
        }
        if (opt.overrideRequired) {
          overrideRequired = true;
        }
      };
      setDefaults = function(){
        var name, ref$, value;
        for (name in ref$ = defaults) {
          value = ref$[name];
          if (obj[name] == null) {
            obj[name] = value;
          }
        }
      };
      checkRequired = function(){
        var i$, ref$, len$, name;
        if (overrideRequired) {
          return;
        }
        for (i$ = 0, len$ = (ref$ = required).length; i$ < len$; ++i$) {
          name = ref$[i$];
          if (!obj[name]) {
            throw new Error("Option " + nameToRaw(name) + " is required.");
          }
        }
      };
      mutuallyExclusiveError = function(first, second){
        throw new Error("The options " + nameToRaw(first) + " and " + nameToRaw(second) + " are mutually exclusive - you cannot use them at the same time.");
      };
      checkMutuallyExclusive = function(){
        var rules, i$, len$, rule, present, j$, len1$, element, k$, len2$, opt;
        rules = libOptions.mutuallyExclusive;
        if (!rules) {
          return;
        }
        for (i$ = 0, len$ = rules.length; i$ < len$; ++i$) {
          rule = rules[i$];
          present = null;
          for (j$ = 0, len1$ = rule.length; j$ < len1$; ++j$) {
            element = rule[j$];
            if (toString$.call(element).slice(8, -1) === 'Array') {
              for (k$ = 0, len2$ = element.length; k$ < len2$; ++k$) {
                opt = element[k$];
                if (opt in obj) {
                  if (present != null) {
                    mutuallyExclusiveError(present, opt);
                  } else {
                    present = opt;
                    break;
                  }
                }
              }
            } else {
              if (element in obj) {
                if (present != null) {
                  mutuallyExclusiveError(present, element);
                } else {
                  present = element;
                }
              }
            }
          }
        }
      };
      checkDependency = function(option){
        var dependsOn, type, targetOptionNames, i$, len$, targetOptionName, targetOption;
        dependsOn = option.dependsOn;
        if (!dependsOn || option.dependenciesMet) {
          return true;
        }
        type = dependsOn[0], targetOptionNames = slice$.call(dependsOn, 1);
        for (i$ = 0, len$ = targetOptionNames.length; i$ < len$; ++i$) {
          targetOptionName = targetOptionNames[i$];
          targetOption = obj[targetOptionName];
          if (targetOption && checkDependency(targetOption)) {
            if (type === 'or') {
              return true;
            }
          } else if (type === 'and') {
            throw new Error("The option '" + option.option + "' did not have its dependencies met.");
          }
        }
        if (type === 'and') {
          return true;
        } else {
          throw new Error("The option '" + option.option + "' did not meet any of its dependencies.");
        }
      };
      checkDependencies = function(){
        var name;
        for (name in obj) {
          checkDependency(opts[name]);
        }
      };
      switch (toString$.call(input).slice(8, -1)) {
      case 'String':
        args = parseString(input.slice(slice != null ? slice : 0));
        break;
      case 'Array':
        args = input.slice(slice != null ? slice : 2);
        break;
      case 'Object':
        obj = {};
        for (key in input) {
          value = input[key];
          if (key !== '_') {
            option = getOption(dasherize(key));
            if (parsedTypeCheck(option.parsedType, value)) {
              obj[option.option] = value;
            } else {
              throw new Error("Option '" + option.option + "': Invalid type for '" + value + "' - expected type '" + option.type + "'.");
            }
          }
        }
        checkMutuallyExclusive();
        checkDependencies();
        setDefaults();
        checkRequired();
        return ref$ = camelizeKeys(obj), ref$._ = input._ || [], ref$;
      default:
        throw new Error("Invalid argument to 'parse': " + input + ".");
      }
      for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
        arg = args[i$];
        if (arg === '--') {
          restPositional = true;
        } else if (restPositional) {
          positional.push(arg);
        } else {
          if (that = arg.match(/^(--?)([a-zA-Z][-a-zA-Z0-9]*)(=)?(.*)?$/)) {
            result = that;
            if (prop) {
              throw new Error("Value for '" + prop + "' of type '" + getOption(prop).type + "' required.");
            }
            short = result[1].length === 1;
            argName = result[2];
            usingAssign = result[3] != null;
            val = result[4];
            if (usingAssign && val == null) {
              throw new Error("No value for '" + argName + "' specified.");
            }
            if (short) {
              flags = chars(argName);
              len = flags.length;
              for (j$ = 0, len1$ = flags.length; j$ < len1$; ++j$) {
                i = j$;
                flag = flags[j$];
                opt = getOption(flag);
                name = opt.option;
                if (restPositional) {
                  positional.push(flag);
                } else if (opt.boolean) {
                  setValue(name, true);
                } else if (i === len - 1) {
                  if (usingAssign) {
                    setValue(name, val);
                  } else {
                    prop = name;
                  }
                } else {
                  throw new Error("Can't set argument '" + flag + "' when not last flag in a group of short flags.");
                }
              }
            } else {
              negated = false;
              if (that = argName.match(/^no-(.+)$/)) {
                negated = true;
                noedName = that[1];
                opt = getOption(noedName);
              } else {
                opt = getOption(argName);
              }
              name = opt.option;
              if (opt.boolean) {
                valPrime = usingAssign ? parseLevn([{
                  type: 'Boolean'
                }], val) : true;
                if (negated) {
                  setValue(name, !valPrime);
                } else {
                  setValue(name, valPrime);
                }
              } else {
                if (negated) {
                  throw new Error("Only use 'no-' prefix for Boolean options, not with '" + noedName + "'.");
                }
                if (usingAssign) {
                  setValue(name, val);
                } else {
                  prop = name;
                }
              }
            }
          } else if (that = arg.match(/^-([0-9]+(?:\.[0-9]+)?)$/)) {
            opt = opts.NUM;
            if (!opt) {
              throw new Error('No -NUM option defined.');
            }
            setValue(opt.option, that[1]);
          } else {
            if (prop) {
              setValue(prop, arg);
              prop = null;
            } else {
              positional.push(arg);
            }
          }
        }
      }
      checkMutuallyExclusive();
      checkDependencies();
      setDefaults();
      checkRequired();
      return ref$ = camelizeKeys(obj), ref$._ = positional, ref$;
    };
    return {
      parse: parse,
      generateHelp: generateHelp(libOptions),
      generateHelpForOption: generateHelpForOption(getOption, libOptions)
    };
  };
  main.VERSION = VERSION;
  module.exports = main;
}).call(this);

}).call(this,require("hXUCVB"))
},{"./help":76,"./util":78,"deep-is":79,"hXUCVB":93,"levn":71,"prelude-ls":90,"type-check":82}],78:[function(require,module,exports){
// Generated by LiveScript 1.2.0
(function(){
  var prelude, map, sortBy, fl, closestString, nameToRaw, dasherize;
  prelude = require('prelude-ls'), map = prelude.map, sortBy = prelude.sortBy;
  fl = require('fast-levenshtein');
  closestString = function(possibilities, input){
    var distances, ref$, string, distance;
    if (!possibilities.length) {
      return;
    }
    distances = map(function(it){
      var ref$, longer, shorter;
      ref$ = input.length > it.length
        ? [input, it]
        : [it, input], longer = ref$[0], shorter = ref$[1];
      return {
        string: it,
        distance: fl.get(longer, shorter)
      };
    })(
    possibilities);
    ref$ = sortBy(function(it){
      return it.distance;
    }, distances)[0], string = ref$.string, distance = ref$.distance;
    return string;
  };
  nameToRaw = function(name){
    if (name.length === 1 || name === 'NUM') {
      return "-" + name;
    } else {
      return "--" + name;
    }
  };
  dasherize = function(string){
    if (/^[A-Z]/.test(string)) {
      return string;
    } else {
      return prelude.dasherize(string);
    }
  };
  module.exports = {
    closestString: closestString,
    nameToRaw: nameToRaw,
    dasherize: dasherize
  };
}).call(this);

},{"fast-levenshtein":80,"prelude-ls":90}],79:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],80:[function(require,module,exports){
(function() {
  'use strict';

  /**
   * Extend an Object with another Object's properties.
   *
   * The source objects are specified as additional arguments.
   *
   * @param dst Object the object to extend.
   *
   * @return Object the final object.
   */
  var _extend = function(dst) {
    var sources = Array.prototype.slice.call(arguments, 1);
    for (var i=0; i<sources.length; ++i) {
      var src = sources[i];
      for (var p in src) {
        if (src.hasOwnProperty(p)) dst[p] = src[p];
      }
    }
    return dst;
  };

  /**
   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.
   */
  var Levenshtein = {
    /**
     * Calculate levenshtein distance of the two strings.
     *
     * @param str1 String the first string.
     * @param str2 String the second string.
     * @return Integer the levenshtein distance (0 and above).
     */
    get: function(str1, str2) {
      // base cases
      if (str1 === str2) return 0;
      if (str1.length === 0) return str2.length;
      if (str2.length === 0) return str1.length;

      // two rows
      var previous  = new Array(str2.length + 1),
          current = new Array(str2.length + 1),
          i, j;

      // initialise previous row
      for (i=0; i<previous.length; ++i) {
        previous[i] = i;
      }

      // calculate current row distance from previous row
      for (i=0; i<str1.length; ++i) {
        current[0] = i + 1;

        for (j=0; j<str2.length; ++j) {
          current[j + 1] = Math.min(
              previous[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 ),    // substitution
              current[j] + 1,    // insertion
              previous[j + 1] + 1 // deletion
          );

          // copy current into previous (in preparation for next iteration)
          previous[j] = current[j];
        }

        // copy current into previous (in preparation for next iteration)
        previous[j] = current[j];
      }

      return current[str2.length];
    },

    /**
     * Asynchronously calculate levenshtein distance of the two strings.
     *
     * @param str1 String the first string.
     * @param str2 String the second string.
     * @param cb Function callback function with signature: function(Error err, int distance)
     * @param [options] Object additional options.
     * @param [options.progress] Function progress callback with signature: function(percentComplete)
     */
    getAsync: function(str1, str2, cb, options) {
      options = _extend({}, {
        progress: null
      }, options);

      // base cases
      if (str1 === str2) return cb(null, 0);
      if (str1.length === 0) return cb(null, str2.length);
      if (str2.length === 0) return cb(null, str1.length);

      // two rows
      var previous  = new Array(str2.length + 1),
          current = new Array(str2.length + 1),
          i, j, startTime, currentTime;

      // initialise previous row
      for (i=0; i<previous.length; ++i) {
        previous[i] = i;
      }

      current[0] = 1;

      i = 0;
      j = -1;

      var __calculate = function() {
        // reset timer
        startTime = new Date().valueOf();
        currentTime = startTime;

        // keep going until one second has elapsed
        while (currentTime - startTime < 1000) {
          // reached end of current row?
          if (str2.length <= (++j)) {
            // copy current into previous (in preparation for next iteration)
            previous[j] = current[j];

            // if already done all chars
            if (str1.length <= (++i)) {
              return cb(null, current[str2.length]);
            }
            // else if we have more left to do
            else {
              current[0] = i + 1;
              j = 0;
            }
          }

          // calculation
          current[j + 1] = Math.min(
              previous[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 ),    // substitution
              current[j] + 1,    // insertion
              previous[j + 1] + 1 // deletion
          );

          // copy current into previous (in preparation for next iteration)
          previous[j] = current[j];

          // get current time
          currentTime = new Date().valueOf();
        }

        // send a progress update?
        if (null !== options.progress) {
          try {
            options.progress.call(null, (i * 100.0/ str1.length));
          } catch (err) {
            return cb('Progress callback: ' + err.toString());
          }
        }

        // next iteration
        setTimeout(__calculate(), 0);
      };

      __calculate();
    }

  };


  if (typeof define !== "undefined" && define !== null && define.amd) {
    define(function() {
      return Levenshtein;
    });
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = Levenshtein;
  } else {
    if (typeof window !== "undefined" && window !== null) {
      window.Levenshtein = Levenshtein;
    }
  }
}());


},{}],81:[function(require,module,exports){
module.exports=require(73)
},{"prelude-ls":90}],82:[function(require,module,exports){
module.exports=require(74)
},{"./check":81,"./parse-type":83}],83:[function(require,module,exports){
module.exports=require(75)
},{}],84:[function(require,module,exports){
var wordwrap = module.exports = function (start, stop, params) {
    if (typeof start === 'object') {
        params = start;
        start = params.start;
        stop = params.stop;
    }
    
    if (typeof stop === 'object') {
        params = stop;
        start = start || params.start;
        stop = undefined;
    }
    
    if (!stop) {
        stop = start;
        start = 0;
    }
    
    if (!params) params = {};
    var mode = params.mode || 'soft';
    var re = mode === 'hard' ? /\b/ : /(\S+\s+)/;
    
    return function (text) {
        var chunks = text.toString()
            .split(re)
            .reduce(function (acc, x) {
                if (mode === 'hard') {
                    for (var i = 0; i < x.length; i += stop - start) {
                        acc.push(x.slice(i, i + stop - start));
                    }
                }
                else acc.push(x)
                return acc;
            }, [])
        ;
        
        return chunks.reduce(function (lines, rawChunk) {
            if (rawChunk === '') return lines;
            
            var chunk = rawChunk.replace(/\t/g, '    ');
            
            var i = lines.length - 1;
            if (lines[i].length + chunk.length > stop) {
                lines[i] = lines[i].replace(/\s+$/, '');
                
                chunk.split(/\n/).forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else if (chunk.match(/\n/)) {
                var xs = chunk.split(/\n/);
                lines[i] += xs.shift();
                xs.forEach(function (c) {
                    lines.push(
                        new Array(start + 1).join(' ')
                        + c.replace(/^\s+/, '')
                    );
                });
            }
            else {
                lines[i] += chunk;
            }
            
            return lines;
        }, [ new Array(start + 1).join(' ') ]).join('\n');
    };
};

wordwrap.soft = wordwrap;

wordwrap.hard = function (start, stop) {
    return wordwrap(start, stop, { mode : 'hard' });
};

},{}],85:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var apply, curry, flip, fix, over;
apply = curry$(function(f, list){
  return f.apply(null, list);
});
curry = function(f){
  return curry$(f);
};
flip = curry$(function(f, x, y){
  return f(y, x);
});
fix = function(f){
  return function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  }(function(g){
    return function(){
      return f(g(g)).apply(null, arguments);
    };
  });
};
over = curry$(function(f, g, x, y){
  return f(g(x), g(y));
});
module.exports = {
  curry: curry,
  flip: flip,
  fix: fix,
  apply: apply,
  over: over
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],86:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
each = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    f(x);
  }
  return xs;
});
map = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(f(x));
  }
  return results$;
});
compact = function(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      results$.push(x);
    }
  }
  return results$;
};
filter = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
reject = curry$(function(f, xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      results$.push(x);
    }
  }
  return results$;
});
partition = curry$(function(f, xs){
  var passed, failed, i$, len$, x;
  passed = [];
  failed = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    (f(x) ? passed : failed).push(x);
  }
  return [passed, failed];
});
find = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return x;
    }
  }
});
head = first = function(xs){
  return xs[0];
};
tail = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(1);
};
last = function(xs){
  return xs[xs.length - 1];
};
initial = function(xs){
  if (!xs.length) {
    return;
  }
  return xs.slice(0, -1);
};
empty = function(xs){
  return !xs.length;
};
reverse = function(xs){
  return xs.concat().reverse();
};
unique = function(xs){
  var result, i$, len$, x;
  result = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!in$(x, result)) {
      result.push(x);
    }
  }
  return result;
};
uniqueBy = curry$(function(f, xs){
  var seen, i$, len$, x, val, results$ = [];
  seen = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    val = f(x);
    if (in$(val, seen)) {
      continue;
    }
    seen.push(val);
    results$.push(x);
  }
  return results$;
});
fold = foldl = curry$(function(f, memo, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    memo = f(memo, x);
  }
  return memo;
});
fold1 = foldl1 = curry$(function(f, xs){
  return fold(f, xs[0], xs.slice(1));
});
foldr = curry$(function(f, memo, xs){
  var i$, x;
  for (i$ = xs.length - 1; i$ >= 0; --i$) {
    x = xs[i$];
    memo = f(x, memo);
  }
  return memo;
});
foldr1 = curry$(function(f, xs){
  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
});
unfoldr = curry$(function(f, b){
  var result, x, that;
  result = [];
  x = b;
  while ((that = f(x)) != null) {
    result.push(that[0]);
    x = that[1];
  }
  return result;
});
concat = function(xss){
  return [].concat.apply([], xss);
};
concatMap = curry$(function(f, xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(f(x));
    }
    return results$;
  }()));
});
flatten = function(xs){
  var x;
  return [].concat.apply([], (function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (toString$.call(x).slice(8, -1) === 'Array') {
        results$.push(flatten(x));
      } else {
        results$.push(x);
      }
    }
    return results$;
  }()));
};
difference = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
intersection = function(xs){
  var yss, results, i$, len$, x, j$, len1$, ys;
  yss = slice$.call(arguments, 1);
  results = [];
  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
      ys = yss[j$];
      if (!in$(x, ys)) {
        continue outer;
      }
    }
    results.push(x);
  }
  return results;
};
union = function(){
  var xss, results, i$, len$, xs, j$, len1$, x;
  xss = slice$.call(arguments);
  results = [];
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
      x = xs[j$];
      if (!in$(x, results)) {
        results.push(x);
      }
    }
  }
  return results;
};
countBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key] += 1;
    } else {
      results[key] = 1;
    }
  }
  return results;
});
groupBy = curry$(function(f, xs){
  var results, i$, len$, x, key;
  results = {};
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    key = f(x);
    if (key in results) {
      results[key].push(x);
    } else {
      results[key] = [x];
    }
  }
  return results;
});
andList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!x) {
      return false;
    }
  }
  return true;
};
orList = function(xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (x) {
      return true;
    }
  }
  return false;
};
any = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (f(x)) {
      return true;
    }
  }
  return false;
});
all = curry$(function(f, xs){
  var i$, len$, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    if (!f(x)) {
      return false;
    }
  }
  return true;
});
sort = function(xs){
  return xs.concat().sort(function(x, y){
    if (x > y) {
      return 1;
    } else if (x < y) {
      return -1;
    } else {
      return 0;
    }
  });
};
sortWith = curry$(function(f, xs){
  return xs.concat().sort(f);
});
sortBy = curry$(function(f, xs){
  return xs.concat().sort(function(x, y){
    if (f(x) > f(y)) {
      return 1;
    } else if (f(x) < f(y)) {
      return -1;
    } else {
      return 0;
    }
  });
});
sum = function(xs){
  var result, i$, len$, x;
  result = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result += x;
  }
  return result;
};
product = function(xs){
  var result, i$, len$, x;
  result = 1;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    result *= x;
  }
  return result;
};
mean = average = function(xs){
  var sum, i$, len$, x;
  sum = 0;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    sum += x;
  }
  return sum / xs.length;
};
maximum = function(xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x > max) {
      max = x;
    }
  }
  return max;
};
minimum = function(xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (x < min) {
      min = x;
    }
  }
  return min;
};
maximumBy = curry$(function(f, xs){
  var max, i$, ref$, len$, x;
  max = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) > f(max)) {
      max = x;
    }
  }
  return max;
});
minimumBy = curry$(function(f, xs){
  var min, i$, ref$, len$, x;
  min = xs[0];
  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
    x = ref$[i$];
    if (f(x) < f(min)) {
      min = x;
    }
  }
  return min;
});
scan = scanl = curry$(function(f, memo, xs){
  var last, x;
  last = memo;
  return [memo].concat((function(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      results$.push(last = f(last, x));
    }
    return results$;
  }()));
});
scan1 = scanl1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  return scan(f, xs[0], xs.slice(1));
});
scanr = curry$(function(f, memo, xs){
  xs = xs.concat().reverse();
  return scan(f, memo, xs).reverse();
});
scanr1 = curry$(function(f, xs){
  if (!xs.length) {
    return;
  }
  xs = xs.concat().reverse();
  return scan(f, xs[0], xs.slice(1)).reverse();
});
slice = curry$(function(x, y, xs){
  return xs.slice(x, y);
});
take = curry$(function(n, xs){
  if (n <= 0) {
    return xs.slice(0, 0);
  } else {
    return xs.slice(0, n);
  }
});
drop = curry$(function(n, xs){
  if (n <= 0) {
    return xs;
  } else {
    return xs.slice(n);
  }
});
splitAt = curry$(function(n, xs){
  return [take(n, xs), drop(n, xs)];
});
takeWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(0, i);
});
dropWhile = curry$(function(p, xs){
  var len, i;
  len = xs.length;
  if (!len) {
    return xs;
  }
  i = 0;
  while (i < len && p(xs[i])) {
    i += 1;
  }
  return xs.slice(i);
});
span = curry$(function(p, xs){
  return [takeWhile(p, xs), dropWhile(p, xs)];
});
breakList = curry$(function(p, xs){
  return span(function(){
    return not$(p.apply(this, arguments));
  }, xs);
});
zip = curry$(function(xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push([x, ys[i]]);
  }
  return result;
});
zipWith = curry$(function(f, xs, ys){
  var result, len, i$, len$, i, x;
  result = [];
  len = ys.length;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (i === len) {
      break;
    }
    result.push(f(x, ys[i]));
  }
  return result;
});
zipAll = function(){
  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
  xss = slice$.call(arguments);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    lresult$ = [];
    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
      xs = xss[j$];
      lresult$.push(xs[i]);
    }
    results$.push(lresult$);
  }
  return results$;
};
zipAllWith = function(f){
  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
  xss = slice$.call(arguments, 1);
  minLength = 9e9;
  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
    xs = xss[i$];
    minLength <= (ref$ = xs.length) || (minLength = ref$);
  }
  for (i$ = 0; i$ < minLength; ++i$) {
    i = i$;
    results$.push(f.apply(null, (fn$())));
  }
  return results$;
  function fn$(){
    var i$, ref$, len$, results$ = [];
    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
      xs = ref$[i$];
      results$.push(xs[i]);
    }
    return results$;
  }
};
at = curry$(function(n, xs){
  if (n < 0) {
    return xs[xs.length + n];
  } else {
    return xs[n];
  }
});
elemIndex = curry$(function(el, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      return i;
    }
  }
});
elemIndices = curry$(function(el, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (x === el) {
      results$.push(i);
    }
  }
  return results$;
});
findIndex = curry$(function(f, xs){
  var i$, len$, i, x;
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      return i;
    }
  }
});
findIndices = curry$(function(f, xs){
  var i$, len$, i, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    i = i$;
    x = xs[i$];
    if (f(x)) {
      results$.push(i);
    }
  }
  return results$;
});
module.exports = {
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find,
  head: head,
  first: first,
  tail: tail,
  last: last,
  initial: initial,
  empty: empty,
  reverse: reverse,
  difference: difference,
  intersection: intersection,
  union: union,
  countBy: countBy,
  groupBy: groupBy,
  fold: fold,
  fold1: fold1,
  foldl: foldl,
  foldl1: foldl1,
  foldr: foldr,
  foldr1: foldr1,
  unfoldr: unfoldr,
  andList: andList,
  orList: orList,
  any: any,
  all: all,
  unique: unique,
  uniqueBy: uniqueBy,
  sort: sort,
  sortWith: sortWith,
  sortBy: sortBy,
  sum: sum,
  product: product,
  mean: mean,
  average: average,
  concat: concat,
  concatMap: concatMap,
  flatten: flatten,
  maximum: maximum,
  minimum: minimum,
  maximumBy: maximumBy,
  minimumBy: minimumBy,
  scan: scan,
  scan1: scan1,
  scanl: scanl,
  scanl1: scanl1,
  scanr: scanr,
  scanr1: scanr1,
  slice: slice,
  take: take,
  drop: drop,
  splitAt: splitAt,
  takeWhile: takeWhile,
  dropWhile: dropWhile,
  span: span,
  breakList: breakList,
  zip: zip,
  zipWith: zipWith,
  zipAll: zipAll,
  zipAllWith: zipAllWith,
  at: at,
  elemIndex: elemIndex,
  elemIndices: elemIndices,
  findIndex: findIndex,
  findIndices: findIndices
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function not$(x){ return !x; }
},{}],87:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
max = curry$(function(x$, y$){
  return x$ > y$ ? x$ : y$;
});
min = curry$(function(x$, y$){
  return x$ < y$ ? x$ : y$;
});
negate = function(x){
  return -x;
};
abs = Math.abs;
signum = function(x){
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
};
quot = curry$(function(x, y){
  return ~~(x / y);
});
rem = curry$(function(x$, y$){
  return x$ % y$;
});
div = curry$(function(x, y){
  return Math.floor(x / y);
});
mod = curry$(function(x$, y$){
  var ref$;
  return ((x$) % (ref$ = y$) + ref$) % ref$;
});
recip = (function(it){
  return 1 / it;
});
pi = Math.PI;
tau = pi * 2;
exp = Math.exp;
sqrt = Math.sqrt;
ln = Math.log;
pow = curry$(function(x$, y$){
  return Math.pow(x$, y$);
});
sin = Math.sin;
tan = Math.tan;
cos = Math.cos;
asin = Math.asin;
acos = Math.acos;
atan = Math.atan;
atan2 = curry$(function(x, y){
  return Math.atan2(x, y);
});
truncate = function(x){
  return ~~x;
};
round = Math.round;
ceiling = Math.ceil;
floor = Math.floor;
isItNaN = function(x){
  return x !== x;
};
even = function(x){
  return x % 2 === 0;
};
odd = function(x){
  return x % 2 !== 0;
};
gcd = curry$(function(x, y){
  var z;
  x = Math.abs(x);
  y = Math.abs(y);
  while (y !== 0) {
    z = x % y;
    x = y;
    y = z;
  }
  return x;
});
lcm = curry$(function(x, y){
  return Math.abs(Math.floor(x / gcd(x, y) * y));
});
module.exports = {
  max: max,
  min: min,
  negate: negate,
  abs: abs,
  signum: signum,
  quot: quot,
  rem: rem,
  div: div,
  mod: mod,
  recip: recip,
  pi: pi,
  tau: tau,
  exp: exp,
  sqrt: sqrt,
  ln: ln,
  pow: pow,
  sin: sin,
  tan: tan,
  cos: cos,
  acos: acos,
  asin: asin,
  atan: atan,
  atan2: atan2,
  truncate: truncate,
  round: round,
  ceiling: ceiling,
  floor: floor,
  isItNaN: isItNaN,
  even: even,
  odd: odd,
  gcd: gcd,
  lcm: lcm
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],88:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
values = function(object){
  var i$, x, results$ = [];
  for (i$ in object) {
    x = object[i$];
    results$.push(x);
  }
  return results$;
};
keys = function(object){
  var x, results$ = [];
  for (x in object) {
    results$.push(x);
  }
  return results$;
};
pairsToObj = function(object){
  var i$, len$, x, results$ = {};
  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
    x = object[i$];
    results$[x[0]] = x[1];
  }
  return results$;
};
objToPairs = function(object){
  var key, value, results$ = [];
  for (key in object) {
    value = object[key];
    results$.push([key, value]);
  }
  return results$;
};
listsToObj = curry$(function(keys, values){
  var i$, len$, i, key, results$ = {};
  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
    i = i$;
    key = keys[i$];
    results$[key] = values[i];
  }
  return results$;
});
objToLists = function(object){
  var keys, values, key, value;
  keys = [];
  values = [];
  for (key in object) {
    value = object[key];
    keys.push(key);
    values.push(value);
  }
  return [keys, values];
};
empty = function(object){
  var x;
  for (x in object) {
    return false;
  }
  return true;
};
each = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    f(x);
  }
  return object;
});
map = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
    results$[k] = f(x);
  }
  return results$;
});
compact = function(object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (x) {
      results$[k] = x;
    }
  }
  return results$;
};
filter = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
reject = curry$(function(f, object){
  var k, x, results$ = {};
  for (k in object) {
    x = object[k];
if (!f(x)) {
      results$[k] = x;
    }
  }
  return results$;
});
partition = curry$(function(f, object){
  var passed, failed, k, x;
  passed = {};
  failed = {};
  for (k in object) {
    x = object[k];
    (f(x) ? passed : failed)[k] = x;
  }
  return [passed, failed];
});
find = curry$(function(f, object){
  var i$, x;
  for (i$ in object) {
    x = object[i$];
    if (f(x)) {
      return x;
    }
  }
});
module.exports = {
  values: values,
  keys: keys,
  pairsToObj: pairsToObj,
  objToPairs: objToPairs,
  listsToObj: listsToObj,
  objToLists: objToLists,
  empty: empty,
  each: each,
  map: map,
  filter: filter,
  compact: compact,
  reject: reject,
  partition: partition,
  find: find
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],89:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
split = curry$(function(sep, str){
  return str.split(sep);
});
join = curry$(function(sep, xs){
  return xs.join(sep);
});
lines = function(str){
  if (!str.length) {
    return [];
  }
  return str.split('\n');
};
unlines = function(it){
  return it.join('\n');
};
words = function(str){
  if (!str.length) {
    return [];
  }
  return str.split(/[ ]+/);
};
unwords = function(it){
  return it.join(' ');
};
chars = function(it){
  return it.split('');
};
unchars = function(it){
  return it.join('');
};
reverse = function(str){
  return str.split('').reverse().join('');
};
repeat = curry$(function(n, str){
  var result, i$;
  result = '';
  for (i$ = 0; i$ < n; ++i$) {
    result += str;
  }
  return result;
});
capitalize = function(str){
  return str.charAt(0).toUpperCase() + str.slice(1);
};
camelize = function(it){
  return it.replace(/[-_]+(.)?/g, function(arg$, c){
    return (c != null ? c : '').toUpperCase();
  });
};
dasherize = function(str){
  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
    return lower + "-" + (upper.length > 1
      ? upper
      : upper.toLowerCase());
  }).replace(/^([A-Z]+)/, function(arg$, upper){
    if (upper.length > 1) {
      return upper + "-";
    } else {
      return upper.toLowerCase();
    }
  });
};
module.exports = {
  split: split,
  join: join,
  lines: lines,
  unlines: unlines,
  words: words,
  unwords: unwords,
  chars: chars,
  unchars: unchars,
  reverse: reverse,
  repeat: repeat,
  capitalize: capitalize,
  camelize: camelize,
  dasherize: dasherize
};
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{}],90:[function(require,module,exports){
// Generated by LiveScript 1.2.0
var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
Func = require('./Func.js');
List = require('./List.js');
Obj = require('./Obj.js');
Str = require('./Str.js');
Num = require('./Num.js');
id = function(x){
  return x;
};
isType = curry$(function(type, x){
  return toString$.call(x).slice(8, -1) === type;
});
replicate = curry$(function(n, x){
  var i$, results$ = [];
  for (i$ = 0; i$ < n; ++i$) {
    results$.push(x);
  }
  return results$;
});
Str.empty = List.empty;
Str.slice = List.slice;
Str.take = List.take;
Str.drop = List.drop;
Str.splitAt = List.splitAt;
Str.takeWhile = List.takeWhile;
Str.dropWhile = List.dropWhile;
Str.span = List.span;
Str.breakStr = List.breakList;
prelude = {
  Func: Func,
  List: List,
  Obj: Obj,
  Str: Str,
  Num: Num,
  id: id,
  isType: isType,
  replicate: replicate
};
prelude.each = List.each;
prelude.map = List.map;
prelude.filter = List.filter;
prelude.compact = List.compact;
prelude.reject = List.reject;
prelude.partition = List.partition;
prelude.find = List.find;
prelude.head = List.head;
prelude.first = List.first;
prelude.tail = List.tail;
prelude.last = List.last;
prelude.initial = List.initial;
prelude.empty = List.empty;
prelude.reverse = List.reverse;
prelude.difference = List.difference;
prelude.intersection = List.intersection;
prelude.union = List.union;
prelude.countBy = List.countBy;
prelude.groupBy = List.groupBy;
prelude.fold = List.fold;
prelude.foldl = List.foldl;
prelude.fold1 = List.fold1;
prelude.foldl1 = List.foldl1;
prelude.foldr = List.foldr;
prelude.foldr1 = List.foldr1;
prelude.unfoldr = List.unfoldr;
prelude.andList = List.andList;
prelude.orList = List.orList;
prelude.any = List.any;
prelude.all = List.all;
prelude.unique = List.unique;
prelude.uniqueBy = List.uniqueBy;
prelude.sort = List.sort;
prelude.sortWith = List.sortWith;
prelude.sortBy = List.sortBy;
prelude.sum = List.sum;
prelude.product = List.product;
prelude.mean = List.mean;
prelude.average = List.average;
prelude.concat = List.concat;
prelude.concatMap = List.concatMap;
prelude.flatten = List.flatten;
prelude.maximum = List.maximum;
prelude.minimum = List.minimum;
prelude.maximumBy = List.maximumBy;
prelude.minimumBy = List.minimumBy;
prelude.scan = List.scan;
prelude.scanl = List.scanl;
prelude.scan1 = List.scan1;
prelude.scanl1 = List.scanl1;
prelude.scanr = List.scanr;
prelude.scanr1 = List.scanr1;
prelude.slice = List.slice;
prelude.take = List.take;
prelude.drop = List.drop;
prelude.splitAt = List.splitAt;
prelude.takeWhile = List.takeWhile;
prelude.dropWhile = List.dropWhile;
prelude.span = List.span;
prelude.breakList = List.breakList;
prelude.zip = List.zip;
prelude.zipWith = List.zipWith;
prelude.zipAll = List.zipAll;
prelude.zipAllWith = List.zipAllWith;
prelude.at = List.at;
prelude.elemIndex = List.elemIndex;
prelude.elemIndices = List.elemIndices;
prelude.findIndex = List.findIndex;
prelude.findIndices = List.findIndices;
prelude.apply = Func.apply;
prelude.curry = Func.curry;
prelude.flip = Func.flip;
prelude.fix = Func.fix;
prelude.over = Func.over;
prelude.split = Str.split;
prelude.join = Str.join;
prelude.lines = Str.lines;
prelude.unlines = Str.unlines;
prelude.words = Str.words;
prelude.unwords = Str.unwords;
prelude.chars = Str.chars;
prelude.unchars = Str.unchars;
prelude.repeat = Str.repeat;
prelude.capitalize = Str.capitalize;
prelude.camelize = Str.camelize;
prelude.dasherize = Str.dasherize;
prelude.values = Obj.values;
prelude.keys = Obj.keys;
prelude.pairsToObj = Obj.pairsToObj;
prelude.objToPairs = Obj.objToPairs;
prelude.listsToObj = Obj.listsToObj;
prelude.objToLists = Obj.objToLists;
prelude.max = Num.max;
prelude.min = Num.min;
prelude.negate = Num.negate;
prelude.abs = Num.abs;
prelude.signum = Num.signum;
prelude.quot = Num.quot;
prelude.rem = Num.rem;
prelude.div = Num.div;
prelude.mod = Num.mod;
prelude.recip = Num.recip;
prelude.pi = Num.pi;
prelude.tau = Num.tau;
prelude.exp = Num.exp;
prelude.sqrt = Num.sqrt;
prelude.ln = Num.ln;
prelude.pow = Num.pow;
prelude.sin = Num.sin;
prelude.tan = Num.tan;
prelude.cos = Num.cos;
prelude.acos = Num.acos;
prelude.asin = Num.asin;
prelude.atan = Num.atan;
prelude.atan2 = Num.atan2;
prelude.truncate = Num.truncate;
prelude.round = Num.round;
prelude.ceiling = Num.ceiling;
prelude.floor = Num.floor;
prelude.isItNaN = Num.isItNaN;
prelude.even = Num.even;
prelude.odd = Num.odd;
prelude.gcd = Num.gcd;
prelude.lcm = Num.lcm;
prelude.VERSION = '1.1.1';
module.exports = prelude;
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
},{"./Func.js":85,"./List.js":86,"./Num.js":87,"./Obj.js":88,"./Str.js":89}],91:[function(require,module,exports){

},{}],92:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require("hXUCVB"))
},{"hXUCVB":93}],93:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],94:[function(require,module,exports){
exports.isatty = function () { return false; };

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}
exports.WriteStream = WriteStream;

},{}]},{},[7])