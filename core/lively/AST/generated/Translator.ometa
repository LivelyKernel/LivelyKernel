ometa JSTranslator <: Parser {
trans = [:t apply(t):ans] -> ans,
begin =
	:pos trans*:children end
	-> { new lively.AST.Sequence(pos, children) },
number =
	:pos :value
	-> { new lively.AST.Number(pos, value) },
string =
	:pos :value
	-> { new lively.AST.String(pos, value) },
condExpr =
	:pos trans:condExpr trans:trueExpr trans:falseExpr
	-> { new lively.AST.Cond(pos, condExpr, trueExpr, falseExpr) },
if =
	:pos trans:condExpr trans:trueExpr trans:falseExpr
	-> { new lively.AST.If(pos, condExpr, trueExpr, falseExpr) },
while =
	:pos trans:condExpr trans:body
	-> { new lively.AST.While(pos, condExpr, body) },
doWhile =
	:pos trans:body trans:condExpr
	-> { new lively.AST.DoWhile(pos, body, condExpr) },
for =
	:pos trans:init trans:condExpr trans:upd trans:body
	-> { new lively.AST.For(pos, init, condExpr, upd, body) },
forIn =
	:pos trans:name trans:obj trans:body
	-> { new lively.AST.ForIn(pos, name, obj, body) },
set =
	:pos trans:left trans:right
	-> { new lively.AST.Set(pos, left, right) },
mset =
	:pos trans:left :name trans:right
	-> { new lively.AST.ModifyingSet(pos, left, name, right) },
binop =
	:pos :name trans:left trans:right
	-> { new lively.AST.BinaryOp(pos, name, left, right) },
unop =
	:pos :name trans:expr
	-> { new lively.AST.UnaryOp(pos, name, expr) },
preop =
	:pos :name trans:expr
	-> { new lively.AST.PreOp(pos, name, expr) },
postop =
	:pos :name trans:expr
	-> { new lively.AST.PostOp(pos, name, expr) },
this =
	:pos
	-> { new lively.AST.This(pos) },
get =
	:pos :name
	-> { new lively.AST.Variable(pos, name) },
getp =
	:pos trans:slotName trans:obj
	-> { new lively.AST.GetSlot(pos, slotName, obj) },
break =
	:pos
	-> { new lively.AST.Break(pos) },
debugger =
	:pos
	-> { new lively.AST.Debugger(pos) },
continue =
	:pos
	-> { new lively.AST.Continue(pos) },
arr =
	:pos trans*:elements
	-> { new lively.AST.ArrayLiteral(pos, elements) },
return =
	:pos trans:expr
	-> { new lively.AST.Return(pos, expr) },
with =
	:pos trans:obj trans:body
	-> { new lively.AST.With(pos, obj, body) },
send =
	:pos :name trans:recv trans*:args
	-> { new lively.AST.Send(pos, name, recv, args) },
call =
	:pos trans:fn trans*:args
	-> { new lively.AST.Call(pos, fn, args) },
new =
	:pos trans:clsExpr
	-> { new lively.AST.New(pos, clsExpr) },
var =
	:pos :name trans:val
	-> { new lively.AST.VarDeclaration(pos, name, val) },
throw =
	:pos trans:expr
	-> { new lively.AST.Throw(pos, expr) },
try =
	:pos trans:trySeq :errName trans:catchSeq trans:finallySeq
	-> { new lively.AST.TryCatchFinally(pos, trySeq, errName, catchSeq, finallySeq) },
func =
	:pos :args trans:body
	-> { new lively.AST.Function(pos, args, body) },
json =
	:pos trans*:properties
	-> { new lively.AST.ObjectLiteral(pos, properties) },
binding =
	:pos :name trans:property
	-> { new lively.AST.ObjProperty(pos, name, property) },
switch =
	:pos trans:expr trans*:cases
	-> { new lively.AST.Switch(pos, expr, cases) },
case =
	:pos trans:condExpr trans:thenExpr
	-> { new lively.AST.Case(pos, condExpr, thenExpr) },
default =
	:pos trans:defaultExpr
	-> { new lively.AST.Default(pos, defaultExpr) },
regex =
	:pos :exprString :flags
	-> { new lively.AST.Regex(pos, exprString, flags) }
}