module('lively.ide.tools.EntanglementInspector').requires('lively.persistence.Entanglement').toRun(function() {

lively.BuildSpec('lively.ide.tools.EntanglementInspector', {
    _BorderColor: Color.rgb(204,0,0),
    _Extent: lively.pt(624.0,426.0),
    _Position: lively.pt(125.5,174.0),
    _StyleClassNames: ["Morph","Window"],
    cameForward: false,
    className: "lively.morphic.Window",
    collapsedExtent: lively.pt(248.0,22.0),
    collapsedPosition: lively.pt(611.0,448.0),
    collapsedTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 611,
        f: 448
    },
    contentOffset: lively.pt(3.0,22.0),
    draggingEnabled: true,
    droppingEnabled: false,
    entanglemen: "[object Object]",
    entanglement: "[object Object]",
    expandedExtent: lively.pt(624.0,426.0),
    expandedPosition: lively.pt(105.0,333.0),
    expandedTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 105,
        f: 333
    },
    helperMorphs: "[<lively.morphic.ReframeHandle#61EB4...>,<lively.morphic.ReframeHandle#1A85E...>,<lively.morphic.ReframeHandle#593F0...>]",
    highlighted: false,
    ignoreEventsOnExpand: false,
    layout: {
        adjustForNewBounds: true
    },
    listListener: "AttributeConnection([object Object].createEntangledMorph --> <lively.morphic.List#5A0AE... - EntangledMorphsList>.addItem)",
    morphList: {
        isMorphRef: true,
        name: "EntangledMorphsList"
    },
    name: "Entanglement Inspector",
    shape: {
        _BorderColor: Color.rgb(204,0,0),
        _BorderRadius: 0,
        _BorderStyle: "solid",
        _BorderWidth: 0,
        _Extent: lively.pt(624.0,426.0),
        _Fill: null,
        _Opacity: 1,
        _Padding: lively.rect(0,0,0,0),
        _Position: lively.pt(0.0,0.0),
        _StrokeOpacity: false,
        canvasDispatchTable: {
            append: "appendCANVAS",
            appendShape: "renderCANVAS",
            init: "initCANVAS",
            remove: "removeCANVAS",
            setPosition: "attributeChangedCANVAS"
        },
        doNotSerialize: ["_renderContext"],
        htmlDispatchTable: {
            appendShape: "renderHTML",
            init: "initHTML",
            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
            setBorderColor: "setBorderColorHTML",
            setBorderRadius: "setBorderRadiusHTML",
            setBorderStyle: "setBorderStyleHTML",
            setBorderStylingMode: "setBorderStylingModeHTML",
            setBorderWidth: "setBorderWidthHTML",
            setExtent: "setExtentHTML",
            setFill: "setFillHTML",
            setNodeId: "setNodeIdHTML",
            setOpacity: "setOpacityHTML",
            setPadding: "setPaddingHTML",
            setPosition: "setPositionHTML",
            setStrokeOpacity: "setStrokeOpacityHTML"
        },
        renderContextTableType: "shapeRenderContextTable",
        svgDispatchTable: {
            appendShape: "renderSVG",
            init: "initSVG",
            setBorderColor: "setBorderColorSVG",
            setBorderRadius: "setBorderRadiusSVG",
            setBorderStyle: "setBorderStyleSVG",
            setBorderWidth: "setBorderWidthSVG",
            setExtent: "setExtentSVG",
            setFill: "setFillSVG",
            setPosition: "setPositionSVG",
            setStrokeOpacity: "setStrokeOpacitySVG"
        },
        attributeChangedCANVAS: function (ctx, value) {
        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
        this.renderCANVAS(ctx)
    },
        bounds: function () { return this.getBounds() },
        compensateShapeNode: function (ctx) {
        // compensates the shapeNode's position for childmorphs,
        // positions childmorphs against morphNodes (origin!)
        if (!ctx.originNode) return;
        ctx.originNode.style.setProperty(
            'top', -this.getPosition().y + 'px', 'important');
        ctx.originNode.style.setProperty(
            'left', -this.getPosition().x + 'px', 'important');
        ctx.originNode.style.setProperty(
            'position', 'absolute', 'important');

        // FIXME: hack, necessary until the style editor knows
        // about stroke widths of svg lines instead of using borderWidth...
        if (ctx.pathNode) return;

        // compensates the shapeNode's borderWidth for childmorphs,
        // borders don't affect submorphs
        ctx.originNode.style.setProperty(
            'margin-top', -this.getBorderWidth() + 'px', 'important');
        ctx.originNode.style.setProperty(
            'margin-left', -this.getBorderWidth() + 'px', 'important');
    },
        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                if (bounds) this.setBounds(bounds);
                            }}),
        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
        defaultRenderContext: function () { return null },
        getAppearanceStylingMode: function () {
        return this.shapeGetter('AppearanceStylingMode');
    },
        getBorderColor: function () {
        var fill = this.shapeGetter('BorderColor');
        return fill === undefined ? Color.red : fill;
    },
        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
        getBorderStylingMode: function () {
        return this.shapeGetter('BorderStylingMode');
    },
        getBorderWidth: function () {
        return this.shapeGetter('BorderWidth')  || 0;
    },
        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
        getFill: function () { return this.shapeGetter('Fill') || null },
        getFillOpacity: function () {
        var fill = this.getFill();
        return (fill && typeof fill.a === "number") ? fill.a : 1;
    },
        getNodeClass: function () {
        return this.shapeGetter('NodeClass') || [];
    },
        getNodeId: function () {
        return this.shapeGetter('NodeId')
    },
        getOpacity: function () {
        var op = this.shapeGetter('Opacity');
        return op === undefined ? 1 : Number(op);
    },
        getPadding: function () {
        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
    },
        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
        getStrokeOpacity: function () {
        var op = this.shapeGetter('StrokeOpacity');
        return op === undefined ? 1 : op;
    },
        initCANVAS: function () {},
        initHTML: function ($super, ctx) {
        if (!ctx.shapeNode)
            ctx.shapeNode = ctx.domInterface.htmlRect();
        $super(ctx);
        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
    },
        initSVG: function (ctx) {
        if (!ctx.shapeNode)
            ctx.shapeNode = this.createShapeNode(ctx);
        this.setPositionSVG(ctx, this.getPosition());
        this.setExtentSVG(ctx, this.getExtent());
        this.setFillSVG(ctx, this.getFill());
        this.setBorderWidthSVG(ctx, this.getBorderWidth());
        this.setBorderColorSVG(ctx, this.getBorderColor());
        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
    },
        initialize: function (bounds) {
                                if (bounds) this.setBounds(bounds);
                            },
        reallyContainsPoint: function (pt) {
        // Overridden for non-rectangular shapes like lines and ellipses
        // Note assumes that pt is within this.bounds
        return true
    },
        renderCANVAS: function (ctx) {
        var graphicContext = ctx.getGraphicContext(),
            pathSet = false,
            bounds = this.getBounds(),
            fill = this.getFill();
        if (fill) { // Fill first, then stroke
            var alpha = this.getFillOpacity();
            if (alpha != 1) graphicContext.globalAlpha = alpha;
            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
            this.setPath(graphicContext, bounds);
            graphicContext.fill();
            pathSet = true;
        }
        // if (this.getStroke() && this.getStrokeWidth() > 0) {
            // var alpha = this.getStrokeOpacity();
            // if (alpha != 1) graphicContext.globalAlpha = alpha;
            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
            // graphicContext.lineWidth = this.getStrokeWidth();
            // this.drawStrokeOn(graphicContext, bounds, pathSet);
        // }
    },
        renderContext: function () {
        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
        return this._renderContext;
    },
        renderContextDispatch: function (aspect, arg) {
        if (!this._renderContext) this.renderContext();
        // if we cannot lazy initialize the renderContext we just do nothing
        if (!this._renderContext) return undefined;
        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
        if (!renderSpecificAspect) {
            dbgOn(true, 'renderContextTable does no include: ' + aspect);
            return undefined;
        }
        return this[renderSpecificAspect](this._renderContext, arg);
    },
        renderHTML: function (ctx) {
        if (ctx.shapeNode.parentNode) return;
        var child = ctx.morphNode.childNodes[0];
        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
    },
        renderSVG: function (ctx) {
        if (!ctx.shapeNode.parentNode)
            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
    },
        renderUsing: function (renderContext) {
        this.setRenderContext(renderContext);
        this.renderContextDispatch('init');
        this.renderContextDispatch('appendShape');
    },
        setAppearanceStylingMode: function (value) {
        return this.shapeSetter('AppearanceStylingMode', value);
    },
        setAppearanceStylingModeHTML: function (ctx, value) {
        this.setFillHTML(ctx, this.shapeGetter("Fill"));
        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
    },
        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
        setBorderColorHTML: function (ctx, fill) {
        var alpha;
        if (this.getStrokeOpacity() != 1) {
            alpha = this.getStrokeOpacity();
        } else {
            alpha = fill === null ? 0 : fill.a;
        }
        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
    },
        setBorderColorSVG: function () {},
        setBorderHTML: function (ctx, width, fill, opacity) {
        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
            ctx.shapeNode.style['border'] = null;
            this.compensateShapeNode(ctx);
        } else {
            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
        }
    },
        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
        setBorderRadiusHTML: function (ctx, value) {
        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
    },
        setBorderRadiusSVG: function () {},
        setBorderStyle: function (value) {
        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
        return this.shapeSetter('BorderStyle', value);
    },
        setBorderStyleHTML: function (ctx, value) {
        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
    },
        setBorderStyleSVG: function (ctx, value) {
        if (value == 'dashed')
            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
        else if (value == 'dotted')
            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
        else
            ctx.shapeNode.removeAttribute('stroke-dasharray')
    },
        setBorderStylingMode: function (value) {
        return this.shapeSetter('BorderStylingMode', value);
    },
        setBorderStylingModeHTML: function (ctx, value) {
        this.setBorderHTML(
            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
        this.setExtentHTML(ctx, this.getExtent());
    },
        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
        setBorderWidthHTML: function (ctx, width) {
        if (this.getBorderStylingMode()) {
            ctx.shapeNode.style.border = '';
            ctx.shapeNode.style.borderWidth = width+'px';
        } else {
            ctx.shapeNode.style.borderWidth = '';
            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
        }
        this.compensateShapeNode(ctx);
        this.setExtentHTML(ctx, this.getExtent());
        return width;
    },
        setBorderWidthSVG: function (ctx, value) {
        // var node = this.getPathNodeHTML(ctx);
        // node && node.setAttribute('stroke-width', String(value))
    },
        setBounds: function (bounds) {
        this.setPosition(bounds.topLeft());
        this.setExtent(bounds.extent());
        return bounds
    },
        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
        setExtentHTML: function (ctx, value) {
        if (!ctx.shapeNode) return undefined;
        var padding = this.getPadding(),
            paddingWidth = padding.left() + padding.right(),
            paddingHeight = padding.top() + padding.bottom(),
            // HTML isn't using fractions for pixels, rounds internally,
            // this has to be reflected to compensate HTML's box model
            borderWidth = Math.floor(this.getBorderWidth()),
            realExtent = value
                         .addXY(-2 * borderWidth, -2 * borderWidth)
                         .addXY(-paddingWidth, -paddingHeight);
            realExtent = realExtent.maxPt(pt(0,0));
        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
        return realExtent;
    },
        setExtentSVG: function (ctx, value) {
        if (ctx.shapeNode)
            ctx.domInterface.setExtent(ctx.shapeNode, value);
        // update also parents so that shapes is not clipped... really necassary? FIXME
        // if (ctx.morphNode)
            // ctx.domInterface.setExtent(ctx.morphNode, value);
        // if (ctx.morphNode.parentNode.tagName == 'svg')
            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
    },
        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
        setFillHTML: function (ctx, value) {
        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
    },
        setFillOpacity: function (opacity) {
        var fill = this.getFill()
        if (fill && fill.withA)
            this.setFill(fill.withA(opacity))
    },
        setFillSVG: function (ctx, value) {
        if (ctx.shapeNode)
            ctx.domInterface.setFill(ctx.shapeNode, value);
    },
        setNodeClass: function (value) {
        return this.shapeSetter('NodeClass', value);
    },
        setNodeId: function (value) {
        return this.shapeSetter('NodeId', value);
    },
        setNodeIdHTML: function (ctx, id) {
        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
        return id;
    },
        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
        setOpacityHTML: function (ctx, value) {
        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
    },
        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
        setPaddingHTML: function (ctx, r) {
        if (r === undefined || !ctx.shapeNode) return r;
        // Rectangle.inset(left, top, right, bottom) ==>
        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
        ctx.shapeNode.style.padding = s;
        return r;
    },
        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
        graphicContext.beginPath();
        graphicContext.moveTo(bnds.x, bnds.y);
        graphicContext.lineTo(bnds.maxX(), bnds.y);
        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
        graphicContext.lineTo(bnds.x, bnds.maxY());
        graphicContext.closePath();
    },
        setPosition: function (position) { return this.shapeSetter('Position', position) },
        setPositionHTML: function (ctx, value) {
        if (!ctx.shapeNode) return;
        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
        if (ctx.originNode) {
            this.compensateShapeNode(ctx);
        }
    },
        setPositionSVG: function (ctx, value) {
        if (ctx.shapeNode)
            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
    },
        setRenderContext: function (newRenderContext) {
        if (newRenderContext) {
            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                this, newRenderContext.renderContextTableName);
        }
        this._renderContext = newRenderContext;
    },
        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
        setStrokeOpacityHTML: function (ctx, opacity) {
        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
    },
        setStrokeOpacitySVG: function () {},
        setVertices: function () {
        // This does nothing for non path shapes
    },
        shapeGetter: function (propName) { return this['_' + propName] },
        shapeSetter: function (propName, value) {
        if (value === undefined) {
            delete this['_' + propName];
        } else {
            this['_' + propName] = value;
        }
        return this.renderContextDispatch('set' + propName, value);
    },
        vertices: function () {
        var b = this.bounds();
        return [pt(b.x, b.y), pt(b.width, b.height)]
    }
    },
    sourceModule: "lively.morphic.Widgets",
    state: "expanded",
    submorphs: [{
        _BorderColor: Color.rgb(95,94,95),
        _BorderWidth: 1,
        _Extent: lively.pt(618.0,401.0),
        _Fill: Color.rgb(204,204,204),
        _Position: lively.pt(3.0,22.0),
        className: "lively.morphic.Panel",
        droppingEnabled: true,
        entangledMorphsList: {
            isMorphRef: true,
            name: "EntangledMorphsList"
        },
        isCopyMorphRef: true,
        layout: {
            adjustForNewBounds: true,
            grid: lively.pt(30.9,20.1),
            resizeHeight: true,
            resizeWidth: true
        },
        morphRefId: 1,
        ownerApp: "[object Object]",
        ownerWidget: "[object Object]",
        shape: {
            _BorderColor: Color.rgb(95,94,95),
            _BorderRadius: 0,
            _BorderStyle: "solid",
            _BorderWidth: 1,
            _Extent: lively.pt(618.0,401.0),
            _Fill: Color.rgb(204,204,204),
            _Opacity: 1,
            _Padding: lively.rect(0,0,0,0),
            _Position: lively.pt(0.0,0.0),
            canvasDispatchTable: {
                append: "appendCANVAS",
                appendShape: "renderCANVAS",
                init: "initCANVAS",
                remove: "removeCANVAS",
                setPosition: "attributeChangedCANVAS"
            },
            doNotSerialize: ["_renderContext"],
            htmlDispatchTable: {
                appendShape: "renderHTML",
                init: "initHTML",
                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                setBorderColor: "setBorderColorHTML",
                setBorderRadius: "setBorderRadiusHTML",
                setBorderStyle: "setBorderStyleHTML",
                setBorderStylingMode: "setBorderStylingModeHTML",
                setBorderWidth: "setBorderWidthHTML",
                setExtent: "setExtentHTML",
                setFill: "setFillHTML",
                setNodeId: "setNodeIdHTML",
                setOpacity: "setOpacityHTML",
                setPadding: "setPaddingHTML",
                setPosition: "setPositionHTML",
                setStrokeOpacity: "setStrokeOpacityHTML"
            },
            renderContextTableType: "shapeRenderContextTable",
            svgDispatchTable: {
                appendShape: "renderSVG",
                init: "initSVG",
                setBorderColor: "setBorderColorSVG",
                setBorderRadius: "setBorderRadiusSVG",
                setBorderStyle: "setBorderStyleSVG",
                setBorderWidth: "setBorderWidthSVG",
                setExtent: "setExtentSVG",
                setFill: "setFillSVG",
                setPosition: "setPositionSVG",
                setStrokeOpacity: "setStrokeOpacitySVG"
            },
            attributeChangedCANVAS: function (ctx, value) {
            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
            this.renderCANVAS(ctx)
        },
            bounds: function () { return this.getBounds() },
            compensateShapeNode: function (ctx) {
            // compensates the shapeNode's position for childmorphs,
            // positions childmorphs against morphNodes (origin!)
            if (!ctx.originNode) return;
            ctx.originNode.style.setProperty(
                'top', -this.getPosition().y + 'px', 'important');
            ctx.originNode.style.setProperty(
                'left', -this.getPosition().x + 'px', 'important');
            ctx.originNode.style.setProperty(
                'position', 'absolute', 'important');
    
            // FIXME: hack, necessary until the style editor knows
            // about stroke widths of svg lines instead of using borderWidth...
            if (ctx.pathNode) return;
    
            // compensates the shapeNode's borderWidth for childmorphs,
            // borders don't affect submorphs
            ctx.originNode.style.setProperty(
                'margin-top', -this.getBorderWidth() + 'px', 'important');
            ctx.originNode.style.setProperty(
                'margin-left', -this.getBorderWidth() + 'px', 'important');
        },
            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                    if (bounds) this.setBounds(bounds);
                                }}),
            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
            defaultRenderContext: function () { return null },
            getAppearanceStylingMode: function () {
            return this.shapeGetter('AppearanceStylingMode');
        },
            getBorderColor: function () {
            var fill = this.shapeGetter('BorderColor');
            return fill === undefined ? Color.red : fill;
        },
            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
            getBorderStylingMode: function () {
            return this.shapeGetter('BorderStylingMode');
        },
            getBorderWidth: function () {
            return this.shapeGetter('BorderWidth')  || 0;
        },
            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
            getFill: function () { return this.shapeGetter('Fill') || null },
            getFillOpacity: function () {
            var fill = this.getFill();
            return (fill && typeof fill.a === "number") ? fill.a : 1;
        },
            getNodeClass: function () {
            return this.shapeGetter('NodeClass') || [];
        },
            getNodeId: function () {
            return this.shapeGetter('NodeId')
        },
            getOpacity: function () {
            var op = this.shapeGetter('Opacity');
            return op === undefined ? 1 : Number(op);
        },
            getPadding: function () {
            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
        },
            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
            getStrokeOpacity: function () {
            var op = this.shapeGetter('StrokeOpacity');
            return op === undefined ? 1 : op;
        },
            initCANVAS: function () {},
            initHTML: function ($super, ctx) {
            if (!ctx.shapeNode)
                ctx.shapeNode = ctx.domInterface.htmlRect();
            $super(ctx);
            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
        },
            initSVG: function (ctx) {
            if (!ctx.shapeNode)
                ctx.shapeNode = this.createShapeNode(ctx);
            this.setPositionSVG(ctx, this.getPosition());
            this.setExtentSVG(ctx, this.getExtent());
            this.setFillSVG(ctx, this.getFill());
            this.setBorderWidthSVG(ctx, this.getBorderWidth());
            this.setBorderColorSVG(ctx, this.getBorderColor());
            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
        },
            initialize: function (bounds) {
                                    if (bounds) this.setBounds(bounds);
                                },
            reallyContainsPoint: function (pt) {
            // Overridden for non-rectangular shapes like lines and ellipses
            // Note assumes that pt is within this.bounds
            return true
        },
            renderCANVAS: function (ctx) {
            var graphicContext = ctx.getGraphicContext(),
                pathSet = false,
                bounds = this.getBounds(),
                fill = this.getFill();
            if (fill) { // Fill first, then stroke
                var alpha = this.getFillOpacity();
                if (alpha != 1) graphicContext.globalAlpha = alpha;
                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                this.setPath(graphicContext, bounds);
                graphicContext.fill();
                pathSet = true;
            }
            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                // var alpha = this.getStrokeOpacity();
                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                // graphicContext.lineWidth = this.getStrokeWidth();
                // this.drawStrokeOn(graphicContext, bounds, pathSet);
            // }
        },
            renderContext: function () {
            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
            return this._renderContext;
        },
            renderContextDispatch: function (aspect, arg) {
            if (!this._renderContext) this.renderContext();
            // if we cannot lazy initialize the renderContext we just do nothing
            if (!this._renderContext) return undefined;
            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
            if (!renderSpecificAspect) {
                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                return undefined;
            }
            return this[renderSpecificAspect](this._renderContext, arg);
        },
            renderHTML: function (ctx) {
            if (ctx.shapeNode.parentNode) return;
            var child = ctx.morphNode.childNodes[0];
            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
        },
            renderSVG: function (ctx) {
            if (!ctx.shapeNode.parentNode)
                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
        },
            renderUsing: function (renderContext) {
            this.setRenderContext(renderContext);
            this.renderContextDispatch('init');
            this.renderContextDispatch('appendShape');
        },
            setAppearanceStylingMode: function (value) {
            return this.shapeSetter('AppearanceStylingMode', value);
        },
            setAppearanceStylingModeHTML: function (ctx, value) {
            this.setFillHTML(ctx, this.shapeGetter("Fill"));
            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
        },
            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
            setBorderColorHTML: function (ctx, fill) {
            var alpha;
            if (this.getStrokeOpacity() != 1) {
                alpha = this.getStrokeOpacity();
            } else {
                alpha = fill === null ? 0 : fill.a;
            }
            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
        },
            setBorderColorSVG: function () {},
            setBorderHTML: function (ctx, width, fill, opacity) {
            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                ctx.shapeNode.style['border'] = null;
                this.compensateShapeNode(ctx);
            } else {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
            }
        },
            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
            setBorderRadiusHTML: function (ctx, value) {
            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
        },
            setBorderRadiusSVG: function () {},
            setBorderStyle: function (value) {
            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
            return this.shapeSetter('BorderStyle', value);
        },
            setBorderStyleHTML: function (ctx, value) {
            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
        },
            setBorderStyleSVG: function (ctx, value) {
            if (value == 'dashed')
                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
            else if (value == 'dotted')
                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
            else
                ctx.shapeNode.removeAttribute('stroke-dasharray')
        },
            setBorderStylingMode: function (value) {
            return this.shapeSetter('BorderStylingMode', value);
        },
            setBorderStylingModeHTML: function (ctx, value) {
            this.setBorderHTML(
                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
            this.setExtentHTML(ctx, this.getExtent());
        },
            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
            setBorderWidthHTML: function (ctx, width) {
            if (this.getBorderStylingMode()) {
                ctx.shapeNode.style.border = '';
                ctx.shapeNode.style.borderWidth = width+'px';
            } else {
                ctx.shapeNode.style.borderWidth = '';
                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
            }
            this.compensateShapeNode(ctx);
            this.setExtentHTML(ctx, this.getExtent());
            return width;
        },
            setBorderWidthSVG: function (ctx, value) {
            // var node = this.getPathNodeHTML(ctx);
            // node && node.setAttribute('stroke-width', String(value))
        },
            setBounds: function (bounds) {
            this.setPosition(bounds.topLeft());
            this.setExtent(bounds.extent());
            return bounds
        },
            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
            setExtentHTML: function (ctx, value) {
            if (!ctx.shapeNode) return undefined;
            var padding = this.getPadding(),
                paddingWidth = padding.left() + padding.right(),
                paddingHeight = padding.top() + padding.bottom(),
                // HTML isn't using fractions for pixels, rounds internally,
                // this has to be reflected to compensate HTML's box model
                borderWidth = Math.floor(this.getBorderWidth()),
                realExtent = value
                             .addXY(-2 * borderWidth, -2 * borderWidth)
                             .addXY(-paddingWidth, -paddingHeight);
                realExtent = realExtent.maxPt(pt(0,0));
            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
            return realExtent;
        },
            setExtentSVG: function (ctx, value) {
            if (ctx.shapeNode)
                ctx.domInterface.setExtent(ctx.shapeNode, value);
            // update also parents so that shapes is not clipped... really necassary? FIXME
            // if (ctx.morphNode)
                // ctx.domInterface.setExtent(ctx.morphNode, value);
            // if (ctx.morphNode.parentNode.tagName == 'svg')
                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
        },
            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
            setFillHTML: function (ctx, value) {
            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
        },
            setFillOpacity: function (opacity) {
            var fill = this.getFill()
            if (fill && fill.withA)
                this.setFill(fill.withA(opacity))
        },
            setFillSVG: function (ctx, value) {
            if (ctx.shapeNode)
                ctx.domInterface.setFill(ctx.shapeNode, value);
        },
            setNodeClass: function (value) {
            return this.shapeSetter('NodeClass', value);
        },
            setNodeId: function (value) {
            return this.shapeSetter('NodeId', value);
        },
            setNodeIdHTML: function (ctx, id) {
            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
            return id;
        },
            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
            setOpacityHTML: function (ctx, value) {
            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
        },
            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
            setPaddingHTML: function (ctx, r) {
            if (r === undefined || !ctx.shapeNode) return r;
            // Rectangle.inset(left, top, right, bottom) ==>
            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
            ctx.shapeNode.style.padding = s;
            return r;
        },
            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
            graphicContext.beginPath();
            graphicContext.moveTo(bnds.x, bnds.y);
            graphicContext.lineTo(bnds.maxX(), bnds.y);
            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
            graphicContext.lineTo(bnds.x, bnds.maxY());
            graphicContext.closePath();
        },
            setPosition: function (position) { return this.shapeSetter('Position', position) },
            setPositionHTML: function (ctx, value) {
            if (!ctx.shapeNode) return;
            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
            if (ctx.originNode) {
                this.compensateShapeNode(ctx);
            }
        },
            setPositionSVG: function (ctx, value) {
            if (ctx.shapeNode)
                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
        },
            setRenderContext: function (newRenderContext) {
            if (newRenderContext) {
                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                    this, newRenderContext.renderContextTableName);
            }
            this._renderContext = newRenderContext;
        },
            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
            setStrokeOpacityHTML: function (ctx, opacity) {
            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
        },
            setStrokeOpacitySVG: function () {},
            setVertices: function () {
            // This does nothing for non path shapes
        },
            shapeGetter: function (propName) { return this['_' + propName] },
            shapeSetter: function (propName, value) {
            if (value === undefined) {
                delete this['_' + propName];
            } else {
                this['_' + propName] = value;
            }
            return this.renderContextDispatch('set' + propName, value);
        },
            vertices: function () {
            var b = this.bounds();
            return [pt(b.x, b.y), pt(b.width, b.height)]
        }
        },
        sourceModule: "lively.morphic.MorphAddons",
        submorphs: [{
            _BorderColor: Color.rgb(189,190,192),
            _BorderRadius: 5,
            _BorderWidth: 1,
            _Extent: lively.pt(100.0,20.0),
            _Position: lively.pt(508.0,372.0),
            _StyleClassNames: ["Morph","Button"],
            className: "lively.morphic.Button",
            droppingEnabled: false,
            grabbingEnabled: false,
            isPressed: false,
            label: "Button",
            name: "CreationButton",
            pinSpecs: [{
                accessor: "fire",
                location: 1.5,
                modality: "output",
                pinName: "fire",
                type: "Boolean"
            }],
            shape: {
                _BorderColor: Color.rgb(189,190,192),
                _BorderRadius: 5,
                _BorderStyle: "solid",
                _BorderWidth: 1,
                _Extent: lively.pt(100.0,20.0),
                _Fill: null,
                _Opacity: 1,
                _Padding: lively.rect(0,0,0,0),
                _Position: lively.pt(0.0,0.0),
                canvasDispatchTable: {
                    append: "appendCANVAS",
                    appendShape: "renderCANVAS",
                    init: "initCANVAS",
                    remove: "removeCANVAS",
                    setPosition: "attributeChangedCANVAS"
                },
                doNotSerialize: ["_renderContext"],
                htmlDispatchTable: {
                    appendShape: "renderHTML",
                    init: "initHTML",
                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                    setBorderColor: "setBorderColorHTML",
                    setBorderRadius: "setBorderRadiusHTML",
                    setBorderStyle: "setBorderStyleHTML",
                    setBorderStylingMode: "setBorderStylingModeHTML",
                    setBorderWidth: "setBorderWidthHTML",
                    setExtent: "setExtentHTML",
                    setFill: "setFillHTML",
                    setNodeId: "setNodeIdHTML",
                    setOpacity: "setOpacityHTML",
                    setPadding: "setPaddingHTML",
                    setPosition: "setPositionHTML",
                    setStrokeOpacity: "setStrokeOpacityHTML"
                },
                renderContextTableType: "shapeRenderContextTable",
                svgDispatchTable: {
                    appendShape: "renderSVG",
                    init: "initSVG",
                    setBorderColor: "setBorderColorSVG",
                    setBorderRadius: "setBorderRadiusSVG",
                    setBorderStyle: "setBorderStyleSVG",
                    setBorderWidth: "setBorderWidthSVG",
                    setExtent: "setExtentSVG",
                    setFill: "setFillSVG",
                    setPosition: "setPositionSVG",
                    setStrokeOpacity: "setStrokeOpacitySVG"
                },
                attributeChangedCANVAS: function (ctx, value) {
                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                this.renderCANVAS(ctx)
            },
                bounds: function () { return this.getBounds() },
                compensateShapeNode: function (ctx) {
                // compensates the shapeNode's position for childmorphs,
                // positions childmorphs against morphNodes (origin!)
                if (!ctx.originNode) return;
                ctx.originNode.style.setProperty(
                    'top', -this.getPosition().y + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'left', -this.getPosition().x + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'position', 'absolute', 'important');
        
                // FIXME: hack, necessary until the style editor knows
                // about stroke widths of svg lines instead of using borderWidth...
                if (ctx.pathNode) return;
        
                // compensates the shapeNode's borderWidth for childmorphs,
                // borders don't affect submorphs
                ctx.originNode.style.setProperty(
                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'margin-left', -this.getBorderWidth() + 'px', 'important');
            },
                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    }}),
                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                defaultRenderContext: function () { return null },
                getAppearanceStylingMode: function () {
                return this.shapeGetter('AppearanceStylingMode');
            },
                getBorderColor: function () {
                var fill = this.shapeGetter('BorderColor');
                return fill === undefined ? Color.red : fill;
            },
                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                getBorderStylingMode: function () {
                return this.shapeGetter('BorderStylingMode');
            },
                getBorderWidth: function () {
                return this.shapeGetter('BorderWidth')  || 0;
            },
                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                getFill: function () { return this.shapeGetter('Fill') || null },
                getFillOpacity: function () {
                var fill = this.getFill();
                return (fill && typeof fill.a === "number") ? fill.a : 1;
            },
                getNodeClass: function () {
                return this.shapeGetter('NodeClass') || [];
            },
                getNodeId: function () {
                return this.shapeGetter('NodeId')
            },
                getOpacity: function () {
                var op = this.shapeGetter('Opacity');
                return op === undefined ? 1 : Number(op);
            },
                getPadding: function () {
                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
            },
                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                getStrokeOpacity: function () {
                var op = this.shapeGetter('StrokeOpacity');
                return op === undefined ? 1 : op;
            },
                initCANVAS: function () {},
                initHTML: function ($super, ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = ctx.domInterface.htmlRect();
                $super(ctx);
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
            },
                initSVG: function (ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = this.createShapeNode(ctx);
                this.setPositionSVG(ctx, this.getPosition());
                this.setExtentSVG(ctx, this.getExtent());
                this.setFillSVG(ctx, this.getFill());
                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                this.setBorderColorSVG(ctx, this.getBorderColor());
                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
            },
                initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    },
                reallyContainsPoint: function (pt) {
                // Overridden for non-rectangular shapes like lines and ellipses
                // Note assumes that pt is within this.bounds
                return true
            },
                renderCANVAS: function (ctx) {
                var graphicContext = ctx.getGraphicContext(),
                    pathSet = false,
                    bounds = this.getBounds(),
                    fill = this.getFill();
                if (fill) { // Fill first, then stroke
                    var alpha = this.getFillOpacity();
                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                    this.setPath(graphicContext, bounds);
                    graphicContext.fill();
                    pathSet = true;
                }
                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                    // var alpha = this.getStrokeOpacity();
                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                    // graphicContext.lineWidth = this.getStrokeWidth();
                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                // }
            },
                renderContext: function () {
                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                return this._renderContext;
            },
                renderContextDispatch: function (aspect, arg) {
                if (!this._renderContext) this.renderContext();
                // if we cannot lazy initialize the renderContext we just do nothing
                if (!this._renderContext) return undefined;
                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                if (!renderSpecificAspect) {
                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                    return undefined;
                }
                return this[renderSpecificAspect](this._renderContext, arg);
            },
                renderHTML: function (ctx) {
                if (ctx.shapeNode.parentNode) return;
                var child = ctx.morphNode.childNodes[0];
                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
            },
                renderSVG: function (ctx) {
                if (!ctx.shapeNode.parentNode)
                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
            },
                renderUsing: function (renderContext) {
                this.setRenderContext(renderContext);
                this.renderContextDispatch('init');
                this.renderContextDispatch('appendShape');
            },
                setAppearanceStylingMode: function (value) {
                return this.shapeSetter('AppearanceStylingMode', value);
            },
                setAppearanceStylingModeHTML: function (ctx, value) {
                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
            },
                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                setBorderColorHTML: function (ctx, fill) {
                var alpha;
                if (this.getStrokeOpacity() != 1) {
                    alpha = this.getStrokeOpacity();
                } else {
                    alpha = fill === null ? 0 : fill.a;
                }
                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
            },
                setBorderColorSVG: function () {},
                setBorderHTML: function (ctx, width, fill, opacity) {
                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                    ctx.shapeNode.style['border'] = null;
                    this.compensateShapeNode(ctx);
                } else {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                }
            },
                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                setBorderRadiusHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderRadiusSVG: function () {},
                setBorderStyle: function (value) {
                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                return this.shapeSetter('BorderStyle', value);
            },
                setBorderStyleHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderStyleSVG: function (ctx, value) {
                if (value == 'dashed')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                else if (value == 'dotted')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                else
                    ctx.shapeNode.removeAttribute('stroke-dasharray')
            },
                setBorderStylingMode: function (value) {
                return this.shapeSetter('BorderStylingMode', value);
            },
                setBorderStylingModeHTML: function (ctx, value) {
                this.setBorderHTML(
                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                this.setExtentHTML(ctx, this.getExtent());
            },
                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                setBorderWidthHTML: function (ctx, width) {
                if (this.getBorderStylingMode()) {
                    ctx.shapeNode.style.border = '';
                    ctx.shapeNode.style.borderWidth = width+'px';
                } else {
                    ctx.shapeNode.style.borderWidth = '';
                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                }
                this.compensateShapeNode(ctx);
                this.setExtentHTML(ctx, this.getExtent());
                return width;
            },
                setBorderWidthSVG: function (ctx, value) {
                // var node = this.getPathNodeHTML(ctx);
                // node && node.setAttribute('stroke-width', String(value))
            },
                setBounds: function (bounds) {
                this.setPosition(bounds.topLeft());
                this.setExtent(bounds.extent());
                return bounds
            },
                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                setExtentHTML: function (ctx, value) {
                if (!ctx.shapeNode) return undefined;
                var padding = this.getPadding(),
                    paddingWidth = padding.left() + padding.right(),
                    paddingHeight = padding.top() + padding.bottom(),
                    // HTML isn't using fractions for pixels, rounds internally,
                    // this has to be reflected to compensate HTML's box model
                    borderWidth = Math.floor(this.getBorderWidth()),
                    realExtent = value
                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                 .addXY(-paddingWidth, -paddingHeight);
                    realExtent = realExtent.maxPt(pt(0,0));
                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                return realExtent;
            },
                setExtentSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                // update also parents so that shapes is not clipped... really necassary? FIXME
                // if (ctx.morphNode)
                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                // if (ctx.morphNode.parentNode.tagName == 'svg')
                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
            },
                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                setFillHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setFillOpacity: function (opacity) {
                var fill = this.getFill()
                if (fill && fill.withA)
                    this.setFill(fill.withA(opacity))
            },
                setFillSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setFill(ctx.shapeNode, value);
            },
                setNodeClass: function (value) {
                return this.shapeSetter('NodeClass', value);
            },
                setNodeId: function (value) {
                return this.shapeSetter('NodeId', value);
            },
                setNodeIdHTML: function (ctx, id) {
                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                return id;
            },
                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                setOpacityHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                setPaddingHTML: function (ctx, r) {
                if (r === undefined || !ctx.shapeNode) return r;
                // Rectangle.inset(left, top, right, bottom) ==>
                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                ctx.shapeNode.style.padding = s;
                return r;
            },
                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                graphicContext.beginPath();
                graphicContext.moveTo(bnds.x, bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                graphicContext.lineTo(bnds.x, bnds.maxY());
                graphicContext.closePath();
            },
                setPosition: function (position) { return this.shapeSetter('Position', position) },
                setPositionHTML: function (ctx, value) {
                if (!ctx.shapeNode) return;
                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                if (ctx.originNode) {
                    this.compensateShapeNode(ctx);
                }
            },
                setPositionSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
            },
                setRenderContext: function (newRenderContext) {
                if (newRenderContext) {
                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                        this, newRenderContext.renderContextTableName);
                }
                this._renderContext = newRenderContext;
            },
                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                setStrokeOpacityHTML: function (ctx, opacity) {
                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
            },
                setStrokeOpacitySVG: function () {},
                setVertices: function () {
                // This does nothing for non path shapes
            },
                shapeGetter: function (propName) { return this['_' + propName] },
                shapeSetter: function (propName, value) {
                if (value === undefined) {
                    delete this['_' + propName];
                } else {
                    this['_' + propName] = value;
                }
                return this.renderContextDispatch('set' + propName, value);
            },
                vertices: function () {
                var b = this.bounds();
                return [pt(b.x, b.y), pt(b.width, b.height)]
            }
            },
            sourceModule: "lively.morphic.Widgets",
            toggle: false,
            value: false,
            connectionRebuilder: function connectionRebuilder() {
            lively.bindings.connect(this, "fire", this, "doAction", {});
            lively.bindings.connect(this, "fire", this.get("Entanglement Inspector"), "createEntangledObj", {});
        },
            doAction: function doAction() {
                    
                }
        },{
            _BorderColor: Color.rgb(230,230,230),
            _BorderStyle: "outset",
            _BorderWidth: 1,
            _ClipMode: {
                x: "hidden",
                y: "scroll"
            },
            _Extent: lively.pt(169.0,348.0),
            _Fill: Color.rgb(255,255,255),
            _Position: lively.pt(440.0,15.0),
            allowDeselectClick: false,
            className: "lively.morphic.List",
            droppingEnabled: true,
            isMultipleSelectionList: false,
            itemList: "[<lively.morphic.Path#3109E... - Triangle>]",
            itemMorphs: [],
            layout: {
                adjustForNewBounds: true,
                extent: lively.pt(169.0,348.0),
                listItemHeight: 19,
                maxExtent: lively.pt(169.0,348.0),
                maxListItems: 19,
                noOfCandidatesShown: 2,
                padding: 0,
                scaleHorizontal: true,
                scaleVertical: true
            },
            multipleSelectionMode: "none",
            name: "EntangledMorphsList",
            noSingleSelectionIfMultipleSelected: false,
            plug: {
                menuItems: "output",
                selection: "output",
                setList: "input"
            },
            shape: {
                _BorderColor: Color.rgb(230,230,230),
                _BorderStyle: "outset",
                _BorderWidth: 1,
                _Extent: lively.pt(169.0,348.0),
                _Fill: Color.rgb(255,255,255),
                _Padding: lively.rect(0,0,0,0),
                _Position: lively.pt(0.0,0.0),
                canvasDispatchTable: {
                    append: "appendCANVAS",
                    appendShape: "renderCANVAS",
                    init: "initCANVAS",
                    remove: "removeCANVAS",
                    setPosition: "attributeChangedCANVAS"
                },
                doNotSerialize: ["_renderContext"],
                htmlDispatchTable: {
                    appendShape: "renderHTML",
                    init: "initHTML",
                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                    setBorderColor: "setBorderColorHTML",
                    setBorderRadius: "setBorderRadiusHTML",
                    setBorderStyle: "setBorderStyleHTML",
                    setBorderStylingMode: "setBorderStylingModeHTML",
                    setBorderWidth: "setBorderWidthHTML",
                    setExtent: "setExtentHTML",
                    setFill: "setFillHTML",
                    setNodeId: "setNodeIdHTML",
                    setOpacity: "setOpacityHTML",
                    setPadding: "setPaddingHTML",
                    setPosition: "setPositionHTML",
                    setStrokeOpacity: "setStrokeOpacityHTML"
                },
                renderContextTableType: "shapeRenderContextTable",
                svgDispatchTable: {
                    appendShape: "renderSVG",
                    init: "initSVG",
                    setBorderColor: "setBorderColorSVG",
                    setBorderRadius: "setBorderRadiusSVG",
                    setBorderStyle: "setBorderStyleSVG",
                    setBorderWidth: "setBorderWidthSVG",
                    setExtent: "setExtentSVG",
                    setFill: "setFillSVG",
                    setPosition: "setPositionSVG",
                    setStrokeOpacity: "setStrokeOpacitySVG"
                },
                attributeChangedCANVAS: function (ctx, value) {
                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                this.renderCANVAS(ctx)
            },
                bounds: function () { return this.getBounds() },
                compensateShapeNode: function (ctx) {
                // compensates the shapeNode's position for childmorphs,
                // positions childmorphs against morphNodes (origin!)
                if (!ctx.originNode) return;
                ctx.originNode.style.setProperty(
                    'top', -this.getPosition().y + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'left', -this.getPosition().x + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'position', 'absolute', 'important');
        
                // FIXME: hack, necessary until the style editor knows
                // about stroke widths of svg lines instead of using borderWidth...
                if (ctx.pathNode) return;
        
                // compensates the shapeNode's borderWidth for childmorphs,
                // borders don't affect submorphs
                ctx.originNode.style.setProperty(
                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'margin-left', -this.getBorderWidth() + 'px', 'important');
            },
                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    }}),
                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                defaultRenderContext: function () { return null },
                getAppearanceStylingMode: function () {
                return this.shapeGetter('AppearanceStylingMode');
            },
                getBorderColor: function () {
                var fill = this.shapeGetter('BorderColor');
                return fill === undefined ? Color.red : fill;
            },
                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                getBorderStylingMode: function () {
                return this.shapeGetter('BorderStylingMode');
            },
                getBorderWidth: function () {
                return this.shapeGetter('BorderWidth')  || 0;
            },
                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                getFill: function () { return this.shapeGetter('Fill') || null },
                getFillOpacity: function () {
                var fill = this.getFill();
                return (fill && typeof fill.a === "number") ? fill.a : 1;
            },
                getNodeClass: function () {
                return this.shapeGetter('NodeClass') || [];
            },
                getNodeId: function () {
                return this.shapeGetter('NodeId')
            },
                getOpacity: function () {
                var op = this.shapeGetter('Opacity');
                return op === undefined ? 1 : Number(op);
            },
                getPadding: function () {
                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
            },
                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                getStrokeOpacity: function () {
                var op = this.shapeGetter('StrokeOpacity');
                return op === undefined ? 1 : op;
            },
                initCANVAS: function () {},
                initHTML: function ($super, ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = ctx.domInterface.htmlRect();
                $super(ctx);
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
            },
                initSVG: function (ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = this.createShapeNode(ctx);
                this.setPositionSVG(ctx, this.getPosition());
                this.setExtentSVG(ctx, this.getExtent());
                this.setFillSVG(ctx, this.getFill());
                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                this.setBorderColorSVG(ctx, this.getBorderColor());
                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
            },
                initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    },
                reallyContainsPoint: function (pt) {
                // Overridden for non-rectangular shapes like lines and ellipses
                // Note assumes that pt is within this.bounds
                return true
            },
                renderCANVAS: function (ctx) {
                var graphicContext = ctx.getGraphicContext(),
                    pathSet = false,
                    bounds = this.getBounds(),
                    fill = this.getFill();
                if (fill) { // Fill first, then stroke
                    var alpha = this.getFillOpacity();
                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                    this.setPath(graphicContext, bounds);
                    graphicContext.fill();
                    pathSet = true;
                }
                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                    // var alpha = this.getStrokeOpacity();
                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                    // graphicContext.lineWidth = this.getStrokeWidth();
                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                // }
            },
                renderContext: function () {
                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                return this._renderContext;
            },
                renderContextDispatch: function (aspect, arg) {
                if (!this._renderContext) this.renderContext();
                // if we cannot lazy initialize the renderContext we just do nothing
                if (!this._renderContext) return undefined;
                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                if (!renderSpecificAspect) {
                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                    return undefined;
                }
                return this[renderSpecificAspect](this._renderContext, arg);
            },
                renderHTML: function (ctx) {
                if (ctx.shapeNode.parentNode) return;
                var child = ctx.morphNode.childNodes[0];
                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
            },
                renderSVG: function (ctx) {
                if (!ctx.shapeNode.parentNode)
                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
            },
                renderUsing: function (renderContext) {
                this.setRenderContext(renderContext);
                this.renderContextDispatch('init');
                this.renderContextDispatch('appendShape');
            },
                setAppearanceStylingMode: function (value) {
                return this.shapeSetter('AppearanceStylingMode', value);
            },
                setAppearanceStylingModeHTML: function (ctx, value) {
                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
            },
                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                setBorderColorHTML: function (ctx, fill) {
                var alpha;
                if (this.getStrokeOpacity() != 1) {
                    alpha = this.getStrokeOpacity();
                } else {
                    alpha = fill === null ? 0 : fill.a;
                }
                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
            },
                setBorderColorSVG: function () {},
                setBorderHTML: function (ctx, width, fill, opacity) {
                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                    ctx.shapeNode.style['border'] = null;
                    this.compensateShapeNode(ctx);
                } else {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                }
            },
                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                setBorderRadiusHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderRadiusSVG: function () {},
                setBorderStyle: function (value) {
                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                return this.shapeSetter('BorderStyle', value);
            },
                setBorderStyleHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderStyleSVG: function (ctx, value) {
                if (value == 'dashed')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                else if (value == 'dotted')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                else
                    ctx.shapeNode.removeAttribute('stroke-dasharray')
            },
                setBorderStylingMode: function (value) {
                return this.shapeSetter('BorderStylingMode', value);
            },
                setBorderStylingModeHTML: function (ctx, value) {
                this.setBorderHTML(
                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                this.setExtentHTML(ctx, this.getExtent());
            },
                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                setBorderWidthHTML: function (ctx, width) {
                if (this.getBorderStylingMode()) {
                    ctx.shapeNode.style.border = '';
                    ctx.shapeNode.style.borderWidth = width+'px';
                } else {
                    ctx.shapeNode.style.borderWidth = '';
                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                }
                this.compensateShapeNode(ctx);
                this.setExtentHTML(ctx, this.getExtent());
                return width;
            },
                setBorderWidthSVG: function (ctx, value) {
                // var node = this.getPathNodeHTML(ctx);
                // node && node.setAttribute('stroke-width', String(value))
            },
                setBounds: function (bounds) {
                this.setPosition(bounds.topLeft());
                this.setExtent(bounds.extent());
                return bounds
            },
                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                setExtentHTML: function (ctx, value) {
                if (!ctx.shapeNode) return undefined;
                var padding = this.getPadding(),
                    paddingWidth = padding.left() + padding.right(),
                    paddingHeight = padding.top() + padding.bottom(),
                    // HTML isn't using fractions for pixels, rounds internally,
                    // this has to be reflected to compensate HTML's box model
                    borderWidth = Math.floor(this.getBorderWidth()),
                    realExtent = value
                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                 .addXY(-paddingWidth, -paddingHeight);
                    realExtent = realExtent.maxPt(pt(0,0));
                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                return realExtent;
            },
                setExtentSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                // update also parents so that shapes is not clipped... really necassary? FIXME
                // if (ctx.morphNode)
                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                // if (ctx.morphNode.parentNode.tagName == 'svg')
                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
            },
                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                setFillHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setFillOpacity: function (opacity) {
                var fill = this.getFill()
                if (fill && fill.withA)
                    this.setFill(fill.withA(opacity))
            },
                setFillSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setFill(ctx.shapeNode, value);
            },
                setNodeClass: function (value) {
                return this.shapeSetter('NodeClass', value);
            },
                setNodeId: function (value) {
                return this.shapeSetter('NodeId', value);
            },
                setNodeIdHTML: function (ctx, id) {
                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                return id;
            },
                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                setOpacityHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                setPaddingHTML: function (ctx, r) {
                if (r === undefined || !ctx.shapeNode) return r;
                // Rectangle.inset(left, top, right, bottom) ==>
                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                ctx.shapeNode.style.padding = s;
                return r;
            },
                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                graphicContext.beginPath();
                graphicContext.moveTo(bnds.x, bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                graphicContext.lineTo(bnds.x, bnds.maxY());
                graphicContext.closePath();
            },
                setPosition: function (position) { return this.shapeSetter('Position', position) },
                setPositionHTML: function (ctx, value) {
                if (!ctx.shapeNode) return;
                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                if (ctx.originNode) {
                    this.compensateShapeNode(ctx);
                }
            },
                setPositionSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
            },
                setRenderContext: function (newRenderContext) {
                if (newRenderContext) {
                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                        this, newRenderContext.renderContextTableName);
                }
                this._renderContext = newRenderContext;
            },
                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                setStrokeOpacityHTML: function (ctx, opacity) {
                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
            },
                setStrokeOpacitySVG: function () {},
                setVertices: function () {
                // This does nothing for non path shapes
            },
                shapeGetter: function (propName) { return this['_' + propName] },
                shapeSetter: function (propName, value) {
                if (value === undefined) {
                    delete this['_' + propName];
                } else {
                    this['_' + propName] = value;
                }
                return this.renderContextDispatch('set' + propName, value);
            },
                vertices: function () {
                var b = this.bounds();
                return [pt(b.x, b.y), pt(b.width, b.height)]
            }
            },
            sourceModule: "lively.morphic.Lists",
            submorphs: [{
                _BorderColor: null,
                _Extent: lively.pt(169.0,23.0),
                className: "lively.morphic.Box",
                droppingEnabled: true,
                halosEnabled: false,
                layout: {
                    adjustForNewBounds: true,
                    resizeWidth: true
                },
                shape: {
                    _BorderColor: null,
                    _BorderWidth: 0,
                    _Extent: lively.pt(169.0,23.0),
                    _Fill: null,
                    _Padding: lively.rect(0,0,0,0),
                    _Position: lively.pt(0.0,0.0),
                    canvasDispatchTable: {
                        append: "appendCANVAS",
                        appendShape: "renderCANVAS",
                        init: "initCANVAS",
                        remove: "removeCANVAS",
                        setPosition: "attributeChangedCANVAS"
                    },
                    doNotSerialize: ["_renderContext"],
                    htmlDispatchTable: {
                        appendShape: "renderHTML",
                        init: "initHTML",
                        setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                        setBorderColor: "setBorderColorHTML",
                        setBorderRadius: "setBorderRadiusHTML",
                        setBorderStyle: "setBorderStyleHTML",
                        setBorderStylingMode: "setBorderStylingModeHTML",
                        setBorderWidth: "setBorderWidthHTML",
                        setExtent: "setExtentHTML",
                        setFill: "setFillHTML",
                        setNodeId: "setNodeIdHTML",
                        setOpacity: "setOpacityHTML",
                        setPadding: "setPaddingHTML",
                        setPosition: "setPositionHTML",
                        setStrokeOpacity: "setStrokeOpacityHTML"
                    },
                    renderContextTableType: "shapeRenderContextTable",
                    svgDispatchTable: {
                        appendShape: "renderSVG",
                        init: "initSVG",
                        setBorderColor: "setBorderColorSVG",
                        setBorderRadius: "setBorderRadiusSVG",
                        setBorderStyle: "setBorderStyleSVG",
                        setBorderWidth: "setBorderWidthSVG",
                        setExtent: "setExtentSVG",
                        setFill: "setFillSVG",
                        setPosition: "setPositionSVG",
                        setStrokeOpacity: "setStrokeOpacitySVG"
                    },
                    attributeChangedCANVAS: function (ctx, value) {
                    ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                    this.renderCANVAS(ctx)
                },
                    bounds: function () { return this.getBounds() },
                    compensateShapeNode: function (ctx) {
                    // compensates the shapeNode's position for childmorphs,
                    // positions childmorphs against morphNodes (origin!)
                    if (!ctx.originNode) return;
                    ctx.originNode.style.setProperty(
                        'top', -this.getPosition().y + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'left', -this.getPosition().x + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'position', 'absolute', 'important');
            
                    // FIXME: hack, necessary until the style editor knows
                    // about stroke widths of svg lines instead of using borderWidth...
                    if (ctx.pathNode) return;
            
                    // compensates the shapeNode's borderWidth for childmorphs,
                    // borders don't affect submorphs
                    ctx.originNode.style.setProperty(
                        'margin-top', -this.getBorderWidth() + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'margin-left', -this.getBorderWidth() + 'px', 'important');
                },
                    constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                            if (bounds) this.setBounds(bounds);
                                        }}),
                    createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                    defaultRenderContext: function () { return null },
                    getAppearanceStylingMode: function () {
                    return this.shapeGetter('AppearanceStylingMode');
                },
                    getBorderColor: function () {
                    var fill = this.shapeGetter('BorderColor');
                    return fill === undefined ? Color.red : fill;
                },
                    getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                    getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                    getBorderStylingMode: function () {
                    return this.shapeGetter('BorderStylingMode');
                },
                    getBorderWidth: function () {
                    return this.shapeGetter('BorderWidth')  || 0;
                },
                    getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                    getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                    getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                    getFill: function () { return this.shapeGetter('Fill') || null },
                    getFillOpacity: function () {
                    var fill = this.getFill();
                    return (fill && typeof fill.a === "number") ? fill.a : 1;
                },
                    getNodeClass: function () {
                    return this.shapeGetter('NodeClass') || [];
                },
                    getNodeId: function () {
                    return this.shapeGetter('NodeId')
                },
                    getOpacity: function () {
                    var op = this.shapeGetter('Opacity');
                    return op === undefined ? 1 : Number(op);
                },
                    getPadding: function () {
                    return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                },
                    getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                    getStrokeOpacity: function () {
                    var op = this.shapeGetter('StrokeOpacity');
                    return op === undefined ? 1 : op;
                },
                    initCANVAS: function () {},
                    initHTML: function ($super, ctx) {
                    if (!ctx.shapeNode)
                        ctx.shapeNode = ctx.domInterface.htmlRect();
                    $super(ctx);
                    this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                },
                    initSVG: function (ctx) {
                    if (!ctx.shapeNode)
                        ctx.shapeNode = this.createShapeNode(ctx);
                    this.setPositionSVG(ctx, this.getPosition());
                    this.setExtentSVG(ctx, this.getExtent());
                    this.setFillSVG(ctx, this.getFill());
                    this.setBorderWidthSVG(ctx, this.getBorderWidth());
                    this.setBorderColorSVG(ctx, this.getBorderColor());
                    this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                },
                    initialize: function (bounds) {
                                            if (bounds) this.setBounds(bounds);
                                        },
                    reallyContainsPoint: function (pt) {
                    // Overridden for non-rectangular shapes like lines and ellipses
                    // Note assumes that pt is within this.bounds
                    return true
                },
                    renderCANVAS: function (ctx) {
                    var graphicContext = ctx.getGraphicContext(),
                        pathSet = false,
                        bounds = this.getBounds(),
                        fill = this.getFill();
                    if (fill) { // Fill first, then stroke
                        var alpha = this.getFillOpacity();
                        if (alpha != 1) graphicContext.globalAlpha = alpha;
                        graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                        this.setPath(graphicContext, bounds);
                        graphicContext.fill();
                        pathSet = true;
                    }
                    // if (this.getStroke() && this.getStrokeWidth() > 0) {
                        // var alpha = this.getStrokeOpacity();
                        // if (alpha != 1) graphicContext.globalAlpha = alpha;
                        // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                        // graphicContext.lineWidth = this.getStrokeWidth();
                        // this.drawStrokeOn(graphicContext, bounds, pathSet);
                    // }
                },
                    renderContext: function () {
                    if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                    return this._renderContext;
                },
                    renderContextDispatch: function (aspect, arg) {
                    if (!this._renderContext) this.renderContext();
                    // if we cannot lazy initialize the renderContext we just do nothing
                    if (!this._renderContext) return undefined;
                    var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                    if (!renderSpecificAspect) {
                        dbgOn(true, 'renderContextTable does no include: ' + aspect);
                        return undefined;
                    }
                    return this[renderSpecificAspect](this._renderContext, arg);
                },
                    renderHTML: function (ctx) {
                    if (ctx.shapeNode.parentNode) return;
                    var child = ctx.morphNode.childNodes[0];
                    if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                    else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                },
                    renderSVG: function (ctx) {
                    if (!ctx.shapeNode.parentNode)
                        ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                },
                    renderUsing: function (renderContext) {
                    this.setRenderContext(renderContext);
                    this.renderContextDispatch('init');
                    this.renderContextDispatch('appendShape');
                },
                    setAppearanceStylingMode: function (value) {
                    return this.shapeSetter('AppearanceStylingMode', value);
                },
                    setAppearanceStylingModeHTML: function (ctx, value) {
                    this.setFillHTML(ctx, this.shapeGetter("Fill"));
                    this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                },
                    setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                    setBorderColorHTML: function (ctx, fill) {
                    var alpha;
                    if (this.getStrokeOpacity() != 1) {
                        alpha = this.getStrokeOpacity();
                    } else {
                        alpha = fill === null ? 0 : fill.a;
                    }
                    return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                },
                    setBorderColorSVG: function () {},
                    setBorderHTML: function (ctx, width, fill, opacity) {
                    if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                        ctx.shapeNode.style['border'] = null;
                        this.compensateShapeNode(ctx);
                    } else {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                    }
                },
                    setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                    setBorderRadiusHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                },
                    setBorderRadiusSVG: function () {},
                    setBorderStyle: function (value) {
                    // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                    return this.shapeSetter('BorderStyle', value);
                },
                    setBorderStyleHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                },
                    setBorderStyleSVG: function (ctx, value) {
                    if (value == 'dashed')
                        ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                    else if (value == 'dotted')
                        ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                    else
                        ctx.shapeNode.removeAttribute('stroke-dasharray')
                },
                    setBorderStylingMode: function (value) {
                    return this.shapeSetter('BorderStylingMode', value);
                },
                    setBorderStylingModeHTML: function (ctx, value) {
                    this.setBorderHTML(
                        ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                    this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    this.setExtentHTML(ctx, this.getExtent());
                },
                    setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                    setBorderWidthHTML: function (ctx, width) {
                    if (this.getBorderStylingMode()) {
                        ctx.shapeNode.style.border = '';
                        ctx.shapeNode.style.borderWidth = width+'px';
                    } else {
                        ctx.shapeNode.style.borderWidth = '';
                        this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                    }
                    this.compensateShapeNode(ctx);
                    this.setExtentHTML(ctx, this.getExtent());
                    return width;
                },
                    setBorderWidthSVG: function (ctx, value) {
                    // var node = this.getPathNodeHTML(ctx);
                    // node && node.setAttribute('stroke-width', String(value))
                },
                    setBounds: function (bounds) {
                    this.setPosition(bounds.topLeft());
                    this.setExtent(bounds.extent());
                    return bounds
                },
                    setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                    setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                    setExtentHTML: function (ctx, value) {
                    if (!ctx.shapeNode) return undefined;
                    var padding = this.getPadding(),
                        paddingWidth = padding.left() + padding.right(),
                        paddingHeight = padding.top() + padding.bottom(),
                        // HTML isn't using fractions for pixels, rounds internally,
                        // this has to be reflected to compensate HTML's box model
                        borderWidth = Math.floor(this.getBorderWidth()),
                        realExtent = value
                                     .addXY(-2 * borderWidth, -2 * borderWidth)
                                     .addXY(-paddingWidth, -paddingHeight);
                        realExtent = realExtent.maxPt(pt(0,0));
                    ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                    return realExtent;
                },
                    setExtentSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setExtent(ctx.shapeNode, value);
                    // update also parents so that shapes is not clipped... really necassary? FIXME
                    // if (ctx.morphNode)
                        // ctx.domInterface.setExtent(ctx.morphNode, value);
                    // if (ctx.morphNode.parentNode.tagName == 'svg')
                        // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                },
                    setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                    setFillHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                },
                    setFillOpacity: function (opacity) {
                    var fill = this.getFill()
                    if (fill && fill.withA)
                        this.setFill(fill.withA(opacity))
                },
                    setFillSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setFill(ctx.shapeNode, value);
                },
                    setNodeClass: function (value) {
                    return this.shapeSetter('NodeClass', value);
                },
                    setNodeId: function (value) {
                    return this.shapeSetter('NodeId', value);
                },
                    setNodeIdHTML: function (ctx, id) {
                    ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                    return id;
                },
                    setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                    setOpacityHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                },
                    setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                    setPaddingHTML: function (ctx, r) {
                    if (r === undefined || !ctx.shapeNode) return r;
                    // Rectangle.inset(left, top, right, bottom) ==>
                    // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                    var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                    ctx.shapeNode.style.padding = s;
                    return r;
                },
                    setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                    graphicContext.beginPath();
                    graphicContext.moveTo(bnds.x, bnds.y);
                    graphicContext.lineTo(bnds.maxX(), bnds.y);
                    graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                    graphicContext.lineTo(bnds.x, bnds.maxY());
                    graphicContext.closePath();
                },
                    setPosition: function (position) { return this.shapeSetter('Position', position) },
                    setPositionHTML: function (ctx, value) {
                    if (!ctx.shapeNode) return;
                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    if (ctx.originNode) {
                        this.compensateShapeNode(ctx);
                    }
                },
                    setPositionSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                },
                    setRenderContext: function (newRenderContext) {
                    if (newRenderContext) {
                        newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                            this, newRenderContext.renderContextTableName);
                    }
                    this._renderContext = newRenderContext;
                },
                    setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                    setStrokeOpacityHTML: function (ctx, opacity) {
                    return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                },
                    setStrokeOpacitySVG: function () {},
                    setVertices: function () {
                    // This does nothing for non path shapes
                },
                    shapeGetter: function (propName) { return this['_' + propName] },
                    shapeSetter: function (propName, value) {
                    if (value === undefined) {
                        delete this['_' + propName];
                    } else {
                        this['_' + propName] = value;
                    }
                    return this.renderContextDispatch('set' + propName, value);
                },
                    vertices: function () {
                    var b = this.bounds();
                    return [pt(b.x, b.y), pt(b.width, b.height)]
                }
                },
                sourceModule: "lively.morphic.Core",
                submorphs: [{
                    _ClipMode: "hidden",
                    _Extent: lively.pt(249.0,19.0),
                    _FontFamily: "Helvetica",
                    _HandStyle: "default",
                    _InputAllowed: false,
                    _PointerEvents: "auto",
                    _StyleClassNames: ["Morph","Text","list-item"],
                    _TextColor: Color.rgb(64,64,64),
                    _TextStylingMode: true,
                    _WhiteSpaceHandling: "pre",
                    allowInput: false,
                    className: "lively.morphic.Text",
                    draggingEnabled: true,
                    droppingEnabled: false,
                    emphasis: [[0,41,{}]],
                    evalEnabled: false,
                    eventsAreIgnored: false,
                    fixedHeight: true,
                    grabbingEnabled: false,
                    halosEnabled: false,
                    index: 0,
                    isLabel: true,
                    isListItemMorph: true,
                    layout: {
                        resizeWidth: true
                    },
                    name: "0",
                    selected: false,
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(249.0,19.0),
                        _Fill: null,
                        _Padding: lively.rect(4,2,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.TextCore",
                    textString: "<lively.morphic.Path#3109E... - Triangle>",
                    connectionRebuilder: function connectionRebuilder() {
                    lively.bindings.connect(this, "selected", this.get("EntangledMorphsList"), "selectionChanged", {updater: 
                function ($upd, selected) { $upd(this.sourceObj.index, selected); }});
                },
                    onMouseDown: function onMouseDown(evt) {
                        // NOTE! This method is attached to all the list item morphs, so this
                        // in here is NOT the list but each individual list item morph
                        var list = this.owner.owner, // FIXME
                            isMultiSelect = !!list.isMultipleSelectionList;
                        if (!isMultiSelect) {
                            this.setIsSelected(list.allowDeselectClick ? !this.selected : true);
                        } else {
                            var multiSelectWithShift = list.multipleSelectionMode === 'multiSelectWithShift',
                                hasSelection = !!list.selection,
                                shiftPressed = evt.isShiftDown();
                            if (multiSelectWithShift && !shiftPressed) {
                                var selected = this.selected;
                                list.deselectAll();
                                this.setIsSelected(!selected || !list.allowDeselectClick);
                            } else {
                                this.setIsSelected(!this.selected);
                            }
                        }
                        evt.stop(); return true;
                    },
                    setIsSelected: function setIsSelected(bool, suppressUpdate) {
                            if (!bool && this.selected) {
                                this.removeStyleClassName('selected');
                            } else if (bool && !this.selected){
                                this.addStyleClassName('selected');
                            }
                            var self = this;
                            function setState() { self.selected = bool; }
                            if (suppressUpdate) lively.bindings.noUpdate(setState); else setState();
                        }
                }]
            }],
            connectionRebuilder: function connectionRebuilder() {
            lively.bindings.connect(this, "selection", this.owner, "entangledMorphsListSelection", {});
            lively.bindings.connect(this, "menuItems", this.owner, "entangledMorphsListMenuItems", {});
        }
        },{
            _BorderColor: Color.rgb(255,255,255),
            _BorderWidth: 1,
            _ClipMode: "scroll",
            _Extent: lively.pt(417.0,347.0),
            _Fill: Color.rgb(255,255,255),
            _Position: lively.pt(16.0,15.0),
            className: "lively.morphic.Box",
            droppingEnabled: true,
            name: "EntanglementVisualizer1",
            shape: {
                _BorderColor: Color.rgb(255,255,255),
                _BorderRadius: 0,
                _BorderStyle: "solid",
                _BorderWidth: 1,
                _Extent: lively.pt(417.0,347.0),
                _Fill: Color.rgb(255,255,255),
                _Opacity: 1,
                _Padding: lively.rect(0,0,0,0),
                _Position: lively.pt(0.0,0.0),
                canvasDispatchTable: {
                    append: "appendCANVAS",
                    appendShape: "renderCANVAS",
                    init: "initCANVAS",
                    remove: "removeCANVAS",
                    setPosition: "attributeChangedCANVAS"
                },
                doNotSerialize: ["_renderContext"],
                htmlDispatchTable: {
                    appendShape: "renderHTML",
                    init: "initHTML",
                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                    setBorderColor: "setBorderColorHTML",
                    setBorderRadius: "setBorderRadiusHTML",
                    setBorderStyle: "setBorderStyleHTML",
                    setBorderStylingMode: "setBorderStylingModeHTML",
                    setBorderWidth: "setBorderWidthHTML",
                    setExtent: "setExtentHTML",
                    setFill: "setFillHTML",
                    setNodeId: "setNodeIdHTML",
                    setOpacity: "setOpacityHTML",
                    setPadding: "setPaddingHTML",
                    setPosition: "setPositionHTML",
                    setStrokeOpacity: "setStrokeOpacityHTML"
                },
                renderContextTableType: "shapeRenderContextTable",
                svgDispatchTable: {
                    appendShape: "renderSVG",
                    init: "initSVG",
                    setBorderColor: "setBorderColorSVG",
                    setBorderRadius: "setBorderRadiusSVG",
                    setBorderStyle: "setBorderStyleSVG",
                    setBorderWidth: "setBorderWidthSVG",
                    setExtent: "setExtentSVG",
                    setFill: "setFillSVG",
                    setPosition: "setPositionSVG",
                    setStrokeOpacity: "setStrokeOpacitySVG"
                },
                attributeChangedCANVAS: function (ctx, value) {
                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                this.renderCANVAS(ctx)
            },
                bounds: function () { return this.getBounds() },
                compensateShapeNode: function (ctx) {
                // compensates the shapeNode's position for childmorphs,
                // positions childmorphs against morphNodes (origin!)
                if (!ctx.originNode) return;
                ctx.originNode.style.setProperty(
                    'top', -this.getPosition().y + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'left', -this.getPosition().x + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'position', 'absolute', 'important');
        
                // FIXME: hack, necessary until the style editor knows
                // about stroke widths of svg lines instead of using borderWidth...
                if (ctx.pathNode) return;
        
                // compensates the shapeNode's borderWidth for childmorphs,
                // borders don't affect submorphs
                ctx.originNode.style.setProperty(
                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                ctx.originNode.style.setProperty(
                    'margin-left', -this.getBorderWidth() + 'px', 'important');
            },
                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    }}),
                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                defaultRenderContext: function () { return null },
                getAppearanceStylingMode: function () {
                return this.shapeGetter('AppearanceStylingMode');
            },
                getBorderColor: function () {
                var fill = this.shapeGetter('BorderColor');
                return fill === undefined ? Color.red : fill;
            },
                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                getBorderStylingMode: function () {
                return this.shapeGetter('BorderStylingMode');
            },
                getBorderWidth: function () {
                return this.shapeGetter('BorderWidth')  || 0;
            },
                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                getFill: function () { return this.shapeGetter('Fill') || null },
                getFillOpacity: function () {
                var fill = this.getFill();
                return (fill && typeof fill.a === "number") ? fill.a : 1;
            },
                getNodeClass: function () {
                return this.shapeGetter('NodeClass') || [];
            },
                getNodeId: function () {
                return this.shapeGetter('NodeId')
            },
                getOpacity: function () {
                var op = this.shapeGetter('Opacity');
                return op === undefined ? 1 : Number(op);
            },
                getPadding: function () {
                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
            },
                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                getStrokeOpacity: function () {
                var op = this.shapeGetter('StrokeOpacity');
                return op === undefined ? 1 : op;
            },
                initCANVAS: function () {},
                initHTML: function ($super, ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = ctx.domInterface.htmlRect();
                $super(ctx);
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
            },
                initSVG: function (ctx) {
                if (!ctx.shapeNode)
                    ctx.shapeNode = this.createShapeNode(ctx);
                this.setPositionSVG(ctx, this.getPosition());
                this.setExtentSVG(ctx, this.getExtent());
                this.setFillSVG(ctx, this.getFill());
                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                this.setBorderColorSVG(ctx, this.getBorderColor());
                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
            },
                initialize: function (bounds) {
                                        if (bounds) this.setBounds(bounds);
                                    },
                reallyContainsPoint: function (pt) {
                // Overridden for non-rectangular shapes like lines and ellipses
                // Note assumes that pt is within this.bounds
                return true
            },
                renderCANVAS: function (ctx) {
                var graphicContext = ctx.getGraphicContext(),
                    pathSet = false,
                    bounds = this.getBounds(),
                    fill = this.getFill();
                if (fill) { // Fill first, then stroke
                    var alpha = this.getFillOpacity();
                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                    this.setPath(graphicContext, bounds);
                    graphicContext.fill();
                    pathSet = true;
                }
                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                    // var alpha = this.getStrokeOpacity();
                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                    // graphicContext.lineWidth = this.getStrokeWidth();
                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                // }
            },
                renderContext: function () {
                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                return this._renderContext;
            },
                renderContextDispatch: function (aspect, arg) {
                if (!this._renderContext) this.renderContext();
                // if we cannot lazy initialize the renderContext we just do nothing
                if (!this._renderContext) return undefined;
                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                if (!renderSpecificAspect) {
                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                    return undefined;
                }
                return this[renderSpecificAspect](this._renderContext, arg);
            },
                renderHTML: function (ctx) {
                if (ctx.shapeNode.parentNode) return;
                var child = ctx.morphNode.childNodes[0];
                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
            },
                renderSVG: function (ctx) {
                if (!ctx.shapeNode.parentNode)
                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
            },
                renderUsing: function (renderContext) {
                this.setRenderContext(renderContext);
                this.renderContextDispatch('init');
                this.renderContextDispatch('appendShape');
            },
                setAppearanceStylingMode: function (value) {
                return this.shapeSetter('AppearanceStylingMode', value);
            },
                setAppearanceStylingModeHTML: function (ctx, value) {
                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
            },
                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                setBorderColorHTML: function (ctx, fill) {
                var alpha;
                if (this.getStrokeOpacity() != 1) {
                    alpha = this.getStrokeOpacity();
                } else {
                    alpha = fill === null ? 0 : fill.a;
                }
                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
            },
                setBorderColorSVG: function () {},
                setBorderHTML: function (ctx, width, fill, opacity) {
                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                    ctx.shapeNode.style['border'] = null;
                    this.compensateShapeNode(ctx);
                } else {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                }
            },
                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                setBorderRadiusHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderRadiusSVG: function () {},
                setBorderStyle: function (value) {
                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                return this.shapeSetter('BorderStyle', value);
            },
                setBorderStyleHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
            },
                setBorderStyleSVG: function (ctx, value) {
                if (value == 'dashed')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                else if (value == 'dotted')
                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                else
                    ctx.shapeNode.removeAttribute('stroke-dasharray')
            },
                setBorderStylingMode: function (value) {
                return this.shapeSetter('BorderStylingMode', value);
            },
                setBorderStylingModeHTML: function (ctx, value) {
                this.setBorderHTML(
                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                this.setExtentHTML(ctx, this.getExtent());
            },
                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                setBorderWidthHTML: function (ctx, width) {
                if (this.getBorderStylingMode()) {
                    ctx.shapeNode.style.border = '';
                    ctx.shapeNode.style.borderWidth = width+'px';
                } else {
                    ctx.shapeNode.style.borderWidth = '';
                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                }
                this.compensateShapeNode(ctx);
                this.setExtentHTML(ctx, this.getExtent());
                return width;
            },
                setBorderWidthSVG: function (ctx, value) {
                // var node = this.getPathNodeHTML(ctx);
                // node && node.setAttribute('stroke-width', String(value))
            },
                setBounds: function (bounds) {
                this.setPosition(bounds.topLeft());
                this.setExtent(bounds.extent());
                return bounds
            },
                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                setExtentHTML: function (ctx, value) {
                if (!ctx.shapeNode) return undefined;
                var padding = this.getPadding(),
                    paddingWidth = padding.left() + padding.right(),
                    paddingHeight = padding.top() + padding.bottom(),
                    // HTML isn't using fractions for pixels, rounds internally,
                    // this has to be reflected to compensate HTML's box model
                    borderWidth = Math.floor(this.getBorderWidth()),
                    realExtent = value
                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                 .addXY(-paddingWidth, -paddingHeight);
                    realExtent = realExtent.maxPt(pt(0,0));
                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                return realExtent;
            },
                setExtentSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                // update also parents so that shapes is not clipped... really necassary? FIXME
                // if (ctx.morphNode)
                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                // if (ctx.morphNode.parentNode.tagName == 'svg')
                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
            },
                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                setFillHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setFillOpacity: function (opacity) {
                var fill = this.getFill()
                if (fill && fill.withA)
                    this.setFill(fill.withA(opacity))
            },
                setFillSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setFill(ctx.shapeNode, value);
            },
                setNodeClass: function (value) {
                return this.shapeSetter('NodeClass', value);
            },
                setNodeId: function (value) {
                return this.shapeSetter('NodeId', value);
            },
                setNodeIdHTML: function (ctx, id) {
                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                return id;
            },
                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                setOpacityHTML: function (ctx, value) {
                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
            },
                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                setPaddingHTML: function (ctx, r) {
                if (r === undefined || !ctx.shapeNode) return r;
                // Rectangle.inset(left, top, right, bottom) ==>
                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                ctx.shapeNode.style.padding = s;
                return r;
            },
                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                graphicContext.beginPath();
                graphicContext.moveTo(bnds.x, bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.y);
                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                graphicContext.lineTo(bnds.x, bnds.maxY());
                graphicContext.closePath();
            },
                setPosition: function (position) { return this.shapeSetter('Position', position) },
                setPositionHTML: function (ctx, value) {
                if (!ctx.shapeNode) return;
                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                if (ctx.originNode) {
                    this.compensateShapeNode(ctx);
                }
            },
                setPositionSVG: function (ctx, value) {
                if (ctx.shapeNode)
                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
            },
                setRenderContext: function (newRenderContext) {
                if (newRenderContext) {
                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                        this, newRenderContext.renderContextTableName);
                }
                this._renderContext = newRenderContext;
            },
                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                setStrokeOpacityHTML: function (ctx, opacity) {
                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
            },
                setStrokeOpacitySVG: function () {},
                setVertices: function () {
                // This does nothing for non path shapes
            },
                shapeGetter: function (propName) { return this['_' + propName] },
                shapeSetter: function (propName, value) {
                if (value === undefined) {
                    delete this['_' + propName];
                } else {
                    this['_' + propName] = value;
                }
                return this.renderContextDispatch('set' + propName, value);
            },
                vertices: function () {
                var b = this.bounds();
                return [pt(b.x, b.y), pt(b.width, b.height)]
            }
            },
            sourceModule: "lively.morphic.Core",
            submorphs: [{
                _Extent: lively.pt(167723.3,260.0),
                _Fill: Color.rgb(255,255,255),
                _Position: lively.pt(16.0,16.0),
                _Visible: true,
                className: "lively.morphic.Tree",
                depth: 0,
                draggingEnabled: false,
                droppingEnabled: false,
                grabbingEnabled: false,
                isInLayoutCycle: false,
                name: "tree-view",
                shape: {
                    _BorderColor: Color.rgb(0,0,0),
                    _BorderRadius: 0,
                    _BorderStyle: "solid",
                    _BorderWidth: 0,
                    _Extent: lively.pt(167723.3,260.0),
                    _Fill: Color.rgb(255,255,255),
                    _Opacity: 1,
                    _Padding: lively.rect(0,0,0,0),
                    _Position: lively.pt(0.0,0.0),
                    canvasDispatchTable: {
                        append: "appendCANVAS",
                        appendShape: "renderCANVAS",
                        init: "initCANVAS",
                        remove: "removeCANVAS",
                        setPosition: "attributeChangedCANVAS"
                    },
                    doNotSerialize: ["_renderContext"],
                    htmlDispatchTable: {
                        appendShape: "renderHTML",
                        init: "initHTML",
                        setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                        setBorderColor: "setBorderColorHTML",
                        setBorderRadius: "setBorderRadiusHTML",
                        setBorderStyle: "setBorderStyleHTML",
                        setBorderStylingMode: "setBorderStylingModeHTML",
                        setBorderWidth: "setBorderWidthHTML",
                        setExtent: "setExtentHTML",
                        setFill: "setFillHTML",
                        setNodeId: "setNodeIdHTML",
                        setOpacity: "setOpacityHTML",
                        setPadding: "setPaddingHTML",
                        setPosition: "setPositionHTML",
                        setStrokeOpacity: "setStrokeOpacityHTML"
                    },
                    renderContextTableType: "shapeRenderContextTable",
                    svgDispatchTable: {
                        appendShape: "renderSVG",
                        init: "initSVG",
                        setBorderColor: "setBorderColorSVG",
                        setBorderRadius: "setBorderRadiusSVG",
                        setBorderStyle: "setBorderStyleSVG",
                        setBorderWidth: "setBorderWidthSVG",
                        setExtent: "setExtentSVG",
                        setFill: "setFillSVG",
                        setPosition: "setPositionSVG",
                        setStrokeOpacity: "setStrokeOpacitySVG"
                    },
                    attributeChangedCANVAS: function (ctx, value) {
                    ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                    this.renderCANVAS(ctx)
                },
                    bounds: function () { return this.getBounds() },
                    compensateShapeNode: function (ctx) {
                    // compensates the shapeNode's position for childmorphs,
                    // positions childmorphs against morphNodes (origin!)
                    if (!ctx.originNode) return;
                    ctx.originNode.style.setProperty(
                        'top', -this.getPosition().y + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'left', -this.getPosition().x + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'position', 'absolute', 'important');
            
                    // FIXME: hack, necessary until the style editor knows
                    // about stroke widths of svg lines instead of using borderWidth...
                    if (ctx.pathNode) return;
            
                    // compensates the shapeNode's borderWidth for childmorphs,
                    // borders don't affect submorphs
                    ctx.originNode.style.setProperty(
                        'margin-top', -this.getBorderWidth() + 'px', 'important');
                    ctx.originNode.style.setProperty(
                        'margin-left', -this.getBorderWidth() + 'px', 'important');
                },
                    constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                            if (bounds) this.setBounds(bounds);
                                        }}),
                    createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                    defaultRenderContext: function () { return null },
                    getAppearanceStylingMode: function () {
                    return this.shapeGetter('AppearanceStylingMode');
                },
                    getBorderColor: function () {
                    var fill = this.shapeGetter('BorderColor');
                    return fill === undefined ? Color.red : fill;
                },
                    getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                    getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                    getBorderStylingMode: function () {
                    return this.shapeGetter('BorderStylingMode');
                },
                    getBorderWidth: function () {
                    return this.shapeGetter('BorderWidth')  || 0;
                },
                    getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                    getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                    getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                    getFill: function () { return this.shapeGetter('Fill') || null },
                    getFillOpacity: function () {
                    var fill = this.getFill();
                    return (fill && typeof fill.a === "number") ? fill.a : 1;
                },
                    getNodeClass: function () {
                    return this.shapeGetter('NodeClass') || [];
                },
                    getNodeId: function () {
                    return this.shapeGetter('NodeId')
                },
                    getOpacity: function () {
                    var op = this.shapeGetter('Opacity');
                    return op === undefined ? 1 : Number(op);
                },
                    getPadding: function () {
                    return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                },
                    getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                    getStrokeOpacity: function () {
                    var op = this.shapeGetter('StrokeOpacity');
                    return op === undefined ? 1 : op;
                },
                    initCANVAS: function () {},
                    initHTML: function ($super, ctx) {
                    if (!ctx.shapeNode)
                        ctx.shapeNode = ctx.domInterface.htmlRect();
                    $super(ctx);
                    this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                },
                    initSVG: function (ctx) {
                    if (!ctx.shapeNode)
                        ctx.shapeNode = this.createShapeNode(ctx);
                    this.setPositionSVG(ctx, this.getPosition());
                    this.setExtentSVG(ctx, this.getExtent());
                    this.setFillSVG(ctx, this.getFill());
                    this.setBorderWidthSVG(ctx, this.getBorderWidth());
                    this.setBorderColorSVG(ctx, this.getBorderColor());
                    this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                },
                    initialize: function (bounds) {
                                            if (bounds) this.setBounds(bounds);
                                        },
                    reallyContainsPoint: function (pt) {
                    // Overridden for non-rectangular shapes like lines and ellipses
                    // Note assumes that pt is within this.bounds
                    return true
                },
                    renderCANVAS: function (ctx) {
                    var graphicContext = ctx.getGraphicContext(),
                        pathSet = false,
                        bounds = this.getBounds(),
                        fill = this.getFill();
                    if (fill) { // Fill first, then stroke
                        var alpha = this.getFillOpacity();
                        if (alpha != 1) graphicContext.globalAlpha = alpha;
                        graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                        this.setPath(graphicContext, bounds);
                        graphicContext.fill();
                        pathSet = true;
                    }
                    // if (this.getStroke() && this.getStrokeWidth() > 0) {
                        // var alpha = this.getStrokeOpacity();
                        // if (alpha != 1) graphicContext.globalAlpha = alpha;
                        // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                        // graphicContext.lineWidth = this.getStrokeWidth();
                        // this.drawStrokeOn(graphicContext, bounds, pathSet);
                    // }
                },
                    renderContext: function () {
                    if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                    return this._renderContext;
                },
                    renderContextDispatch: function (aspect, arg) {
                    if (!this._renderContext) this.renderContext();
                    // if we cannot lazy initialize the renderContext we just do nothing
                    if (!this._renderContext) return undefined;
                    var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                    if (!renderSpecificAspect) {
                        dbgOn(true, 'renderContextTable does no include: ' + aspect);
                        return undefined;
                    }
                    return this[renderSpecificAspect](this._renderContext, arg);
                },
                    renderHTML: function (ctx) {
                    if (ctx.shapeNode.parentNode) return;
                    var child = ctx.morphNode.childNodes[0];
                    if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                    else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                },
                    renderSVG: function (ctx) {
                    if (!ctx.shapeNode.parentNode)
                        ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                },
                    renderUsing: function (renderContext) {
                    this.setRenderContext(renderContext);
                    this.renderContextDispatch('init');
                    this.renderContextDispatch('appendShape');
                },
                    setAppearanceStylingMode: function (value) {
                    return this.shapeSetter('AppearanceStylingMode', value);
                },
                    setAppearanceStylingModeHTML: function (ctx, value) {
                    this.setFillHTML(ctx, this.shapeGetter("Fill"));
                    this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                },
                    setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                    setBorderColorHTML: function (ctx, fill) {
                    var alpha;
                    if (this.getStrokeOpacity() != 1) {
                        alpha = this.getStrokeOpacity();
                    } else {
                        alpha = fill === null ? 0 : fill.a;
                    }
                    return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                },
                    setBorderColorSVG: function () {},
                    setBorderHTML: function (ctx, width, fill, opacity) {
                    if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                        ctx.shapeNode.style['border'] = null;
                        this.compensateShapeNode(ctx);
                    } else {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                    }
                },
                    setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                    setBorderRadiusHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                },
                    setBorderRadiusSVG: function () {},
                    setBorderStyle: function (value) {
                    // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                    return this.shapeSetter('BorderStyle', value);
                },
                    setBorderStyleHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                },
                    setBorderStyleSVG: function (ctx, value) {
                    if (value == 'dashed')
                        ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                    else if (value == 'dotted')
                        ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                    else
                        ctx.shapeNode.removeAttribute('stroke-dasharray')
                },
                    setBorderStylingMode: function (value) {
                    return this.shapeSetter('BorderStylingMode', value);
                },
                    setBorderStylingModeHTML: function (ctx, value) {
                    this.setBorderHTML(
                        ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                    this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    this.setExtentHTML(ctx, this.getExtent());
                },
                    setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                    setBorderWidthHTML: function (ctx, width) {
                    if (this.getBorderStylingMode()) {
                        ctx.shapeNode.style.border = '';
                        ctx.shapeNode.style.borderWidth = width+'px';
                    } else {
                        ctx.shapeNode.style.borderWidth = '';
                        this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                    }
                    this.compensateShapeNode(ctx);
                    this.setExtentHTML(ctx, this.getExtent());
                    return width;
                },
                    setBorderWidthSVG: function (ctx, value) {
                    // var node = this.getPathNodeHTML(ctx);
                    // node && node.setAttribute('stroke-width', String(value))
                },
                    setBounds: function (bounds) {
                    this.setPosition(bounds.topLeft());
                    this.setExtent(bounds.extent());
                    return bounds
                },
                    setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                    setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                    setExtentHTML: function (ctx, value) {
                    if (!ctx.shapeNode) return undefined;
                    var padding = this.getPadding(),
                        paddingWidth = padding.left() + padding.right(),
                        paddingHeight = padding.top() + padding.bottom(),
                        // HTML isn't using fractions for pixels, rounds internally,
                        // this has to be reflected to compensate HTML's box model
                        borderWidth = Math.floor(this.getBorderWidth()),
                        realExtent = value
                                     .addXY(-2 * borderWidth, -2 * borderWidth)
                                     .addXY(-paddingWidth, -paddingHeight);
                        realExtent = realExtent.maxPt(pt(0,0));
                    ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                    return realExtent;
                },
                    setExtentSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setExtent(ctx.shapeNode, value);
                    // update also parents so that shapes is not clipped... really necassary? FIXME
                    // if (ctx.morphNode)
                        // ctx.domInterface.setExtent(ctx.morphNode, value);
                    // if (ctx.morphNode.parentNode.tagName == 'svg')
                        // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                },
                    setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                    setFillHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                },
                    setFillOpacity: function (opacity) {
                    var fill = this.getFill()
                    if (fill && fill.withA)
                        this.setFill(fill.withA(opacity))
                },
                    setFillSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setFill(ctx.shapeNode, value);
                },
                    setNodeClass: function (value) {
                    return this.shapeSetter('NodeClass', value);
                },
                    setNodeId: function (value) {
                    return this.shapeSetter('NodeId', value);
                },
                    setNodeIdHTML: function (ctx, id) {
                    ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                    return id;
                },
                    setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                    setOpacityHTML: function (ctx, value) {
                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                },
                    setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                    setPaddingHTML: function (ctx, r) {
                    if (r === undefined || !ctx.shapeNode) return r;
                    // Rectangle.inset(left, top, right, bottom) ==>
                    // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                    var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                    ctx.shapeNode.style.padding = s;
                    return r;
                },
                    setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                    graphicContext.beginPath();
                    graphicContext.moveTo(bnds.x, bnds.y);
                    graphicContext.lineTo(bnds.maxX(), bnds.y);
                    graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                    graphicContext.lineTo(bnds.x, bnds.maxY());
                    graphicContext.closePath();
                },
                    setPosition: function (position) { return this.shapeSetter('Position', position) },
                    setPositionHTML: function (ctx, value) {
                    if (!ctx.shapeNode) return;
                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    if (ctx.originNode) {
                        this.compensateShapeNode(ctx);
                    }
                },
                    setPositionSVG: function (ctx, value) {
                    if (ctx.shapeNode)
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                },
                    setRenderContext: function (newRenderContext) {
                    if (newRenderContext) {
                        newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                            this, newRenderContext.renderContextTableName);
                    }
                    this._renderContext = newRenderContext;
                },
                    setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                    setStrokeOpacityHTML: function (ctx, opacity) {
                    return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                },
                    setStrokeOpacitySVG: function () {},
                    setVertices: function () {
                    // This does nothing for non path shapes
                },
                    shapeGetter: function (propName) { return this['_' + propName] },
                    shapeSetter: function (propName, value) {
                    if (value === undefined) {
                        delete this['_' + propName];
                    } else {
                        this['_' + propName] = value;
                    }
                    return this.renderContextDispatch('set' + propName, value);
                },
                    vertices: function () {
                    var b = this.bounds();
                    return [pt(b.x, b.y), pt(b.width, b.height)]
                }
                },
                showMoreNode: null,
                sourceModule: "lively.morphic.Widgets",
                submorphs: [{
                    _BorderColor: null,
                    _Extent: lively.pt(167723.3,20.0),
                    className: "lively.morphic.Box",
                    droppingEnabled: true,
                    eventsAreIgnored: true,
                    layout: {
                        borderSize: 0,
                        resizeWidth: true,
                        spacing: 5,
                        type: "lively.morphic.Layout.HorizontalLayout"
                    },
                    shape: {
                        _BorderColor: null,
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: null,
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Core",
                    submorphs: [{
                        _Align: "right",
                        _Extent: lively.pt(10.0,20.0),
                        _FontFamily: "Helvetica",
                        _HandStyle: "default",
                        _InputAllowed: false,
                        _TextColor: Color.rgb(64,64,64),
                        allowInput: false,
                        className: "lively.morphic.Text",
                        draggingEnabled: false,
                        droppingEnabled: false,
                        emphasis: [[0,1,{}]],
                        evalEnabled: false,
                        fixedHeight: true,
                        fixedWidth: true,
                        grabbingEnabled: false,
                        shape: {
                            _BorderColor: Color.rgb(0,0,0),
                            _BorderWidth: 0,
                            _Extent: lively.pt(10.0,20.0),
                            _Fill: null,
                            _Padding: lively.rect(4,2,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.TextCore",
                        textString: "▼",
                        onMouseDown: function onMouseDown(evt) {
                                if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                    this.owner.owner.toggle();
                                }
                            }
                    },{
                        _Extent: lively.pt(88.0,20.0),
                        _FontFamily: "Helvetica",
                        _HandStyle: "default",
                        _InputAllowed: false,
                        _Position: lively.pt(15.0,0.0),
                        _TextColor: Color.rgb(64,64,64),
                        _WhiteSpaceHandling: "pre",
                        allowInput: false,
                        className: "lively.morphic.Text",
                        draggingEnabled: false,
                        droppingEnabled: false,
                        emphasis: [[0,12,{}]],
                        evalEnabled: false,
                        fixedHeight: true,
                        grabbingEnabled: false,
                        shape: {
                            _BorderColor: Color.rgb(0,0,0),
                            _BorderWidth: 0,
                            _Extent: lively.pt(88.0,20.0),
                            _Fill: null,
                            _Padding: lively.rect(4,2,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.TextCore",
                        textString: "Entanglement",
                        onMouseDown: function onMouseDown(evt) {
                                if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                    this.owner.owner.getRootTree().select(this.owner.owner);
                                }
                            }
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,20.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(192.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,9,{}],[9,30,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(192.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "className  lively.morphic.Path",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,40.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(281.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,12,{}],[12,45,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(281.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "sourceModule  lively.morphic.AdditionalMorphs",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,60.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(94.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,4,{}],[4,14,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(94.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "name  Triangle",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,80.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(134.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,15,{}],[15,21,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(134.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "droppingEnabled  true",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,100.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(191.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,9,{}],[9,33,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(191.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "_Position  lively.pt(760.0,361.0)",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,120.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(168.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,7,{}],[7,29,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(168.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "_Extent  lively.pt(94.0,87.0)",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,140.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(123.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,5,{}],[5,21,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(123.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "_Fill  rgb(255,143,0)",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,160.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(167.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,12,{}],[12,27,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(167.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "_BorderColor  rgb(66,66,66)",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,180.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(217.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,12,{}],[12,32,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(217.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "_BorderWidth  2.8160000000000003",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,200.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(136.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,5,{}],[5,22,{
                                color: Color.rgb(169,169,169)
                            }]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(136.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "shape  [object Object]",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,220.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,0,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(84.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,13,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(84.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "controlPoints",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                },{
                    _Extent: lively.pt(167723.3,20.0),
                    _Fill: Color.rgb(255,255,255),
                    _Position: lively.pt(0.0,240.0),
                    className: "lively.morphic.Tree",
                    depth: 1,
                    draggingEnabled: false,
                    droppingEnabled: false,
                    grabbingEnabled: false,
                    isInLayoutCycle: false,
                    parent: {
                        isMorphRef: true,
                        name: "tree-view"
                    },
                    shape: {
                        _BorderColor: Color.rgb(0,0,0),
                        _BorderWidth: 0,
                        _Extent: lively.pt(167723.3,20.0),
                        _Fill: Color.rgb(255,255,255),
                        _Padding: lively.rect(0,0,0,0),
                        _Position: lively.pt(0.0,0.0),
                        canvasDispatchTable: {
                            append: "appendCANVAS",
                            appendShape: "renderCANVAS",
                            init: "initCANVAS",
                            remove: "removeCANVAS",
                            setPosition: "attributeChangedCANVAS"
                        },
                        doNotSerialize: ["_renderContext"],
                        htmlDispatchTable: {
                            appendShape: "renderHTML",
                            init: "initHTML",
                            setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                            setBorderColor: "setBorderColorHTML",
                            setBorderRadius: "setBorderRadiusHTML",
                            setBorderStyle: "setBorderStyleHTML",
                            setBorderStylingMode: "setBorderStylingModeHTML",
                            setBorderWidth: "setBorderWidthHTML",
                            setExtent: "setExtentHTML",
                            setFill: "setFillHTML",
                            setNodeId: "setNodeIdHTML",
                            setOpacity: "setOpacityHTML",
                            setPadding: "setPaddingHTML",
                            setPosition: "setPositionHTML",
                            setStrokeOpacity: "setStrokeOpacityHTML"
                        },
                        renderContextTableType: "shapeRenderContextTable",
                        svgDispatchTable: {
                            appendShape: "renderSVG",
                            init: "initSVG",
                            setBorderColor: "setBorderColorSVG",
                            setBorderRadius: "setBorderRadiusSVG",
                            setBorderStyle: "setBorderStyleSVG",
                            setBorderWidth: "setBorderWidthSVG",
                            setExtent: "setExtentSVG",
                            setFill: "setFillSVG",
                            setPosition: "setPositionSVG",
                            setStrokeOpacity: "setStrokeOpacitySVG"
                        },
                        attributeChangedCANVAS: function (ctx, value) {
                        ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                        this.renderCANVAS(ctx)
                    },
                        bounds: function () { return this.getBounds() },
                        compensateShapeNode: function (ctx) {
                        // compensates the shapeNode's position for childmorphs,
                        // positions childmorphs against morphNodes (origin!)
                        if (!ctx.originNode) return;
                        ctx.originNode.style.setProperty(
                            'top', -this.getPosition().y + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'left', -this.getPosition().x + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'position', 'absolute', 'important');
                
                        // FIXME: hack, necessary until the style editor knows
                        // about stroke widths of svg lines instead of using borderWidth...
                        if (ctx.pathNode) return;
                
                        // compensates the shapeNode's borderWidth for childmorphs,
                        // borders don't affect submorphs
                        ctx.originNode.style.setProperty(
                            'margin-top', -this.getBorderWidth() + 'px', 'important');
                        ctx.originNode.style.setProperty(
                            'margin-left', -this.getBorderWidth() + 'px', 'important');
                    },
                        constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            }}),
                        createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                        defaultRenderContext: function () { return null },
                        getAppearanceStylingMode: function () {
                        return this.shapeGetter('AppearanceStylingMode');
                    },
                        getBorderColor: function () {
                        var fill = this.shapeGetter('BorderColor');
                        return fill === undefined ? Color.red : fill;
                    },
                        getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                        getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                        getBorderStylingMode: function () {
                        return this.shapeGetter('BorderStylingMode');
                    },
                        getBorderWidth: function () {
                        return this.shapeGetter('BorderWidth')  || 0;
                    },
                        getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                        getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                        getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                        getFill: function () { return this.shapeGetter('Fill') || null },
                        getFillOpacity: function () {
                        var fill = this.getFill();
                        return (fill && typeof fill.a === "number") ? fill.a : 1;
                    },
                        getNodeClass: function () {
                        return this.shapeGetter('NodeClass') || [];
                    },
                        getNodeId: function () {
                        return this.shapeGetter('NodeId')
                    },
                        getOpacity: function () {
                        var op = this.shapeGetter('Opacity');
                        return op === undefined ? 1 : Number(op);
                    },
                        getPadding: function () {
                        return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                    },
                        getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                        getStrokeOpacity: function () {
                        var op = this.shapeGetter('StrokeOpacity');
                        return op === undefined ? 1 : op;
                    },
                        initCANVAS: function () {},
                        initHTML: function ($super, ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = ctx.domInterface.htmlRect();
                        $super(ctx);
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                    },
                        initSVG: function (ctx) {
                        if (!ctx.shapeNode)
                            ctx.shapeNode = this.createShapeNode(ctx);
                        this.setPositionSVG(ctx, this.getPosition());
                        this.setExtentSVG(ctx, this.getExtent());
                        this.setFillSVG(ctx, this.getFill());
                        this.setBorderWidthSVG(ctx, this.getBorderWidth());
                        this.setBorderColorSVG(ctx, this.getBorderColor());
                        this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                    },
                        initialize: function (bounds) {
                                                if (bounds) this.setBounds(bounds);
                                            },
                        reallyContainsPoint: function (pt) {
                        // Overridden for non-rectangular shapes like lines and ellipses
                        // Note assumes that pt is within this.bounds
                        return true
                    },
                        renderCANVAS: function (ctx) {
                        var graphicContext = ctx.getGraphicContext(),
                            pathSet = false,
                            bounds = this.getBounds(),
                            fill = this.getFill();
                        if (fill) { // Fill first, then stroke
                            var alpha = this.getFillOpacity();
                            if (alpha != 1) graphicContext.globalAlpha = alpha;
                            graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                            this.setPath(graphicContext, bounds);
                            graphicContext.fill();
                            pathSet = true;
                        }
                        // if (this.getStroke() && this.getStrokeWidth() > 0) {
                            // var alpha = this.getStrokeOpacity();
                            // if (alpha != 1) graphicContext.globalAlpha = alpha;
                            // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                            // graphicContext.lineWidth = this.getStrokeWidth();
                            // this.drawStrokeOn(graphicContext, bounds, pathSet);
                        // }
                    },
                        renderContext: function () {
                        if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                        return this._renderContext;
                    },
                        renderContextDispatch: function (aspect, arg) {
                        if (!this._renderContext) this.renderContext();
                        // if we cannot lazy initialize the renderContext we just do nothing
                        if (!this._renderContext) return undefined;
                        var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                        if (!renderSpecificAspect) {
                            dbgOn(true, 'renderContextTable does no include: ' + aspect);
                            return undefined;
                        }
                        return this[renderSpecificAspect](this._renderContext, arg);
                    },
                        renderHTML: function (ctx) {
                        if (ctx.shapeNode.parentNode) return;
                        var child = ctx.morphNode.childNodes[0];
                        if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                        else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                    },
                        renderSVG: function (ctx) {
                        if (!ctx.shapeNode.parentNode)
                            ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                    },
                        renderUsing: function (renderContext) {
                        this.setRenderContext(renderContext);
                        this.renderContextDispatch('init');
                        this.renderContextDispatch('appendShape');
                    },
                        setAppearanceStylingMode: function (value) {
                        return this.shapeSetter('AppearanceStylingMode', value);
                    },
                        setAppearanceStylingModeHTML: function (ctx, value) {
                        this.setFillHTML(ctx, this.shapeGetter("Fill"));
                        this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                    },
                        setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                        setBorderColorHTML: function (ctx, fill) {
                        var alpha;
                        if (this.getStrokeOpacity() != 1) {
                            alpha = this.getStrokeOpacity();
                        } else {
                            alpha = fill === null ? 0 : fill.a;
                        }
                        return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                    },
                        setBorderColorSVG: function () {},
                        setBorderHTML: function (ctx, width, fill, opacity) {
                        if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                            ctx.shapeNode.style['border'] = null;
                            this.compensateShapeNode(ctx);
                        } else {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                        }
                    },
                        setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                        setBorderRadiusHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderRadiusSVG: function () {},
                        setBorderStyle: function (value) {
                        // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                        return this.shapeSetter('BorderStyle', value);
                    },
                        setBorderStyleHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                    },
                        setBorderStyleSVG: function (ctx, value) {
                        if (value == 'dashed')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                        else if (value == 'dotted')
                            ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                        else
                            ctx.shapeNode.removeAttribute('stroke-dasharray')
                    },
                        setBorderStylingMode: function (value) {
                        return this.shapeSetter('BorderStylingMode', value);
                    },
                        setBorderStylingModeHTML: function (ctx, value) {
                        this.setBorderHTML(
                            ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                        this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        this.setExtentHTML(ctx, this.getExtent());
                    },
                        setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                        setBorderWidthHTML: function (ctx, width) {
                        if (this.getBorderStylingMode()) {
                            ctx.shapeNode.style.border = '';
                            ctx.shapeNode.style.borderWidth = width+'px';
                        } else {
                            ctx.shapeNode.style.borderWidth = '';
                            this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                        }
                        this.compensateShapeNode(ctx);
                        this.setExtentHTML(ctx, this.getExtent());
                        return width;
                    },
                        setBorderWidthSVG: function (ctx, value) {
                        // var node = this.getPathNodeHTML(ctx);
                        // node && node.setAttribute('stroke-width', String(value))
                    },
                        setBounds: function (bounds) {
                        this.setPosition(bounds.topLeft());
                        this.setExtent(bounds.extent());
                        return bounds
                    },
                        setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                        setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                        setExtentHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return undefined;
                        var padding = this.getPadding(),
                            paddingWidth = padding.left() + padding.right(),
                            paddingHeight = padding.top() + padding.bottom(),
                            // HTML isn't using fractions for pixels, rounds internally,
                            // this has to be reflected to compensate HTML's box model
                            borderWidth = Math.floor(this.getBorderWidth()),
                            realExtent = value
                                         .addXY(-2 * borderWidth, -2 * borderWidth)
                                         .addXY(-paddingWidth, -paddingHeight);
                            realExtent = realExtent.maxPt(pt(0,0));
                        ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                        return realExtent;
                    },
                        setExtentSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setExtent(ctx.shapeNode, value);
                        // update also parents so that shapes is not clipped... really necassary? FIXME
                        // if (ctx.morphNode)
                            // ctx.domInterface.setExtent(ctx.morphNode, value);
                        // if (ctx.morphNode.parentNode.tagName == 'svg')
                            // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                    },
                        setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                        setFillHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setFillOpacity: function (opacity) {
                        var fill = this.getFill()
                        if (fill && fill.withA)
                            this.setFill(fill.withA(opacity))
                    },
                        setFillSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setFill(ctx.shapeNode, value);
                    },
                        setNodeClass: function (value) {
                        return this.shapeSetter('NodeClass', value);
                    },
                        setNodeId: function (value) {
                        return this.shapeSetter('NodeId', value);
                    },
                        setNodeIdHTML: function (ctx, id) {
                        ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                        return id;
                    },
                        setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                        setOpacityHTML: function (ctx, value) {
                        return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                    },
                        setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                        setPaddingHTML: function (ctx, r) {
                        if (r === undefined || !ctx.shapeNode) return r;
                        // Rectangle.inset(left, top, right, bottom) ==>
                        // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                        var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                        ctx.shapeNode.style.padding = s;
                        return r;
                    },
                        setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                        graphicContext.beginPath();
                        graphicContext.moveTo(bnds.x, bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.y);
                        graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                        graphicContext.lineTo(bnds.x, bnds.maxY());
                        graphicContext.closePath();
                    },
                        setPosition: function (position) { return this.shapeSetter('Position', position) },
                        setPositionHTML: function (ctx, value) {
                        if (!ctx.shapeNode) return;
                        ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        if (ctx.originNode) {
                            this.compensateShapeNode(ctx);
                        }
                    },
                        setPositionSVG: function (ctx, value) {
                        if (ctx.shapeNode)
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                    },
                        setRenderContext: function (newRenderContext) {
                        if (newRenderContext) {
                            newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                this, newRenderContext.renderContextTableName);
                        }
                        this._renderContext = newRenderContext;
                    },
                        setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                        setStrokeOpacityHTML: function (ctx, opacity) {
                        return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                    },
                        setStrokeOpacitySVG: function () {},
                        setVertices: function () {
                        // This does nothing for non path shapes
                    },
                        shapeGetter: function (propName) { return this['_' + propName] },
                        shapeSetter: function (propName, value) {
                        if (value === undefined) {
                            delete this['_' + propName];
                        } else {
                            this['_' + propName] = value;
                        }
                        return this.renderContextDispatch('set' + propName, value);
                    },
                        vertices: function () {
                        var b = this.bounds();
                        return [pt(b.x, b.y), pt(b.width, b.height)]
                    }
                    },
                    showMoreNode: null,
                    sourceModule: "lively.morphic.Widgets",
                    submorphs: [{
                        _BorderColor: null,
                        _Extent: lively.pt(167707.3,20.0),
                        _Position: lively.pt(16.0,0.0),
                        className: "lively.morphic.Box",
                        droppingEnabled: true,
                        eventsAreIgnored: true,
                        layout: {
                            borderSize: 0,
                            resizeWidth: true,
                            spacing: 5,
                            type: "lively.morphic.Layout.HorizontalLayout"
                        },
                        shape: {
                            _BorderColor: null,
                            _BorderWidth: 0,
                            _Extent: lively.pt(167707.3,20.0),
                            _Fill: null,
                            _Padding: lively.rect(0,0,0,0),
                            _Position: lively.pt(0.0,0.0),
                            canvasDispatchTable: {
                                append: "appendCANVAS",
                                appendShape: "renderCANVAS",
                                init: "initCANVAS",
                                remove: "removeCANVAS",
                                setPosition: "attributeChangedCANVAS"
                            },
                            doNotSerialize: ["_renderContext"],
                            htmlDispatchTable: {
                                appendShape: "renderHTML",
                                init: "initHTML",
                                setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                setBorderColor: "setBorderColorHTML",
                                setBorderRadius: "setBorderRadiusHTML",
                                setBorderStyle: "setBorderStyleHTML",
                                setBorderStylingMode: "setBorderStylingModeHTML",
                                setBorderWidth: "setBorderWidthHTML",
                                setExtent: "setExtentHTML",
                                setFill: "setFillHTML",
                                setNodeId: "setNodeIdHTML",
                                setOpacity: "setOpacityHTML",
                                setPadding: "setPaddingHTML",
                                setPosition: "setPositionHTML",
                                setStrokeOpacity: "setStrokeOpacityHTML"
                            },
                            renderContextTableType: "shapeRenderContextTable",
                            svgDispatchTable: {
                                appendShape: "renderSVG",
                                init: "initSVG",
                                setBorderColor: "setBorderColorSVG",
                                setBorderRadius: "setBorderRadiusSVG",
                                setBorderStyle: "setBorderStyleSVG",
                                setBorderWidth: "setBorderWidthSVG",
                                setExtent: "setExtentSVG",
                                setFill: "setFillSVG",
                                setPosition: "setPositionSVG",
                                setStrokeOpacity: "setStrokeOpacitySVG"
                            },
                            attributeChangedCANVAS: function (ctx, value) {
                            ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                            this.renderCANVAS(ctx)
                        },
                            bounds: function () { return this.getBounds() },
                            compensateShapeNode: function (ctx) {
                            // compensates the shapeNode's position for childmorphs,
                            // positions childmorphs against morphNodes (origin!)
                            if (!ctx.originNode) return;
                            ctx.originNode.style.setProperty(
                                'top', -this.getPosition().y + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'left', -this.getPosition().x + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'position', 'absolute', 'important');
                    
                            // FIXME: hack, necessary until the style editor knows
                            // about stroke widths of svg lines instead of using borderWidth...
                            if (ctx.pathNode) return;
                    
                            // compensates the shapeNode's borderWidth for childmorphs,
                            // borders don't affect submorphs
                            ctx.originNode.style.setProperty(
                                'margin-top', -this.getBorderWidth() + 'px', 'important');
                            ctx.originNode.style.setProperty(
                                'margin-left', -this.getBorderWidth() + 'px', 'important');
                        },
                            constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                }}),
                            createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                            defaultRenderContext: function () { return null },
                            getAppearanceStylingMode: function () {
                            return this.shapeGetter('AppearanceStylingMode');
                        },
                            getBorderColor: function () {
                            var fill = this.shapeGetter('BorderColor');
                            return fill === undefined ? Color.red : fill;
                        },
                            getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                            getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                            getBorderStylingMode: function () {
                            return this.shapeGetter('BorderStylingMode');
                        },
                            getBorderWidth: function () {
                            return this.shapeGetter('BorderWidth')  || 0;
                        },
                            getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                            getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                            getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                            getFill: function () { return this.shapeGetter('Fill') || null },
                            getFillOpacity: function () {
                            var fill = this.getFill();
                            return (fill && typeof fill.a === "number") ? fill.a : 1;
                        },
                            getNodeClass: function () {
                            return this.shapeGetter('NodeClass') || [];
                        },
                            getNodeId: function () {
                            return this.shapeGetter('NodeId')
                        },
                            getOpacity: function () {
                            var op = this.shapeGetter('Opacity');
                            return op === undefined ? 1 : Number(op);
                        },
                            getPadding: function () {
                            return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                        },
                            getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                            getStrokeOpacity: function () {
                            var op = this.shapeGetter('StrokeOpacity');
                            return op === undefined ? 1 : op;
                        },
                            initCANVAS: function () {},
                            initHTML: function ($super, ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = ctx.domInterface.htmlRect();
                            $super(ctx);
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                        },
                            initSVG: function (ctx) {
                            if (!ctx.shapeNode)
                                ctx.shapeNode = this.createShapeNode(ctx);
                            this.setPositionSVG(ctx, this.getPosition());
                            this.setExtentSVG(ctx, this.getExtent());
                            this.setFillSVG(ctx, this.getFill());
                            this.setBorderWidthSVG(ctx, this.getBorderWidth());
                            this.setBorderColorSVG(ctx, this.getBorderColor());
                            this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                        },
                            initialize: function (bounds) {
                                                    if (bounds) this.setBounds(bounds);
                                                },
                            reallyContainsPoint: function (pt) {
                            // Overridden for non-rectangular shapes like lines and ellipses
                            // Note assumes that pt is within this.bounds
                            return true
                        },
                            renderCANVAS: function (ctx) {
                            var graphicContext = ctx.getGraphicContext(),
                                pathSet = false,
                                bounds = this.getBounds(),
                                fill = this.getFill();
                            if (fill) { // Fill first, then stroke
                                var alpha = this.getFillOpacity();
                                if (alpha != 1) graphicContext.globalAlpha = alpha;
                                graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                this.setPath(graphicContext, bounds);
                                graphicContext.fill();
                                pathSet = true;
                            }
                            // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                // var alpha = this.getStrokeOpacity();
                                // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                // graphicContext.lineWidth = this.getStrokeWidth();
                                // this.drawStrokeOn(graphicContext, bounds, pathSet);
                            // }
                        },
                            renderContext: function () {
                            if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                            return this._renderContext;
                        },
                            renderContextDispatch: function (aspect, arg) {
                            if (!this._renderContext) this.renderContext();
                            // if we cannot lazy initialize the renderContext we just do nothing
                            if (!this._renderContext) return undefined;
                            var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                            if (!renderSpecificAspect) {
                                dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                return undefined;
                            }
                            return this[renderSpecificAspect](this._renderContext, arg);
                        },
                            renderHTML: function (ctx) {
                            if (ctx.shapeNode.parentNode) return;
                            var child = ctx.morphNode.childNodes[0];
                            if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                            else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                        },
                            renderSVG: function (ctx) {
                            if (!ctx.shapeNode.parentNode)
                                ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                        },
                            renderUsing: function (renderContext) {
                            this.setRenderContext(renderContext);
                            this.renderContextDispatch('init');
                            this.renderContextDispatch('appendShape');
                        },
                            setAppearanceStylingMode: function (value) {
                            return this.shapeSetter('AppearanceStylingMode', value);
                        },
                            setAppearanceStylingModeHTML: function (ctx, value) {
                            this.setFillHTML(ctx, this.shapeGetter("Fill"));
                            this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                        },
                            setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                            setBorderColorHTML: function (ctx, fill) {
                            var alpha;
                            if (this.getStrokeOpacity() != 1) {
                                alpha = this.getStrokeOpacity();
                            } else {
                                alpha = fill === null ? 0 : fill.a;
                            }
                            return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                        },
                            setBorderColorSVG: function () {},
                            setBorderHTML: function (ctx, width, fill, opacity) {
                            if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                ctx.shapeNode.style['border'] = null;
                                this.compensateShapeNode(ctx);
                            } else {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                            }
                        },
                            setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                            setBorderRadiusHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderRadiusSVG: function () {},
                            setBorderStyle: function (value) {
                            // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                            return this.shapeSetter('BorderStyle', value);
                        },
                            setBorderStyleHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                        },
                            setBorderStyleSVG: function (ctx, value) {
                            if (value == 'dashed')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                            else if (value == 'dotted')
                                ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                            else
                                ctx.shapeNode.removeAttribute('stroke-dasharray')
                        },
                            setBorderStylingMode: function (value) {
                            return this.shapeSetter('BorderStylingMode', value);
                        },
                            setBorderStylingModeHTML: function (ctx, value) {
                            this.setBorderHTML(
                                ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                            this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            this.setExtentHTML(ctx, this.getExtent());
                        },
                            setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                            setBorderWidthHTML: function (ctx, width) {
                            if (this.getBorderStylingMode()) {
                                ctx.shapeNode.style.border = '';
                                ctx.shapeNode.style.borderWidth = width+'px';
                            } else {
                                ctx.shapeNode.style.borderWidth = '';
                                this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                            }
                            this.compensateShapeNode(ctx);
                            this.setExtentHTML(ctx, this.getExtent());
                            return width;
                        },
                            setBorderWidthSVG: function (ctx, value) {
                            // var node = this.getPathNodeHTML(ctx);
                            // node && node.setAttribute('stroke-width', String(value))
                        },
                            setBounds: function (bounds) {
                            this.setPosition(bounds.topLeft());
                            this.setExtent(bounds.extent());
                            return bounds
                        },
                            setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                            setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                            setExtentHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return undefined;
                            var padding = this.getPadding(),
                                paddingWidth = padding.left() + padding.right(),
                                paddingHeight = padding.top() + padding.bottom(),
                                // HTML isn't using fractions for pixels, rounds internally,
                                // this has to be reflected to compensate HTML's box model
                                borderWidth = Math.floor(this.getBorderWidth()),
                                realExtent = value
                                             .addXY(-2 * borderWidth, -2 * borderWidth)
                                             .addXY(-paddingWidth, -paddingHeight);
                                realExtent = realExtent.maxPt(pt(0,0));
                            ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                            return realExtent;
                        },
                            setExtentSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setExtent(ctx.shapeNode, value);
                            // update also parents so that shapes is not clipped... really necassary? FIXME
                            // if (ctx.morphNode)
                                // ctx.domInterface.setExtent(ctx.morphNode, value);
                            // if (ctx.morphNode.parentNode.tagName == 'svg')
                                // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                        },
                            setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                            setFillHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setFillOpacity: function (opacity) {
                            var fill = this.getFill()
                            if (fill && fill.withA)
                                this.setFill(fill.withA(opacity))
                        },
                            setFillSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setFill(ctx.shapeNode, value);
                        },
                            setNodeClass: function (value) {
                            return this.shapeSetter('NodeClass', value);
                        },
                            setNodeId: function (value) {
                            return this.shapeSetter('NodeId', value);
                        },
                            setNodeIdHTML: function (ctx, id) {
                            ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                            return id;
                        },
                            setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                            setOpacityHTML: function (ctx, value) {
                            return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                        },
                            setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                            setPaddingHTML: function (ctx, r) {
                            if (r === undefined || !ctx.shapeNode) return r;
                            // Rectangle.inset(left, top, right, bottom) ==>
                            // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                            var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                            ctx.shapeNode.style.padding = s;
                            return r;
                        },
                            setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                            graphicContext.beginPath();
                            graphicContext.moveTo(bnds.x, bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.y);
                            graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                            graphicContext.lineTo(bnds.x, bnds.maxY());
                            graphicContext.closePath();
                        },
                            setPosition: function (position) { return this.shapeSetter('Position', position) },
                            setPositionHTML: function (ctx, value) {
                            if (!ctx.shapeNode) return;
                            ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            if (ctx.originNode) {
                                this.compensateShapeNode(ctx);
                            }
                        },
                            setPositionSVG: function (ctx, value) {
                            if (ctx.shapeNode)
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                        },
                            setRenderContext: function (newRenderContext) {
                            if (newRenderContext) {
                                newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                    this, newRenderContext.renderContextTableName);
                            }
                            this._renderContext = newRenderContext;
                        },
                            setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                            setStrokeOpacityHTML: function (ctx, opacity) {
                            return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                        },
                            setStrokeOpacitySVG: function () {},
                            setVertices: function () {
                            // This does nothing for non path shapes
                        },
                            shapeGetter: function (propName) { return this['_' + propName] },
                            shapeSetter: function (propName, value) {
                            if (value === undefined) {
                                delete this['_' + propName];
                            } else {
                                this['_' + propName] = value;
                            }
                            return this.renderContextDispatch('set' + propName, value);
                        },
                            vertices: function () {
                            var b = this.bounds();
                            return [pt(b.x, b.y), pt(b.width, b.height)]
                        }
                        },
                        sourceModule: "lively.morphic.Core",
                        submorphs: [{
                            _Align: "right",
                            _Extent: lively.pt(10.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _TextColor: Color.rgb(64,64,64),
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,1,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            fixedWidth: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(10.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "►",
                            onMouseDown: function onMouseDown(evt) {
                                    if (this.owner.owner.item.children && evt.isLeftMouseButtonDown()) {
                                        this.owner.owner.toggle();
                                    }
                                }
                        },{
                            _Extent: lively.pt(116.0,20.0),
                            _FontFamily: "Helvetica",
                            _HandStyle: "default",
                            _InputAllowed: false,
                            _Position: lively.pt(15.0,0.0),
                            _TextColor: Color.rgb(64,64,64),
                            _WhiteSpaceHandling: "pre",
                            allowInput: false,
                            className: "lively.morphic.Text",
                            draggingEnabled: false,
                            droppingEnabled: false,
                            emphasis: [[0,16,{}]],
                            evalEnabled: false,
                            fixedHeight: true,
                            grabbingEnabled: false,
                            shape: {
                                _BorderColor: Color.rgb(0,0,0),
                                _BorderWidth: 0,
                                _Extent: lively.pt(116.0,20.0),
                                _Fill: null,
                                _Padding: lively.rect(4,2,0,0),
                                _Position: lively.pt(0.0,0.0),
                                canvasDispatchTable: {
                                    append: "appendCANVAS",
                                    appendShape: "renderCANVAS",
                                    init: "initCANVAS",
                                    remove: "removeCANVAS",
                                    setPosition: "attributeChangedCANVAS"
                                },
                                doNotSerialize: ["_renderContext"],
                                htmlDispatchTable: {
                                    appendShape: "renderHTML",
                                    init: "initHTML",
                                    setAppearanceStylingMode: "setAppearanceStylingModeHTML",
                                    setBorderColor: "setBorderColorHTML",
                                    setBorderRadius: "setBorderRadiusHTML",
                                    setBorderStyle: "setBorderStyleHTML",
                                    setBorderStylingMode: "setBorderStylingModeHTML",
                                    setBorderWidth: "setBorderWidthHTML",
                                    setExtent: "setExtentHTML",
                                    setFill: "setFillHTML",
                                    setNodeId: "setNodeIdHTML",
                                    setOpacity: "setOpacityHTML",
                                    setPadding: "setPaddingHTML",
                                    setPosition: "setPositionHTML",
                                    setStrokeOpacity: "setStrokeOpacityHTML"
                                },
                                renderContextTableType: "shapeRenderContextTable",
                                svgDispatchTable: {
                                    appendShape: "renderSVG",
                                    init: "initSVG",
                                    setBorderColor: "setBorderColorSVG",
                                    setBorderRadius: "setBorderRadiusSVG",
                                    setBorderStyle: "setBorderStyleSVG",
                                    setBorderWidth: "setBorderWidthSVG",
                                    setExtent: "setExtentSVG",
                                    setFill: "setFillSVG",
                                    setPosition: "setPositionSVG",
                                    setStrokeOpacity: "setStrokeOpacitySVG"
                                },
                                attributeChangedCANVAS: function (ctx, value) {
                                ctx.getCanvas().width = ctx.getCanvas().width; // erase canvas;
                                this.renderCANVAS(ctx)
                            },
                                bounds: function () { return this.getBounds() },
                                compensateShapeNode: function (ctx) {
                                // compensates the shapeNode's position for childmorphs,
                                // positions childmorphs against morphNodes (origin!)
                                if (!ctx.originNode) return;
                                ctx.originNode.style.setProperty(
                                    'top', -this.getPosition().y + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'left', -this.getPosition().x + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'position', 'absolute', 'important');
                        
                                // FIXME: hack, necessary until the style editor knows
                                // about stroke widths of svg lines instead of using borderWidth...
                                if (ctx.pathNode) return;
                        
                                // compensates the shapeNode's borderWidth for childmorphs,
                                // borders don't affect submorphs
                                ctx.originNode.style.setProperty(
                                    'margin-top', -this.getBorderWidth() + 'px', 'important');
                                ctx.originNode.style.setProperty(
                                    'margin-left', -this.getBorderWidth() + 'px', 'important');
                            },
                                constructor: lively.morphic.Shapes.Shape.subclass('lively.morphic.Shapes.Rectangle', 'default category', {initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    }}),
                                createShapeNode: function (ctx) { return ctx.domInterface.svgRect() },
                                defaultRenderContext: function () { return null },
                                getAppearanceStylingMode: function () {
                                return this.shapeGetter('AppearanceStylingMode');
                            },
                                getBorderColor: function () {
                                var fill = this.shapeGetter('BorderColor');
                                return fill === undefined ? Color.red : fill;
                            },
                                getBorderRadius: function () { return this.shapeGetter('BorderRadius')  || 0 },
                                getBorderStyle: function () { return this.shapeGetter('BorderStyle') || 'solid' },
                                getBorderStylingMode: function () {
                                return this.shapeGetter('BorderStylingMode');
                            },
                                getBorderWidth: function () {
                                return this.shapeGetter('BorderWidth')  || 0;
                            },
                                getBounds: function () { return this.getPosition().extent(this.getExtent()) },
                                getClipMode: function () { return this.shapeGetter('ClipMode') || 'visible' },
                                getExtent: function () { return this.shapeGetter('Extent') || pt(0,0); },
                                getFill: function () { return this.shapeGetter('Fill') || null },
                                getFillOpacity: function () {
                                var fill = this.getFill();
                                return (fill && typeof fill.a === "number") ? fill.a : 1;
                            },
                                getNodeClass: function () {
                                return this.shapeGetter('NodeClass') || [];
                            },
                                getNodeId: function () {
                                return this.shapeGetter('NodeId')
                            },
                                getOpacity: function () {
                                var op = this.shapeGetter('Opacity');
                                return op === undefined ? 1 : Number(op);
                            },
                                getPadding: function () {
                                return this.shapeGetter('Padding') || this.setPadding(new Rectangle(0,0,0,0));
                            },
                                getPosition: function () { return this.shapeGetter('Position') || pt(0,0) },
                                getStrokeOpacity: function () {
                                var op = this.shapeGetter('StrokeOpacity');
                                return op === undefined ? 1 : op;
                            },
                                initCANVAS: function () {},
                                initHTML: function ($super, ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = ctx.domInterface.htmlRect();
                                $super(ctx);
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                            },
                                initSVG: function (ctx) {
                                if (!ctx.shapeNode)
                                    ctx.shapeNode = this.createShapeNode(ctx);
                                this.setPositionSVG(ctx, this.getPosition());
                                this.setExtentSVG(ctx, this.getExtent());
                                this.setFillSVG(ctx, this.getFill());
                                this.setBorderWidthSVG(ctx, this.getBorderWidth());
                                this.setBorderColorSVG(ctx, this.getBorderColor());
                                this.setStrokeOpacitySVG(ctx, this.getStrokeOpacity());
                            },
                                initialize: function (bounds) {
                                                        if (bounds) this.setBounds(bounds);
                                                    },
                                reallyContainsPoint: function (pt) {
                                // Overridden for non-rectangular shapes like lines and ellipses
                                // Note assumes that pt is within this.bounds
                                return true
                            },
                                renderCANVAS: function (ctx) {
                                var graphicContext = ctx.getGraphicContext(),
                                    pathSet = false,
                                    bounds = this.getBounds(),
                                    fill = this.getFill();
                                if (fill) { // Fill first, then stroke
                                    var alpha = this.getFillOpacity();
                                    if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    graphicContext.fillStyle = ctx.canvasFillFor(fill, graphicContext, bounds);
                                    this.setPath(graphicContext, bounds);
                                    graphicContext.fill();
                                    pathSet = true;
                                }
                                // if (this.getStroke() && this.getStrokeWidth() > 0) {
                                    // var alpha = this.getStrokeOpacity();
                                    // if (alpha != 1) graphicContext.globalAlpha = alpha;
                                    // graphicContext.strokeStyle = this.canvasFillFor(this.getStroke(), graphicContext, bounds);
                                    // graphicContext.lineWidth = this.getStrokeWidth();
                                    // this.drawStrokeOn(graphicContext, bounds, pathSet);
                                // }
                            },
                                renderContext: function () {
                                if (!this._renderContext) this.setRenderContext(this.defaultRenderContext());
                                return this._renderContext;
                            },
                                renderContextDispatch: function (aspect, arg) {
                                if (!this._renderContext) this.renderContext();
                                // if we cannot lazy initialize the renderContext we just do nothing
                                if (!this._renderContext) return undefined;
                                var renderSpecificAspect = this._renderContext[this.renderContextTableType][aspect];
                                if (!renderSpecificAspect) {
                                    dbgOn(true, 'renderContextTable does no include: ' + aspect);
                                    return undefined;
                                }
                                return this[renderSpecificAspect](this._renderContext, arg);
                            },
                                renderHTML: function (ctx) {
                                if (ctx.shapeNode.parentNode) return;
                                var child = ctx.morphNode.childNodes[0];
                                if (!child) ctx.morphNode.appendChild(ctx.shapeNode)
                                else ctx.morphNode.insertBefore(ctx.shapeNode, child)
                            },
                                renderSVG: function (ctx) {
                                if (!ctx.shapeNode.parentNode)
                                    ctx.morphNode.insertBefore(ctx.shapeNode, ctx.morphNode.childNodes[0])
                            },
                                renderUsing: function (renderContext) {
                                this.setRenderContext(renderContext);
                                this.renderContextDispatch('init');
                                this.renderContextDispatch('appendShape');
                            },
                                setAppearanceStylingMode: function (value) {
                                return this.shapeSetter('AppearanceStylingMode', value);
                            },
                                setAppearanceStylingModeHTML: function (ctx, value) {
                                this.setFillHTML(ctx, this.shapeGetter("Fill"));
                                this.setOpacityHTML(ctx, this.shapeGetter("Opacity"));
                            },
                                setBorderColor: function (fill) { return this.shapeSetter('BorderColor', fill) },
                                setBorderColorHTML: function (ctx, fill) {
                                var alpha;
                                if (this.getStrokeOpacity() != 1) {
                                    alpha = this.getStrokeOpacity();
                                } else {
                                    alpha = fill === null ? 0 : fill.a;
                                }
                                return this.setBorderHTML(ctx, this.getBorderWidth(), fill, alpha)
                            },
                                setBorderColorSVG: function () {},
                                setBorderHTML: function (ctx, width, fill, opacity) {
                                if (ctx.shapeNode && this.shapeGetter('BorderStylingMode')) {
                                    ctx.shapeNode.style['border'] = null;
                                    this.compensateShapeNode(ctx);
                                } else {
                                    return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderHTML").call(this, ctx, width, fill, opacity);
                                }
                            },
                                setBorderRadius: function (value) { this.shapeSetter('BorderRadius', value) },
                                setBorderRadiusHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLRectangleTrait').getOriginalMethodFor(lively.morphic.Shapes.Rectangle, "setBorderRadiusHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderRadiusSVG: function () {},
                                setBorderStyle: function (value) {
                                // style can be hidden dotted dashed solid double groove ridge	inset outset inherit
                                return this.shapeSetter('BorderStyle', value);
                            },
                                setBorderStyleHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setBorderStyleHTML").call(this, ctx, ctx.shapeNode && this.shapeGetter('BorderStylingMode') ? null : value);
                            },
                                setBorderStyleSVG: function (ctx, value) {
                                if (value == 'dashed')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '7 4')
                                else if (value == 'dotted')
                                    ctx.shapeNode.setAttribute('stroke-dasharray', '2 2')
                                else
                                    ctx.shapeNode.removeAttribute('stroke-dasharray')
                            },
                                setBorderStylingMode: function (value) {
                                return this.shapeSetter('BorderStylingMode', value);
                            },
                                setBorderStylingModeHTML: function (ctx, value) {
                                this.setBorderHTML(
                                    ctx, this.getBorderWidth(), this.getBorderColor(), this.getStrokeOpacity());
                                this.setBorderRadiusHTML(ctx, this.getBorderRadius());
                                this.setExtentHTML(ctx, this.getExtent());
                            },
                                setBorderWidth: function (width) { return this.shapeSetter('BorderWidth', width) },
                                setBorderWidthHTML: function (ctx, width) {
                                if (this.getBorderStylingMode()) {
                                    ctx.shapeNode.style.border = '';
                                    ctx.shapeNode.style.borderWidth = width+'px';
                                } else {
                                    ctx.shapeNode.style.borderWidth = '';
                                    this.setBorderHTML(ctx, width, this.getBorderColor(), this.getStrokeOpacity());
                                }
                                this.compensateShapeNode(ctx);
                                this.setExtentHTML(ctx, this.getExtent());
                                return width;
                            },
                                setBorderWidthSVG: function (ctx, value) {
                                // var node = this.getPathNodeHTML(ctx);
                                // node && node.setAttribute('stroke-width', String(value))
                            },
                                setBounds: function (bounds) {
                                this.setPosition(bounds.topLeft());
                                this.setExtent(bounds.extent());
                                return bounds
                            },
                                setClipMode: function (modeString) { return this.shapeSetter('ClipMode', modeString) },
                                setExtent: function (extent, scrollBarExtent) { return this.shapeSetter('Extent', extent) },
                                setExtentHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return undefined;
                                var padding = this.getPadding(),
                                    paddingWidth = padding.left() + padding.right(),
                                    paddingHeight = padding.top() + padding.bottom(),
                                    // HTML isn't using fractions for pixels, rounds internally,
                                    // this has to be reflected to compensate HTML's box model
                                    borderWidth = Math.floor(this.getBorderWidth()),
                                    realExtent = value
                                                 .addXY(-2 * borderWidth, -2 * borderWidth)
                                                 .addXY(-paddingWidth, -paddingHeight);
                                    realExtent = realExtent.maxPt(pt(0,0));
                                ctx.domInterface.setExtent(ctx.shapeNode, realExtent);
                                return realExtent;
                            },
                                setExtentSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setExtent(ctx.shapeNode, value);
                                // update also parents so that shapes is not clipped... really necassary? FIXME
                                // if (ctx.morphNode)
                                    // ctx.domInterface.setExtent(ctx.morphNode, value);
                                // if (ctx.morphNode.parentNode.tagName == 'svg')
                                    // ctx.domInterface.setExtent(ctx.morphNode.parentNode, value);
                            },
                                setFill: function (fill) { return this.shapeSetter('Fill', fill) },
                                setFillHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setFillHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setFillOpacity: function (opacity) {
                                var fill = this.getFill()
                                if (fill && fill.withA)
                                    this.setFill(fill.withA(opacity))
                            },
                                setFillSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setFill(ctx.shapeNode, value);
                            },
                                setNodeClass: function (value) {
                                return this.shapeSetter('NodeClass', value);
                            },
                                setNodeId: function (value) {
                                return this.shapeSetter('NodeId', value);
                            },
                                setNodeIdHTML: function (ctx, id) {
                                ctx.shapeNode && ctx.shapeNode.setAttribute('id', id);
                                return id;
                            },
                                setOpacity: function (opacity) { return this.shapeSetter('Opacity', opacity) },
                                setOpacityHTML: function (ctx, value) {
                                return Trait('StyleSheetsHTMLShapeTrait').getOriginalMethodFor(lively.morphic.Shapes.Shape, "setOpacityHTML").call(this, ctx, this.shapeGetter('AppearanceStylingMode') ? null : value);
                            },
                                setPadding: function (rect) { return this.shapeSetter('Padding', rect) },
                                setPaddingHTML: function (ctx, r) {
                                if (r === undefined || !ctx.shapeNode) return r;
                                // Rectangle.inset(left, top, right, bottom) ==>
                                // CSS padding: [padding-top] [padding-right] [padding-bottom] [padding-left]
                                var s = r.top() + "px " + r.right() + "px " + r.bottom() + "px " + r.left() + "px";
                                ctx.shapeNode.style.padding = s;
                                return r;
                            },
                                setPath: function (graphicContext, bnds) { // Rectangular default my be overridden
                                graphicContext.beginPath();
                                graphicContext.moveTo(bnds.x, bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.y);
                                graphicContext.lineTo(bnds.maxX(), bnds.maxY());
                                graphicContext.lineTo(bnds.x, bnds.maxY());
                                graphicContext.closePath();
                            },
                                setPosition: function (position) { return this.shapeSetter('Position', position) },
                                setPositionHTML: function (ctx, value) {
                                if (!ctx.shapeNode) return;
                                ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                                if (ctx.originNode) {
                                    this.compensateShapeNode(ctx);
                                }
                            },
                                setPositionSVG: function (ctx, value) {
                                if (ctx.shapeNode)
                                    ctx.domInterface.setPosition(ctx.shapeNode, value, 'absolute');
                            },
                                setRenderContext: function (newRenderContext) {
                                if (newRenderContext) {
                                    newRenderContext[this.renderContextTableType] = Object.mergePropertyInHierarchy(
                                        this, newRenderContext.renderContextTableName);
                                }
                                this._renderContext = newRenderContext;
                            },
                                setStrokeOpacity: function (opacity) { return this.shapeSetter('StrokeOpacity', opacity) },
                                setStrokeOpacityHTML: function (ctx, opacity) {
                                return this.setBorderHTML(ctx, this.getBorderWidth(), this.getBorderColor(), opacity)
                            },
                                setStrokeOpacitySVG: function () {},
                                setVertices: function () {
                                // This does nothing for non path shapes
                            },
                                shapeGetter: function (propName) { return this['_' + propName] },
                                shapeSetter: function (propName, value) {
                                if (value === undefined) {
                                    delete this['_' + propName];
                                } else {
                                    this['_' + propName] = value;
                                }
                                return this.renderContextDispatch('set' + propName, value);
                            },
                                vertices: function () {
                                var b = this.bounds();
                                return [pt(b.x, b.y), pt(b.width, b.height)]
                            }
                            },
                            sourceModule: "lively.morphic.TextCore",
                            textString: "Subentanglements",
                            onMouseDown: function onMouseDown(evt) {
                                    if (evt.isLeftMouseButtonDown() && this.owner.owner.item.onSelect) {
                                        this.owner.owner.getRootTree().select(this.owner.owner);
                                    }
                                }
                        }]
                    }]
                }]
            }],
            tree: {
                isMorphRef: true,
                name: "tree-view"
            },
            marshallEntanglement: function marshallEntanglement(entanglement, name) {
                    var treeItems = {name: name || 'Entanglement', style: '', children: []};
                
                    // the tree should be structured as follows:
                    // 1. primitive properties
                    // 2. directly referenced subEntnaglements -> 
                    // 3. in a visually differentiated entry we store all the subEntanglements
                    //    that are not referenced directly
                    
                    // we first include the special Subentanglements attribute that we add just pro forma:
                    
                    var subEntanglementsItem =  {name: 'Subentanglements', style: '', children: [], description: ''};
                    var alreadyTraversed = [];
                    
                    function addTreeItemFor(attr) {
                        var value = entanglement.get(attr);
                        if(Object.isFunction(value) 
                            || attr.startsWith('$$')
                            || $.inArray(attr, ['submorphs','attributeConnections', 'doNotSerialize', 'doNotCopyProperties']) > -1)
                            return;
                        if(!value || !value.isEntanglement) {
                            // if this is just a primitive object, we add it to the current entanglement
                            var item = {name: attr, value: value, description: value && value.toString()}
                            treeItems.children.push(item);
                            // as this is a primitive object, we connect it and the variable inside the entanglement,
                            // to monitor all changes that happen and update this on the fly inside the view
                            connect(entanglement.entangledAttributes, attr, this , 'updateLabel', 
                                    {updater: function($proceed, oldValue, newValue) {
                                        $proceed(item, newValue);
                                    }, varMapping: {item: item}
                                });
                        } else {
                            // in the other case, we traverse it further
                            alreadyTraversed.push(value);
                            treeItems.children.push(this.marshallEntanglement(value, attr));
                        }
                    }
                    
                    for ( var attr in entanglement.entangledAttributes ) {
                        addTreeItemFor.call(this, attr);
                    }
                    
                    entanglement.subEntanglements.withoutAll(alreadyTraversed).forEach(function(subEnt) {
                       subEntanglementsItem.children.push(this.marshallEntanglement(subEnt)); 
                    }, this);
                    
                    if(subEntanglementsItem.children)
                        treeItems.children.push(subEntanglementsItem);
                    
                    return treeItems;
                },
            updateLabel: function updateLabel(item, value) {
                        // the tree generates and removes nodes dynamically with respect
                        // to the user interaction. We therfore need to fetch the corresponding node
                        // manually for this item every time something changes:
                        var node = this.tree.withAllTreesDetect(function(t) { return t.item == item; });
                        // the user might not have expanded the tree such that the item is visible
                        // in that case we do not have to update the entry, obviously
                        if(node) {
                            node.item.description = value.toString();
                            node.updateLabel(item);
                        }
                },
            visualize: function visualize(entanglement) {
                    var items = this.marshallEntanglement(entanglement);
                    this.tree.setItem(items);
                }
        }],
        aboutMe: function aboutMe() {
            //  This is an experiment in drag-and-drop construction of
            //  paned window apps. 
            // 
            //  The idea is that each widget will have a "plug" reminiscent
            //  of Squeak's pluggable views.  From the plug, this panel
            //  will strive to create all the necessary connections and 
            //  stubbed methods appropriate to operation of that widget.
            //  Gridding assistance and other style defauts will facilitate
            //  rapid construction of pleasing practical apps.
            //
            //  Renaming of the widgets will be supported, but this clearly
            //  becomes more difficult as construction progresses, since the 
            //  stubbed methods, etc will be synchronized with the widget names.
            // 
            //  A further aspiration of this experiment is to automatically
            //  generate a buildView method correponding to the concretely
            //  constructed app.
        },
        addMorph: function addMorph(widget) {
            // Override addMorph to provide gridding and docking of plugs
            $super(widget);  // momentarily install to get local bounds
            var bnds = widget.getBounds();
            var name = widget.getName();
            if (!name) return widget;
            
            if (widget.isList) {
                widget.remove();  // replace by our special version
                var m = this.newListPane(bnds); }
            else if (widget.isText) {
                widget.remove();  // replace by our special version
                var m = this.newCodePane(bnds); }
            else return widget;
            
            m.setName(name);
            $super(m);
            this.plugIn(m);
            return m;
        },
        buildView: function buildView(extent) {  // this.buildView()
            // Disassemble prior view if present and set extent if not null
            this.restart(extent);
        
            // Lay out new widgets
            lively.morphic.Panel.makePanedPanel(extent, [
        		['classPane', this.newListPane, new Rectangle(0, 0, 0.5, 0.6)],
        		['methodPane', this.newListPane, new Rectangle(0.5, 0, 0.5, 0.6)],
        		['codePane', this.newCodePane, new Rectangle(0, 0.6, 1, 0.4)],
        	], this);
        
            // Connect widgets to this panel as model
            connect(this.classPane, "selection", this, "setSelectedClass", {});
            connect(this.methodPane, "selection", this, "setMethodName", {});
        
            // Initialize this panel as model
            this.onLoad();
        },
        entangledMorphsListMenuItems: function entangledMorphsListMenuItems(menuItems) {
    },
        entangledMorphsListSelection: function entangledMorphsListSelection(selection) {
    },
        entangledMorphsListSetList: function entangledMorphsListSetList(setList) {
    	this.entangledMorphsList.setList(setList);
    },
        methodStubFor: function methodStubFor(widget, propName) {
            // returns {methodName: 'nnn', methodString: 'sss'}
            var mode = widget.plug[propName];
            var widgetName = this.uncapitalize(widget.getName());
            var methodName = widgetName + propName.capitalize();
            var methodString = 'function ' + methodName + '(' + propName + ') {\n'
            if (mode == 'input') methodString +=
                '\tthis.' + widgetName + '.' + propName + '(' + propName + ');\n';
            methodString += '}';
            return {widgetName: widgetName, methodName: methodName, methodString: methodString};
        },
        newCodePane: function newCodePane(bnds, morphorNull) {
            // This method should be inherited for all apps
            var codePane = morphorNull || newTextPane(bnds);
            codePane.enableSyntaxHighlighting();
            codePane.evalEnabled = true;
            codePane.doSave = function() {
                this.cachedTextString = null;
                this.savedTextString = this.textString;
                if (this.methodPane.selection) {
                    alertOK('eval'); 
                    this.tryBoundEval('this.' + panel.methodPane.selection + ' = ' + this.savedTextString)
                }
            }
            codePane.applyStyle({scaleProportional: true});
            codePane.plug = {setTextString: 'input', getTextString: 'output', menuItems: 'output'}
            this.wrapWidget(codePane);  // Override remove to clean up stubs
            return codePane
        },
        newListPane: function newListPane(bnds, morphorNull) {
            // This method should be inherited for all apps
            var list = morphorNull || new lively.morphic.List(bnds);
            list.applyStyle({scaleProportional: true});
            list.plug = {setList: 'input', selection: 'output', menuItems: 'output'}
            this.wrapWidget(list);  // Override remove to clean up stubs
            return list;
        },
        onLoad: function onLoad() {  // this.onLoad()
            // Call a method here to initialize state upon loading
        },
        plugIn: function plugIn(widget) {
            // set up connect and stub methods based on widget.plug
            if (!widget.plug) return;
            var plug = widget.plug;
            ownPropertyNames(plug).forEach(function (prop) {
                var stub = this.methodStubFor(widget, prop);
                //  Add method stub
                var script = this.addScript(eval('(' + stub.methodString + ')'));
                script.setProperty("tags", ["app methods"]);
                //  Add connection for outputs
                if (plug[prop] == 'output')
                    connect(widget, prop, this, stub.methodName)
                //  Add own variable for each widget
                this[stub.widgetName] = widget;
                }, this)
        },
        renamePart: function renamePart(part, oldName, newName) {
            // setName must be wrapped to call this
            console.log('Renaming ' + oldName + ' to ' + newName)
            // We will simply remove all old stubs (safely) and then install again
        },
        reset: function reset() {  // this.reset()
            //  Call a method to clear state for saving in parts bin
        },
        restart: function restart(extent) {  // this.restart()
            // Use new frame if supplied
            extent = extent || this.getExtent();
            this.applyStyle({adjustForNewBounds: true, fill: Color.gray});
            this.layout.grid = this.innerBounds().extent().scaleBy(1/20);
        
            // Disassemble prior view and connections
            this.removeAllMorphs();  // this should handle disconnect and unplug
        },
        setExtent: function setExtent(newExt) {
            var result = $super(newExt);
            this.layout.grid = this.innerBounds().extent().scaleBy(1/20);
            return result;
        },
        unPlug: function unPlug(widget) {
            // remove stub methods based on widget.plug
            if (!widget.plug) return;
            var plug = widget.plug;
            ownPropertyNames(plug).forEach(function (prop) {
                var stub = this.methodStubFor(widget, prop);
                // remove method stubs that have not been edited
                if (this[stub.methodName]
                    && this[stub.methodName].toString() == stub.methodString)
                    delete this[stub.methodName];
                // remove connection for outputs
                if (plug[prop] == 'output')
                    disconnect(widget, prop, this, stub.methodName)
                // remove own variable for widget
                if (this[stub.widgetName]) console.log('deleting ' + stub.widgetName);
                if (this[stub.widgetName]) delete this[stub.widgetName];
                }, this)
        },
        uncapitalize: function uncapitalize(name) {
            // By symmetry with <string>.capitalize()
            return name.charAt(0).toLowerCase() + name.slice(1);
        },
        wrapWidget: function wrapWidget(widget) {
            // Clean up stubs when a widget is removed or renamed
            var self = this;
            widget.remove = widget.remove.wrap(
                function(wrapped) {
                    var args = $A(arguments); args.shift();
                    if (this.owner !== self)
                        return wrapped.apply(this, args);
                    self.unPlug(this);
                    this.remove = wrapped;  // restore remove
                    return wrapped.apply(this, args);
                });
            widget.setName = widget.setName.wrap(
                function(wrapped) {
                    var args = $A(arguments); args.shift();
                    if (this.owner !== self || !this.getName())
                        return wrapped.apply(this, args);
                    self.unPlug(this);
                    var result = wrapped.apply(this, args);
                    self.plugIn(this);
                    return result;
                });
        },
        yetToDo: function yetToDo() {
        //  [X] Write code to intercept addMorph()
        //  [X]     gridding
        //  [X]     other defaults such as layout, borders, etc
        //  [X]     define plugs for, eg, list and text
        //  [X]     add stub methods for plugs
        //  [X]     add connections for outputs
        //  [X] Remove stubs when remove parts
        //  [X] Make safeRemove that checks for unchanged stubs
        //  [X] Remove connections when remove parts
        //  [X] Support renaming of parts by safeRemove, followed by add
        //  [X] Add and remove own variable refs
        //  [X] Test by building a browser
        //  [ ] Write code that will generate buildView method
        }
    }],
    targetMorph: {
        isMorphRef: true,
        path: "submorphs.0"
    },
    titleBar: "Entanglement Inspector",
    tree: {
        isMorphRef: true,
        name: "tree-view"
    },
    createEntangledObj: function createEntangledObj() {
    // Something to think about: How to supply the user with an interface for
    // excluding specific interfaces?
    var m = this.entanglement.createEntangledMorph({excludes: ['setPosition']});
    m.setPosition(pt(0));
    m.openInHand();
},
    marshallEntanglement: function marshallEntanglement(entanglement, name) {
    var treeItems = {name: name || 'Entanglement', style: '', children: []};

    // the tree should be structured as follows:
    // 1. primitive properties
    // 2. directly referenced subEntnaglements -> 
    // 3. in a visually differentiated entry we store all the subEntanglements
    //    that are not referenced directly
    
    // we first include the special Subentanglements attribute that we add just pro forma:
    
    var subEntanglementsItem =  {name: 'Subentanglements', style: '', children: [], description: ''};
    var alreadyTraversed = [];
    
    function addTreeItemFor(attr) {
        var value = entanglement.get(attr);
        if(Object.isFunction(value) 
            || attr.startsWith('$$')
            || $.inArray(attr, ['submorphs','attributeConnections', 'doNotSerialize', 'doNotCopyProperties']) > -1)
            return;
        if(!value || !value.isEntanglement) {
            // if this is just a primitive object, we add it to the current entanglement
            var item = {name: attr, value: value, description: value && value.toString()}
            treeItems.children.push(item);
            // as this is a primitive object, we connect it and the variable inside the entanglement,
            // to monitor all changes that happen and update this on the fly inside the view
            connect(entanglement.entangledAttributes, attr, this , 'updateLabel', 
                    {updater: function($proceed, oldValue, newValue) {
                        $proceed(item, newValue);
                    }, varMapping: {item: item}
                });
        } else {
            // in the other case, we traverse it further
            alreadyTraversed.push(value);
            treeItems.children.push(this.marshallEntanglement(value, attr));
        }
    }
    
    for ( var attr in entanglement.entangledAttributes ) {
        addTreeItemFor.call(this, attr);
    }
    
    entanglement.subEntanglements.withoutAll(alreadyTraversed).forEach(function(subEnt) {
       subEntanglementsItem.children.push(this.marshallEntanglement(subEnt)); 
    }, this);
    
    if(subEntanglementsItem.children.length > 0)
        treeItems.children.push(subEntanglementsItem);
    
    return treeItems;
},
    updateLabel: function updateLabel(item, value) {
        // the tree generates and removes nodes dynamically with respect
        // to the user interaction. We therfore need to fetch the corresponding node
        // manually for this item every time something changes:
        var node = this.tree.withAllTreesDetect(function(t) { return t.item == item; });
        // the user might not have expanded the tree such that the item is visible
        // in that case we do not have to update the entry, obviously
        if(node) {
            node.item.description = value.toString();
            node.updateLabel(item);
        }
},
    visualize: function visualize(entanglement) {
    var items = this.marshallEntanglement(entanglement);
    this.entanglement = entanglement;
    this.tree.setItem(items);
    this.ListListener && this.listListener.disconnect();
    this.morphList.getList().forEach(
        function(i) { this.morphList.removeItemOrValue(i); }, 
        this);
    entanglement.entangledMorphs.forEach(
        function(morph) { this.morphList.addItem(morph) }, this );
        
    // also setup a connection with the list of entangled morphs,
    // so that we always find out about new morphs that are added
    this.listListener = connect(this.entanglement, 'createEntangledMorph', this.morphList, 'addItem', {updater: function($proceed, newV, oldV) { $proceed(newV); return newV; }});
    connect(this.entanglement.entangledMorphs, 'remove', this.morphList, 'removeItem');
}
});

})
